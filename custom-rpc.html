<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Custom RPCs - Substrate Recipes</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A Hands-On Cookbook for Aspiring Blockchain Chefs">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="pallets-intro.html"><strong aria-hidden="true">1.</strong> Pallets</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="runtime-printing.html"><strong aria-hidden="true">1.1.</strong> Printing to the Node Log</a></li><li class="chapter-item expanded "><a href="events.html"><strong aria-hidden="true">1.2.</strong> Emitting Events</a></li><li class="chapter-item expanded "><a href="storage-maps.html"><strong aria-hidden="true">1.3.</strong> Storage Maps</a></li><li class="chapter-item expanded "><a href="cache.html"><strong aria-hidden="true">1.4.</strong> Cache Locally &gt; Storage Calls</a></li><li class="chapter-item expanded "><a href="vec-set.html"><strong aria-hidden="true">1.5.</strong> Using Vectors as Sets</a></li><li class="chapter-item expanded "><a href="map-set.html"><strong aria-hidden="true">1.6.</strong> Using Maps as Sets</a></li><li class="chapter-item expanded "><a href="double.html"><strong aria-hidden="true">1.7.</strong> Subgroup Removal by Subkey: Double Maps</a></li><li class="chapter-item expanded "><a href="structs.html"><strong aria-hidden="true">1.8.</strong> Storing custom structs</a></li><li class="chapter-item expanded "><a href="ringbuffer.html"><strong aria-hidden="true">1.9.</strong> Ringbuffer Queue</a></li><li class="chapter-item expanded "><a href="basic-token.html"><strong aria-hidden="true">1.10.</strong> Basic Token</a></li><li class="chapter-item expanded "><a href="constants.html"><strong aria-hidden="true">1.11.</strong> Configurable Constants</a></li><li class="chapter-item expanded "><a href="crowdfund.html"><strong aria-hidden="true">1.12.</strong> Simple Crowdfund</a></li><li class="chapter-item expanded "><a href="instantiable.html"><strong aria-hidden="true">1.13.</strong> Instantiable Pallets</a></li><li class="chapter-item expanded "><a href="weights.html"><strong aria-hidden="true">1.14.</strong> Weights for Resource Accounting</a></li><li class="chapter-item expanded "><a href="charity.html"><strong aria-hidden="true">1.15.</strong> Charity and Imbalances</a></li><li class="chapter-item expanded "><a href="fixed-point.html"><strong aria-hidden="true">1.16.</strong> Fixed Point Arithmetic</a></li><li class="chapter-item expanded "><a href="off-chain-workers/index.html"><strong aria-hidden="true">1.17.</strong> Off-chain Workers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="off-chain-workers/transactions.html"><strong aria-hidden="true">1.17.1.</strong> Transactions</a></li><li class="chapter-item expanded "><a href="off-chain-workers/http-json.html"><strong aria-hidden="true">1.17.2.</strong> HTTP Fetching &amp; JSON Parsing</a></li><li class="chapter-item expanded "><a href="off-chain-workers/storage.html"><strong aria-hidden="true">1.17.3.</strong> Local Storage</a></li></ol></li><li class="chapter-item expanded "><a href="currency.html"><strong aria-hidden="true">1.18.</strong> Currency Types</a></li><li class="chapter-item expanded "><a href="currency-imbalances.html"><strong aria-hidden="true">1.19.</strong> Currency and Imbalances</a></li><li class="chapter-item expanded "><a href="randomness.html"><strong aria-hidden="true">1.20.</strong> Generating Randomness</a></li><li class="chapter-item expanded "><a href="pallet-coupling.html"><strong aria-hidden="true">1.21.</strong> Tightly- and Loosely-Coupled Pallets</a></li></ol></li><li class="chapter-item expanded "><a href="runtimes-intro.html"><strong aria-hidden="true">2.</strong> Runtimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="runtime-api.html"><strong aria-hidden="true">2.1.</strong> Runtime APIs</a></li><li class="chapter-item expanded "><a href="fees.html"><strong aria-hidden="true">2.2.</strong> Transaction Fees for Economic Security</a></li></ol></li><li class="chapter-item expanded "><a href="consensus-intro.html"><strong aria-hidden="true">3.</strong> Consensus</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="sha3-pow-consensus.html"><strong aria-hidden="true">3.1.</strong> Sha3 Pow Consensus Algorithms</a></li></ol></li><li class="chapter-item expanded "><a href="nodes-intro.html"><strong aria-hidden="true">4.</strong> Nodes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="kitchen-node.html"><strong aria-hidden="true">4.1.</strong> Kitchen Node - An reusable instant seal node</a></li><li class="chapter-item expanded "><a href="custom-rpc.html" class="active"><strong aria-hidden="true">4.2.</strong> Custom RPCs</a></li><li class="chapter-item expanded "><a href="basic-pow.html"><strong aria-hidden="true">4.3.</strong> Basic Proof of Work Node</a></li><li class="chapter-item expanded "><a href="hybrid-consensus.html"><strong aria-hidden="true">4.4.</strong> Hybrid PoW/PoS Consensus Node</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Substrate Recipes</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#custom-rpcs" id="custom-rpcs">Custom RPCs</a></h1>
<p><code>nodes/custom-rpc</code>
<a href="https://playground-staging.substrate.dev/?deploy=recipes&amp;files=%2Fhome%2Fsubstrate%2Fworkspace%2Fnodes%2Frpc-node%2Fsrc%2Fservice.rs">
<img src="https://img.shields.io/badge/Playground-Try%20it!-brightgreen?logo=Parity%20Substrate" alt="Try on playground" />
</a>
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/nodes/rpc-node/src/service.rs">
<img src="https://img.shields.io/badge/Github-View%20Code-brightgreen?logo=github" alt="View on GitHub" />
</a></p>
<p><code>runtimes/api-runtime</code>
<a href="https://playground-staging.substrate.dev/?deploy=recipes&amp;files=%2Fhome%2Fsubstrate%2Fworkspace%2Fruntimes%2Fapi-runtime%2Fsrc%2Flib.rs">
<img src="https://img.shields.io/badge/Playground-Try%20it!-brightgreen?logo=Parity%20Substrate" alt="Try on playground" />
</a>
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/runtimes/api-runtime/src/lib.rs">
<img src="https://img.shields.io/badge/Github-View%20Code-brightgreen?logo=github" alt="View on GitHub" />
</a></p>
<p>Remote Procedure Calls, or RPCs, are a way for an external program (eg. a frontend) to communicate
with a Substrate node. They are used for checking storage values, submitting transactions, and
querying the current consensus authorities. Substrate comes with several
<a href="https://polkadot.js.org/docs/substrate/rpc">default RPCs</a>. In many cases it is useful to add
custom RPCs to your node. In this recipe, we will add three custom RPCs to our node. The first is trivial, the second calls into a <a href="./runtime-api.html">custom runtime API</a>, and the third interfaces with consensus.</p>
<h2><a class="header" href="#the-rpc-extensions-builder" id="the-rpc-extensions-builder">The RPC Extensions Builder</a></h2>
<p>In order to connect custom RPCs you must provide an function known as an &quot;RPC extension builder&quot;. This function takes a parameter for whether the node should deny unsafe RPC calls, and returns an <a href="https://docs.rs/jsonrpc-core/15.0.0/jsonrpc_core/struct.IoHandler.html">IoHandler</a> that the node needs to create a json RPC.</p>
<pre><code class="language-rust ignore">let rpc_extensions_builder = {
	let client = client.clone();
	let pool = transaction_pool.clone();
	Box::new(move |deny_unsafe| {
		let deps = crate::rpc::FullDeps {
			client: client.clone(),
			pool: pool.clone(),
			deny_unsafe,
			command_sink: command_sink.clone(),
		};

		crate::rpc::create_full(deps)
	})
};
</code></pre>
<p>This code is mostly boilerplate and can be reused. The one difference that you will encounter in your own node is the parameters that you pass. Here we've passed four parameters:</p>
<ul>
<li><code>client</code> - will be used in our second RPC</li>
<li>The transaction <code>pool</code> - we will not actually use it but many RPCs do</li>
<li><code>deny_unsafe</code> - whether to deny unsafe calls</li>
<li><code>commands_sink</code> - will be used in our third RPC</li>
</ul>
<p>With this builder function out of the way we can begin attaching our actual RPC endpoints.</p>
<h2><a class="header" href="#the-silly-rpc" id="the-silly-rpc">The Silly RPC</a></h2>
<p>We'll begin by defining a simple RPC called &quot;silly rpc&quot; which just returns integers. A Hello world of sorts.</p>
<h3><a class="header" href="#defining-the-silly-rpc" id="defining-the-silly-rpc">Defining the Silly RPC</a></h3>
<p>Every RPC that the node will use must be defined in a trait. In the
<code>nodes/rpc-node/src/silly_rpc.rs</code> file, we define a basic rpc as</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[rpc]
pub trait SillyRpc {
	#[rpc(name = &quot;silly_seven&quot;)]
	fn silly_7(&amp;self) -&gt; Result&lt;u64&gt;;

	#[rpc(name = &quot;silly_double&quot;)]
	fn silly_double(&amp;self, val: u64) -&gt; Result&lt;u64&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>This definition defines two RPC methods called <code>silly_seven</code> and <code>silly_double</code>. Each RPC method must
take a <code>&amp;self</code> reference and must return a <code>Result</code>. Next, we define a struct that implements this
trait.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Silly;

impl SillyRpc for Silly {
	fn silly_7(&amp;self) -&gt; Result&lt;u64&gt; {
		Ok(7)
	}

	fn silly_double(&amp;self, val: u64) -&gt; Result&lt;u64&gt; {
		Ok(2 * val)
	}
}
<span class="boring">}
</span></code></pre></pre>
<p>Finally, to make the contents of this new file usable, we need to add a line in our <code>main.rs</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod silly_rpc;
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#including-the-silly-rpc" id="including-the-silly-rpc">Including the Silly RPC</a></h3>
<p>With our RPC written, we're ready to extend our <code>IoHandler</code> with it. We begin with a few dependencies in our
<code>rpc-node</code>'s <code>Cargo.toml</code>.</p>
<pre><code class="language-toml">jsonrpc-core = &quot;15.0&quot;
jsonrpc-core-client = &quot;15.0&quot;
jsonrpc-derive = &quot;15.0&quot;
sc-rpc = '2.0.0'
</code></pre>
<p>Now we're ready to write the <code>create_full</code> function we referenced from our service. The function is quoted in its entirety below. You ca see we add the</p>
<pre><code class="language-rust ignore">pub fn create_full&lt;C, P&gt;(
	deps: FullDeps&lt;C, P&gt;,
) -&gt; jsonrpc_core::IoHandler&lt;sc_rpc::Metadata&gt; where
	// --snip--
{

	let mut io = jsonrpc_core::IoHandler::default();

	// Add a silly RPC that returns constant values
	io.extend_with(crate::silly_rpc::SillyRpc::to_delegate(
		crate::silly_rpc::Silly {},
	));

	// --snip--

	io
}
</code></pre>
<p>These few lines extend our node with the Silly RPC.</p>
<h3><a class="header" href="#calling-the-silly-rpc" id="calling-the-silly-rpc">Calling the Silly RPC</a></h3>
<p>Once your node is running, you can test the RPC by calling it with any client that speaks json RPC.
One widely available option is <code>curl</code>.</p>
<pre><code class="language-bash">$ curl http://localhost:9933 -H &quot;Content-Type:application/json;charset=utf-8&quot; -d   '{
     &quot;jsonrpc&quot;:&quot;2.0&quot;,
      &quot;id&quot;:1,
      &quot;method&quot;:&quot;silly_seven&quot;,
      &quot;params&quot;: []
    }'
</code></pre>
<p>To which the RPC responds</p>
<pre><code>{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;:7,&quot;id&quot;:1}
</code></pre>
<p>You may have noticed that our second RPC takes a parameter, the value to double. You can supply this
parameter by including its in the <code>params</code> list. For example:</p>
<pre><code class="language-bash">$ curl http://localhost:9933 -H &quot;Content-Type:application/json;charset=utf-8&quot; -d   '{
     &quot;jsonrpc&quot;:&quot;2.0&quot;,
      &quot;id&quot;:1,
      &quot;method&quot;:&quot;silly_double&quot;,
      &quot;params&quot;: [7]
    }'
</code></pre>
<p>To which the RPC responds with the doubled parameter</p>
<pre><code>{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;:14,&quot;id&quot;:1}
</code></pre>
<h2><a class="header" href="#rpc-to-call-a-runtime-api" id="rpc-to-call-a-runtime-api">RPC to Call a Runtime API</a></h2>
<p>The silly RPC demonstrates the fundamentals of working with RPCs in Substrate. Nonetheless, most
RPCs will go beyond what we've learned so far and actually interacts with other parts of the node.
In this second example, we will include an RPC that calls into the <code>sum-storage</code> runtime API from
the <a href="./runtime-api.html">runtime API recipe</a>. While it isn't strictly necessary to understand what the
runtime API does, reading that recipe may provide helpful context.</p>
<h3><a class="header" href="#defining-the-sum-storage-rpc" id="defining-the-sum-storage-rpc">Defining the Sum Storage RPC</a></h3>
<p>Because this RPC's behavior is closely related to a specific pallet, we've chosen to define the RPC
in the pallet's directory. In this case the RPC is defined in <code>pallets/sum-storage/rpc</code>. So rather
than using the <code>mod</code> keyword as we did before, we must include this RPC definition in the node's
<code>Cargo.toml</code> file.</p>
<pre><code class="language-toml">sum-storage-rpc = { path = &quot;../../pallets/sum-storage/rpc&quot; }
</code></pre>
<p>Defining the RPC interface is similar to before, but there are a few differences worth noting.
First, the struct that implements the RPC needs a reference to the <code>client</code>. This is necessary so we
can actually call into the runtime. Second the struct is generic over the <code>BlockHash</code> type. This is
because it will call a runtime API, and runtime APIs must always be called at a specific block.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[rpc]
pub trait SumStorageApi&lt;BlockHash&gt; {
	#[rpc(name = &quot;sumStorage_getSum&quot;)]
	fn get_sum(
		&amp;self,
		at: Option&lt;BlockHash&gt;
	) -&gt; Result&lt;u32&gt;;
}

/// A struct that implements the `SumStorageApi`.
pub struct SumStorage&lt;C, M&gt; {
	client: Arc&lt;C&gt;,
	_marker: std::marker::PhantomData&lt;M&gt;,
}

impl&lt;C, M&gt; SumStorage&lt;C, M&gt; {
	/// Create new `SumStorage` instance with the given reference to the client.
	pub fn new(client: Arc&lt;C&gt;) -&gt; Self {
		Self { client, _marker: Default::default() }
	}
}
<span class="boring">}
</span></code></pre></pre>
<p>The RPC's implementation is also similar to before. The additional syntax here is related to calling
the runtime at a specific block, as well as ensuring that the runtime we're calling actually has the
correct runtime API available.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;C, Block&gt; SumStorageApi&lt;&lt;Block as BlockT&gt;::Hash&gt;
	for SumStorage&lt;C, Block&gt;
where
	Block: BlockT,
	C: Send + Sync + 'static,
	C: ProvideRuntimeApi,
	C: HeaderBackend&lt;Block&gt;,
	C::Api: SumStorageRuntimeApi&lt;Block&gt;,
{
	fn get_sum(
		&amp;self,
		at: Option&lt;&lt;Block as BlockT&gt;::Hash&gt;
	) -&gt; Result&lt;u32&gt; {

		let api = self.client.runtime_api();
		let at = BlockId::hash(at.unwrap_or_else(||
			// If the block hash is not supplied assume the best block.
			self.client.info().best_hash
		));

		let runtime_api_result = api.get_sum(&amp;at);
		runtime_api_result.map_err(|e| RpcError {
			code: ErrorCode::ServerError(9876), // No real reason for this value
			message: &quot;Something wrong&quot;.into(),
			data: Some(format!(&quot;{:?}&quot;, e).into()),
		})
	}
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#installing-the-sum-storage-rpc" id="installing-the-sum-storage-rpc">Installing the Sum Storage RPC</a></h3>
<p>To install this RPC , we expand the existing <code>create_full</code> function from <code>rpc.rs</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>io.extend_with(sum_storage_rpc::SumStorageApi::to_delegate(
	sum_storage_rpc::SumStorage::new(client),
));
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#using-rpc-parameters" id="using-rpc-parameters">Using RPC Parameters</a></h3>
<p>This RPC takes a parameter ,<code>at</code>, whose type is <code>Option&lt;_&gt;</code>. We may call this RPC by omitting the
optional parameter entirely. In this case the implementation provides a default value of the best
block.</p>
<pre><code class="language-bash">$ curl http://localhost:9933 -H &quot;Content-Type:application/json;charset=utf-8&quot; -d   '{
     &quot;jsonrpc&quot;:&quot;2.0&quot;,
      &quot;id&quot;:1,
      &quot;method&quot;:&quot;sumStorage_getSum&quot;,
      &quot;params&quot;: []
    }'
</code></pre>
<p>We may also call the RPC by providing a block hash. One easy way to get a block hash to test this
call is by copying it from the logs of a running node.</p>
<pre><code class="language-bash">$ curl http://localhost:9933 -H &quot;Content-Type:application/json;charset=utf-8&quot; -d   '{
     &quot;jsonrpc&quot;:&quot;2.0&quot;,
      &quot;id&quot;:1,
      &quot;method&quot;:&quot;sumStorage_getSum&quot;,
      &quot;params&quot;: [&quot;0x87b2e4b93e74d2f06a0bde8de78c9e2a9823ce559eb5e3c4710de40a1c1071ac&quot;]
    }'
</code></pre>
<p>As an exercise, change the storage values and confirm that the RPC provides the correct updated sum.
Then call the RPC at an old block and confirm you get the old sum.</p>
<h3><a class="header" href="#polkadot-js-api" id="polkadot-js-api">Polkadot JS API</a></h3>
<p>Many frontends interact with Substrate nodes through Polkadot JS API. While the Recipes does not
strive to document that project, we have included a snippet of javascript for interacting with these first two
custom RPCs in the <code>nodes/rpc-node/js</code> directory.</p>
<h2><a class="header" href="#the-manual-seal-rpc" id="the-manual-seal-rpc">The Manual Seal RPC</a></h2>
<p>Our third and final example RPC will interact with consensus. Specifically, it will tell the consensus engine when to author and finalize blocks. The API for this RPC if defined in Substrate in the <a href="https://substrate.dev/rustdocs/v2.0.0/sc_consensus_manual_seal/rpc/trait.ManualSealApi.html"><code>ManualSealApi</code> Trait</a>.</p>
<h3><a class="header" href="#installing-the-manual-seal-rpc" id="installing-the-manual-seal-rpc">Installing the Manual Seal RPC</a></h3>
<p>The previous RPC needed a reference to the <code>client</code> to call into the runtime. Likewise, this RPC needs a command stream to send messages to the actual consensus engine. This recipe does not cover installing the manual seal engine, but it is nearly identical to the <a href="https://substrate.dev/rustdocs/v2.0.0/sc_consensus_manual_seal/fn.run_instant_seal.html">instant seal engine</a> used in the <a href="./kitchen-node.html">Kitchen Node</a>.</p>
<p>To install the RPC endpoint, we do exactly as we have before, and extend the <code>create_full</code> function in <code>rpc.rs</code></p>
<pre><code class="language-rust ignore">io.extend_with(
	// We provide the rpc handler with the sending end of the channel to allow the rpc
	// send EngineCommands to the background block authorship task.
	ManualSealApi::to_delegate(ManualSeal::new(command_sink)),
);
</code></pre>
<h3><a class="header" href="#using-manual-seal" id="using-manual-seal">Using Manual Seal</a></h3>
<p>Once your node is running, you will see that it just sits there idly. It will accept transactions to
the pool, but it will not author blocks on its own. In manual seal, the node does not author a block
until we explicitly tell it to. We can tell it to author a block by calling the <code>engine_createBlock</code>
RPC.</p>
<pre><code class="language-bash">$ curl http://localhost:9933 -H &quot;Content-Type:application/json;charset=utf-8&quot; -d   '{
     &quot;jsonrpc&quot;:&quot;2.0&quot;,
      &quot;id&quot;:1,
      &quot;method&quot;:&quot;engine_createBlock&quot;,
      &quot;params&quot;: [true, false, null]
    }'
</code></pre>
<p>This call takes three parameters, each of which are worth exploring.</p>
<h4><a class="header" href="#create-empty" id="create-empty">Create Empty</a></h4>
<p><code>create_empty</code> is a Boolean value indicating whether empty blocks may be created. Setting
<code>create-empty</code> to true does not mean that an empty block will necessarily be created. Rather it
means that the engine should go ahead creating a block even if no transaction are present. If
transactions are present in the queue, they will be included regardless of <code>create_empty</code>'s value.'</p>
<h4><a class="header" href="#finalize" id="finalize">Finalize</a></h4>
<p><code>finalize</code> is a Boolean indicating whether the block (and its ancestors, recursively) should be
finalized after creation. Manually controlling finality is interesting, but also dangerous. If you
attempt to author and finalize a block that does not build on the best finalized chain, the block
will not be imported. If you finalize one block in one node, and a conflicting block in another
node, you will cause a safety violation when the nodes synchronize.</p>
<h4><a class="header" href="#parent-hash" id="parent-hash">Parent Hash</a></h4>
<p><code>parent_hash</code> is an optional hash of a block to use as a parent. To set the parent, use the format
<code>&quot;0x0e0626477621754200486f323e3858cd5f28fcbe52c69b2581aecb622e384764&quot;</code>. To omit the parent, use
<code>null</code>. When the parent is omitted the block is built on the current best block. Manually specifying
the parent is useful for constructing fork scenarios and demonstrating chain reorganizations.</p>
<h4><a class="header" href="#manually-finalizing-blocks" id="manually-finalizing-blocks">Manually Finalizing Blocks</a></h4>
<p>In addition to finalizing blocks while creating them, they can be finalized later by using the
second provided RPC call, <code>engine_finalizeBlock</code>.</p>
<pre><code class="language-bash">$ curl http://localhost:9933 -H &quot;Content-Type:application/json;charset=utf-8&quot; -d   '{
     &quot;jsonrpc&quot;:&quot;2.0&quot;,
      &quot;id&quot;:1,
      &quot;method&quot;:&quot;engine_finalizeBlock&quot;,
      &quot;params&quot;: [&quot;0x0e0626477621754200486f323e3858cd5f28fcbe52c69b2581aecb622e384764&quot;, null]
    }'
</code></pre>
<p>The two parameters are:</p>
<ul>
<li>The hash of the block to finalize.</li>
<li>A Justification. TODO what is the justification and why might I want to use it?</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="kitchen-node.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="basic-pow.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="kitchen-node.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="basic-pow.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src=".analytics/load.js"></script>
        
        <script type="text/javascript" src=".analytics/config.js"></script>
        
        <script type="text/javascript" src=".analytics/klaro.min.js"></script>
        

        

    </body>
</html>
