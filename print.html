<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Substrate Recipes</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A Hands-On Cookbook for Aspiring Blockchain Chefs">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded affix "><a href="introduction.html">Introduction</a></li><li class="expanded "><a href="1-prepare-kitchen/index.html"><strong aria-hidden="true">1.</strong> Preparing Your Kitchen</a></li><li><ol class="section"><li class="expanded "><a href="1-prepare-kitchen/1-build-node.html"><strong aria-hidden="true">1.1.</strong> Building A Node</a></li><li class="expanded "><a href="1-prepare-kitchen/2-interact-node.html"><strong aria-hidden="true">1.2.</strong> Interacting with a Node</a></li><li class="expanded "><a href="1-prepare-kitchen/3-kitchen-organization.html"><strong aria-hidden="true">1.3.</strong> Kitchen Organization</a></li></ol></li><li class="expanded "><a href="2-appetizers/index.html"><strong aria-hidden="true">2.</strong> Appetizers</a></li><li><ol class="section"><li class="expanded "><a href="2-appetizers/1-hello-substrate.html"><strong aria-hidden="true">2.1.</strong> Hello Substrate</a></li><li class="expanded "><a href="2-appetizers/2-storage-values.html"><strong aria-hidden="true">2.2.</strong> Single Value Storage</a></li><li class="expanded "><a href="2-appetizers/3-errors.html"><strong aria-hidden="true">2.3.</strong> Handling Errors</a></li><li class="expanded "><a href="2-appetizers/4-events.html"><strong aria-hidden="true">2.4.</strong> Events Verify Execution</a></li></ol></li><li class="expanded "><a href="3-entrees/index.html"><strong aria-hidden="true">3.</strong> Entrees</a></li><li><ol class="section"><li class="expanded "><a href="3-entrees/storage-api/index.html"><strong aria-hidden="true">3.1.</strong> Runtime Storage API</a></li><li><ol class="section"><li class="expanded "><a href="3-entrees/storage-api/storage-maps.html"><strong aria-hidden="true">3.1.1.</strong> Storage Maps</a></li><li class="expanded "><a href="3-entrees/storage-api/cache.html"><strong aria-hidden="true">3.1.2.</strong> Cache Locally &gt; Storage Calls</a></li><li class="expanded "><a href="3-entrees/storage-api/sets-vecs-iteration.html"><strong aria-hidden="true">3.1.3.</strong> Sets, Vectors, Iteration</a></li><li class="expanded "><a href="3-entrees/storage-api/double.html"><strong aria-hidden="true">3.1.4.</strong> Subgroup Removal by Subkey: Double Maps</a></li><li class="expanded "><a href="3-entrees/storage-api/childtries.html"><strong aria-hidden="true">3.1.5.</strong> Efficient Subgroup Removal by Subkey: Child Tries</a></li><li class="expanded "><a href="3-entrees/storage-api/structs.html"><strong aria-hidden="true">3.1.6.</strong> Storing custom structs</a></li><li class="expanded "><a href="3-entrees/storage-api/ringbuffer.html"><strong aria-hidden="true">3.1.7.</strong> Ringbuffer Queue</a></li></ol></li><li class="expanded "><a href="3-entrees/basic-token.html"><strong aria-hidden="true">3.2.</strong> Basic Token</a></li><li class="expanded "><a href="3-entrees/constants.html"><strong aria-hidden="true">3.3.</strong> Configurable Constants</a></li><li class="expanded "><a href="3-entrees/instantiable.html"><strong aria-hidden="true">3.4.</strong> Instantiable Pallets</a></li><li class="expanded "><a href="3-entrees/weights.html"><strong aria-hidden="true">3.5.</strong> Weights for Resource Accounting</a></li><li class="expanded "><a href="3-entrees/fees.html"><strong aria-hidden="true">3.6.</strong> Transaction Fees for Economic Security</a></li><li class="expanded "><a href="3-entrees/charity.html"><strong aria-hidden="true">3.7.</strong> Charity and Imbalances</a></li><li class="expanded "><a href="3-entrees/fixed-point.html"><strong aria-hidden="true">3.8.</strong> Fixed Point Arithmetic</a></li><li class="expanded "><a href="3-entrees/off-chain-workers/index.html"><strong aria-hidden="true">3.9.</strong> Off-chain Workers</a></li><li><ol class="section"><li class="expanded "><a href="3-entrees/off-chain-workers/transactions.html"><strong aria-hidden="true">3.9.1.</strong> Transactions</a></li><li class="expanded "><a href="3-entrees/off-chain-workers/http-json.html"><strong aria-hidden="true">3.9.2.</strong> HTTP Fetching &amp; JSON Parsing</a></li><li class="expanded "><a href="3-entrees/off-chain-workers/storage.html"><strong aria-hidden="true">3.9.3.</strong> Local Storage</a></li></ol></li><li class="expanded "><a href="3-entrees/runtime-api.html"><strong aria-hidden="true">3.10.</strong> Runtime APIs</a></li><li class="expanded "><a href="3-entrees/custom-rpc.html"><strong aria-hidden="true">3.11.</strong> Custom RPCs</a></li><li class="expanded "><a href="3-entrees/sha3-pow-consensus.html"><strong aria-hidden="true">3.12.</strong> Sha3 Pow Consensus Algorithms</a></li><li class="expanded "><a href="3-entrees/basic-pow.html"><strong aria-hidden="true">3.13.</strong> Basic Proof of Work Node</a></li><li class="expanded "><a href="3-entrees/hybrid-consensus.html"><strong aria-hidden="true">3.14.</strong> Hybrid PoW/PoS Consensus Node</a></li><li class="expanded "><a href="3-entrees/manual-seal.html"><strong aria-hidden="true">3.15.</strong> Manual Seal Consensus</a></li><li class="expanded "><a href="3-entrees/kitchen-node.html"><strong aria-hidden="true">3.16.</strong> Kitchen Node - An reusable instant seal node</a></li><li class="expanded "><a href="3-entrees/currency.html"><strong aria-hidden="true">3.17.</strong> Currency Types</a></li><li class="expanded "><a href="3-entrees/randomness.html"><strong aria-hidden="true">3.18.</strong> Generating Randomness</a></li><li class="expanded "><a href="3-entrees/execution-schedule.html"><strong aria-hidden="true">3.19.</strong> Execution Schedule</a></li><li class="expanded "><a href="3-entrees/permissioned-methods.html"><strong aria-hidden="true">3.20.</strong> Permissioned Methods</a></li><li class="expanded "><a href="3-entrees/testing/index.html"><strong aria-hidden="true">3.21.</strong> Testing</a></li><li><ol class="section"><li class="expanded "><a href="3-entrees/testing/mock.html"><strong aria-hidden="true">3.21.1.</strong> Basic Test Environments</a></li><li class="expanded "><a href="3-entrees/testing/common.html"><strong aria-hidden="true">3.21.2.</strong> Common Tests</a></li><li class="expanded "><a href="3-entrees/testing/off-chain-workers.html"><strong aria-hidden="true">3.21.3.</strong> Off-chain Worker Test Environment</a></li><li class="expanded "><a href="3-entrees/testing/externalities.html"><strong aria-hidden="true">3.21.4.</strong> Custom Test Environment</a></li></ol></li><li class="expanded "><a href="3-entrees/safemath.html"><strong aria-hidden="true">3.22.</strong> Safe Math</a></li><li class="spacer"></li></ol></li><li class="expanded "><a href="more-resources.html">More Resources</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Substrate Recipes</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#substrate-recipes-" id="substrate-recipes-">Substrate Recipes üç¥üòãüç¥</a></h1>
<p><em>A Hands-On Cookbook for Aspiring Blockchain Chefs</em></p>
<p>Substrate Recipes is a cookbook of working examples that demonstrate best practices when building blockchains with <strong><a href="https://github.com/paritytech/substrate">Substrate</a></strong>. Each recipe contains a complete working code example as well as a detailed writeup describing the code. This book is <a href="https://github.com/substrate-developer-hub/recipes">open source</a>. Check out the <a href="https://github.com/substrate-developer-hub/recipes/blob/master/CONTRIBUTING.md">contributing guidelines</a> for an overview of the structure and directions for getting involved.</p>
<h2><a class="header" href="#how-to-use-this-book" id="how-to-use-this-book">How to Use This Book</a></h2>
<p>The easiest place to read this book is at <a href="https://substrate.dev/recipes">https://substrate.dev/recipes</a>.</p>
<p>The first two chapters are meant to be read in order.</p>
<p>In Chapter 1, <a href="./1-prepare-kitchen/index.html">Preparing your Kitchen</a>, you will set up your toolchain, compile a blockchain node, and learn to interact with the blockchain.</p>
<p>In Chapter 2, <a href="./2-appetizers/index.html">Appetizers</a>, you will cook your first few recipes, learning the fundamentals of Substrate development.</p>
<p>The rest of the book, the &quot;Entrees&quot;, can be read in any order, and you should skip to whichever recipes interest you.</p>
<p>Remember, you can't learn to cook by reading alone. As you work through the book, put on your apron, get out some pots and pans, and practice compiling, testing, and hacking on the recipes. Play with the code in the kitchen, extract patterns, and apply them to a problem that you want to solve!</p>
<h2><a class="header" href="#getting-help" id="getting-help">Getting Help</a></h2>
<p>When learning any new skill, you will inevitably get stuck at some point. When you do get stuck you can seek help in several ways:</p>
<ul>
<li>Ask a question on <a href="https://stackoverflow.com/questions/tagged/substrate">Stack Overflow</a></li>
<li>Ask a question in the <a href="https://riot.im/app/#/room/#substrate-technical:matrix.org">Substrate Technical Riot channel</a></li>
<li>Open a <a href="https://github.com/substrate-developer-hub/recipes/issues/new">new issue</a> against this repository</li>
</ul>
<h2><a class="header" href="#what-is-substrate" id="what-is-substrate">What is Substrate?</a></h2>
<p><a href="https://github.com/paritytech/substrate">Substrate</a> is a framework for building blockchains. For a high level overview, read the following blog posts:</p>
<ul>
<li><a href="https://www.parity.io/what-is-substrate/">What is Substrate?</a></li>
<li><a href="https://www.parity.io/substrate-in-a-nutshell/">Substrate in a nutshell</a></li>
<li><a href="https://www.parity.io/a-brief-summary-of-everything-substrate-polkadot/">A brief summary of everything Substrate and Polkadot</a></li>
</ul>
<p>To learn more about Substrate, see the <a href="https://substrate.dev">official documentation</a>.</p>
<h2><a class="header" href="#learning-rust" id="learning-rust">Learning Rust</a></h2>
<p>Becoming productive with Substrate requires some familiarity with Rust. Fortunately, the Rust community is known for comprehensive documentation and tutorials. The most common resource for initially learning Rust is <a href="https://doc.rust-lang.org/book/index.html">The Rust Book</a>. To see examples of popular crate usage patterns, <a href="https://doc.rust-lang.org/rust-by-example/index.html">Rust by Example</a> is also convenient.</p>
<p>While knowing some Rust is certainly necessary, it is not wise to delay learning Substrate until you are a Rust guru. Rather than learning Rust <em>before</em> you learn Substrate, consider learning Rust <em>as</em> you learn Substrate. If you're beyond the fundamentals of Rust, there are lots <a href="./more-resources.html">more Rust resources</a> at the end of the book.</p>
<h1><a class="header" href="#setting-up-your-kitchen" id="setting-up-your-kitchen">Setting Up Your Kitchen</a></h1>
<p>Any experienced chef will tell you that cooking delicious blockchains... I mean meals... starts with a properly equipped and organized kitchen. In this chapter we will guide you through setting up your development environment, and introduce you to the structure of the recipes repository.</p>
<p>This section covers:</p>
<ul>
<li><a href="1-prepare-kitchen/./1-build-node.html">Building a Node</a> - Compile and execute your first Substrate-based blockchain node.</li>
<li><a href="1-prepare-kitchen/./2-interact-node.html">Interacting with the Node</a> - Submit transactions and inspect state with a user interface.</li>
<li><a href="1-prepare-kitchen/./3-kitchen-organization.html">Understanding the Kitchen's Organization</a> - How is the code organized, and why?</li>
</ul>
<h1><a class="header" href="#building-a-node" id="building-a-node">Building a Node</a></h1>
<h2><a class="header" href="#prerequisites" id="prerequisites">Prerequisites</a></h2>
<p>Before we can even begin compiling our first blockchain node, we need to have a properly configured Rust toolchain. There is a convenient script that will set up this toolchain for us, and we can run it with the following command.</p>
<pre><code class="language-bash"># Setup Rust and Substrate
curl https://getsubstrate.io -sSf | bash -s -- --fast
</code></pre>
<blockquote>
<p>This command downloads and executes code from the internet. Give yourself peace-of-mind by inspecting the <a href="https://getsubstrate.io">script's source</a> to confirm it isn't doing anything nasty.</p>
</blockquote>
<h3><a class="header" href="#for-windows" id="for-windows">For Windows</a></h3>
<p>These instructions and the rest of the instructions in this chapter assume a unix-like environment such as Linux, MacOS, or Windows Subsystem for Linux (WSL). If you are a Windows user, WSL is the best way to proceed. If you want or need to work in a native Windows environment, this is possible, but is not covered in detail here. Please follow along with the <a href="https://substrate.dev/docs/en/overview/getting-started#getting-started-on-windows">Getting Started on Windows</a> guide, then return here when you're ready to proceed.</p>
<h2><a class="header" href="#compile-the-kitchen-node" id="compile-the-kitchen-node">Compile the Kitchen Node</a></h2>
<p>If you haven't already, <code>git clone</code> the recipes repository. We also want to kick-start the node compilation as it may take about 30 minutes to complete depending on your hardware.</p>
<pre><code class="language-bash"># Clone the Recipes Repository
git clone https://github.com/substrate-developer-hub/recipes.git
cd recipes

#  Update Rust-Wasm toolchain
./nodes/scripts/init.sh

# Compile the Kitchen Node
# This step takes a while to complete
cargo build --release -p kitchen-node
</code></pre>
<p>As you work through the recipes, refer back to these instructions each time you wish to re-compile the node. Over time the commands will become familiar, and you will even modify them to compile other nodes.</p>
<h2><a class="header" href="#checking-your-work" id="checking-your-work">Checking Your Work</a></h2>
<p>Once the compilation is completed, you can ensure that the node has built properly by displaying its help page. Notice that the node has built to the <code>target/release</code> directory. This is the default location for Rust projects.</p>
<pre><code class="language-bash"># Inside `recipes` directory

# Display the Kitchen Node's help page
./target/release/kitchen-node --help
</code></pre>
<h1><a class="header" href="#interact-with-the-kitchen-node" id="interact-with-the-kitchen-node">Interact with the Kitchen Node</a></h1>
<p>If you followed the instructions to <a href="1-prepare-kitchen/./1-build-node.html">build the node</a>, you my proceed to launch your first blockchain.</p>
<h2><a class="header" href="#launch-a-development-node" id="launch-a-development-node">Launch a Development Node</a></h2>
<p>Before we launch our node we will purge any chain data. If you've followed the instructions exactly, you will not yet have any chain data to purge, but on each subsequent run, you will, and it is best to get in the habit of purging your chain now. We will start our node in development mode (<code>--dev</code>).</p>
<pre><code class="language-bash"># Purge existing blockchain data (if any)
./target/release/kitchen-node purge-chain --dev

# Start a fresh development blockchain
./target/release/kitchen-node --dev
</code></pre>
<p>You should now see your node up and running and waiting for transactions. This Kitchen Node, and several other nodes included with the Recipes, is an instant seal node. That means it will not create any blocks until there are transactions to process. It also means that when a transaction is ready, the node will instantly create a block. Instant seal nodes are ideal for experimenting with your Substrate runtime. The output looks something like this.</p>
<pre><code>2020-05-18 14:33:35 Running in --dev mode, RPC CORS has been disabled.
2020-05-18 14:33:35 Kitchen Node
2020-05-18 14:33:35 ‚úåÔ∏è  version 2.0.0-alpha.7-6f91ef9-x86_64-linux-gnu
2020-05-18 14:33:35 ‚ù§Ô∏è  by Joshy Orndorff:4meta5:Jimmy Chu, 2019-2020
2020-05-18 14:33:35 üìã Chain specification: Development
2020-05-18 14:33:35 üè∑  Node name: confused-songs-1348
2020-05-18 14:33:35 üë§ Role: AUTHORITY
2020-05-18 14:33:35 üíæ Database: RocksDb at /home/joshy/.local/share/kitchen-node/chains/dev/db
2020-05-18 14:33:35 ‚õì  Native runtime: super-runtime-1 (super-runtime-1.tx1.au1)
2020-05-18 14:33:35 üî® Initializing Genesis block/state (state: 0x1835‚Ä¶9bd7, header-hash: 0x239e‚Ä¶48d8)
2020-05-18 14:33:35 üì¶ Highest known block at #0
2020-05-18 14:33:35 Using default protocol ID &quot;sup&quot; because none is configured in the chain specs
2020-05-18 14:33:35 üè∑  Local node identity is: QmQXnCTyCAfe3QAs43ggyJyWAJ1MoKzqizK991ZRTNQhxi
2020-05-18 14:33:35 „ÄΩÔ∏è Prometheus server started at 127.0.0.1:9615
2020-05-18 14:33:40 üí§ Idle (0 peers), best: #0 (0x239e‚Ä¶48d8), finalized #0 (0x239e‚Ä¶48d8), ‚¨á 0 ‚¨Ü 0
</code></pre>
<h2><a class="header" href="#launch-the-apps-user-interface" id="launch-the-apps-user-interface">Launch the Apps User Interface</a></h2>
<p>You can navigate to the  <a href="https://polkadot.js.org/apps/#/settings/developer?rpc=ws://127.0.0.1:9944">Polkadot-JS Apps</a> user interface. This is a general purpose interface for interacting with many different Substrate-based blockchains including Polkadot. From now on we'll call it &quot;Apps&quot; for short. Before Apps will work with our blockchain, we need to give it a little chain-specific information known as the &quot;types&quot;. You'll learn what all this means as you work through the recipes; for now just follow the instructions.</p>
<blockquote>
<p>If you are not clicking the link above but visiting Apps directly, by default Apps connects to Kusama network. You will need to switch to your locally running network, with only one node, by clicking on the network icon on Apps top left corner.</p>
<p><img src="1-prepare-kitchen/../img/apps-select-network.png" alt="Screenshot: Switching Network" /></p>
</blockquote>
<blockquote>
<p>Some browsers, notably Firefox, will not connect to a local node from an https website. An easy work around is to try another browser, like Chromium. Another option is to <a href="https://github.com/polkadot-js/apps#development">host this interface locally</a>.</p>
</blockquote>
<p>If you're not already on the <code>Settings -&gt; Developer</code>page, please navigate there. Copy the contents of <code>runtimes/super-runtime/types.json</code> into Apps.</p>
<p><img src="1-prepare-kitchen/../img/apps-types.png" alt="Screenshot: pasting types into Apps UI" /></p>
<p>The kitchen node uses the super runtime by default. As you work through the recipes, you'll learn that it is easy to use other runtimes in this node, or use other nodes entirely. When you do use another runtime, you need to insert the appropriate types from the <code>runtimes/&lt;whatever runtime you're using&gt;/types.json</code> file. Every runtime that ships with the Recipes has this file.</p>
<h2><a class="header" href="#submitting-a-transaction" id="submitting-a-transaction">Submitting a Transaction</a></h2>
<p>You may now submit a simple token transfer transaction using the &quot;Transfer&quot; tab. When you do, you will notice that your node instantly creates a block, and the transaction is processed. As you work through the recipes, you will use the <strong>Chain State</strong> tab to query the blockchain status and <strong>Extrinsics</strong> to send transactions to the blockchain. Play around for a bit before moving on.</p>
<h1><a class="header" href="#kitchen-organization" id="kitchen-organization">Kitchen Organization</a></h1>
<p>Now that your kitchen is well-equipped with all the right tools (bowls, knives, Rust compiler, etc), let's take a look at how it is organized.</p>
<h2><a class="header" href="#structure-of-a-substrate-node" id="structure-of-a-substrate-node">Structure of a Substrate Node</a></h2>
<p>It is useful to recognize that <a href="https://youtu.be/05H4YsyPA-U?t=1789">coding is all about abstraction</a>.</p>
<p>To understand how the code in this repository is organized, let's first take a look at how a Substrate node is constructed. Each node has many components that manage things like queueing transaction, communicating over a P2P network, reaching consensus on the state of the blockchain, and the chain's actual runtime logic. Each aspect of the node is interesting in its own right, and the runtime is particularly interesting because it contains the business logic (aka &quot;state transition function&quot;) that codifies the chain's functionality.</p>
<p>Much, but not all, of the Recipes focuses on writing runtimes with FRAME, Parity's Framework for composing runtimes from individual building blocks called Pallets. Runtimes built with FRAME typically contain several such pallets. The kitchen node you built previously follows this paradigm.</p>
<p><img src="1-prepare-kitchen/../img/substrate-architecture.png" alt="Substrate Architecture Diagram" /></p>
<h2><a class="header" href="#the-directories-in-our-kitchen" id="the-directories-in-our-kitchen">The Directories in our Kitchen</a></h2>
<p>There are five primary directories in this repository:</p>
<ul>
<li><strong>Text</strong>: Source of <a href="https://substrate.dev/recipes">the book</a> written in markdown. This is what you're reading right now.</li>
<li><strong>Pallets</strong>: Pallets for use in FRAME-based runtimes.</li>
<li><strong>Runtimes</strong>: Runtimes for use in Substrate nodes.</li>
<li><strong>Consensus</strong>: Consensus engines for use in Substrate nodes.</li>
<li><strong>Nodes</strong>: Complete Substrate nodes ready to run.</li>
</ul>
<p>Exploring those directories reveals a tree that looks like this</p>
<pre><code>recipes
|
+-- text
|
+-- consensus
  |
  +-- shaw3pow
|
+-- nodes
	|
	+-- kitchen-node    &lt;-- You built this previously
	|
	+-- rpc-node
|
+-- runtimes
	|
	+-- api-runtime
	|
	+-- super-runtime    &lt;-- You built this too (it is part of the kitchen-node)
	|
	+-- weight-fee-runtime
	|
	+ ...
|
+-- pallets
	|
	+-- adding-machine    &lt;-- You built this too (it is part of super-runtime)
	|
	+-- basic-token        &lt;-- You built this too (it is part of super-runtime)
	|
	+ ...
	|
	+-- weights
</code></pre>
<h2><a class="header" href="#inside-the-kitchen-node" id="inside-the-kitchen-node">Inside the Kitchen Node</a></h2>
<p>Let us take a deeper look at the <a href="https://github.com/substrate-developer-hub/recipes/tree/master/nodes/kitchen-node">Kitchen Node</a>.</p>
<p>Looking inside the Kitchen Node's <code>Cargo.toml</code> file we see that it has many dependencies. Most of them come from Substrate itself. Indeed most parts of this Kitchen Node are not unique or specialized, and Substrate offers robust implementations that we can use. The runtime does not come from Substrate. Rather, we use our super-runtime which is in the <code>runtimes</code> folder.</p>
<p><strong><code>nodes/kitchen-node/Cargo.toml</code></strong></p>
<pre><code class="language-TOML"># This node is compatible with any of the runtimes below
# ---
# Common runtime configured with most Recipes pallets.
runtime = { package = &quot;super-runtime&quot;, path = &quot;../../runtimes/super-runtime&quot; }

# Runtime with custom weight and fee calculation.
# runtime = { package = &quot;weight-fee-runtime&quot;, path = &quot;../../runtimes/weight-fee-runtime&quot;}

# Runtime with off-chain worker enabled.
# To use this runtime, compile the node with `ocw` feature enabled,
#   `cargo build --release --features ocw`.
# runtime = { package = &quot;ocw-runtime&quot;, path = &quot;../../runtimes/ocw-runtime&quot; }

# Runtime with custom runtime-api (custom API only used in rpc-node)
# runtime = { package = &quot;api-runtime&quot;, path = &quot;../../runtimes/api-runtime&quot; }
# ---
</code></pre>
<p>The commented lines, quoted above, show that the Super Runtime is not the only runtime we could have chosen. We could also use the Weight-Fee runtime, and I encourage you to try that experiment (remember, instructions to re-compile the node are in the previous section).</p>
<p>Every node must have a runtime. You may confirm that by looking at the <code>Cago.toml</code> files of the other nodes included in our kitchen.</p>
<h2><a class="header" href="#inside-the-super-runtime" id="inside-the-super-runtime">Inside the Super Runtime</a></h2>
<p>Having seen that the Kitchen Node depends on a runtime, let us now look deeper at the <a href="https://github.com/substrate-developer-hub/recipes/tree/master/runtimes/super-runtime">Super Runtime</a>.</p>
<p><strong><code>runtimes/super-runtime/Cargo.toml</code></strong></p>
<pre><code class="language-TOML"># -- snip --

# Substrate Pallets
balances = { package = 'pallet-balances', , ... }
transaction-payment = { package = 'pallet-transaction-payment', ,... }
# Recipe Pallets
adding-machine = { path = &quot;../../pallets/adding-machine&quot;, default-features = false }
basic-token = { path = &quot;../../pallets/basic-token&quot;, default-features = false }
</code></pre>
<p>Here we see that the runtime depends on many pallets. Some of these pallets come from Substrate itself. Indeed, Substrate offers a rich collection of commonly used pallets which you may use in your own runtimes. This runtime also contains several custom pallets that are written right here in our Kitchen.</p>
<h2><a class="header" href="#common-patterns" id="common-patterns">Common Patterns</a></h2>
<p>We will not yet look closely at individual Pallets. We will begin that endeavor in the next chapter -- Appetizers.</p>
<p>We've just observed the general pattern used throughout the recipes. From the inside out, we see a piece of pallet code stored in <code>pallets/&lt;pallet-name&gt;/src/lib.rs</code>. The pallet is then included into a runtime by adding its name and relative path in <code>runtimes/&lt;runtime-name&gt;/Cargo.toml</code>. That runtime is then installed in a node by adding its name and relative path in <code>nodes/&lt;node-name&gt;/Cargo.toml</code>. Of course adding pallets and runtimes also requires changing actual <em>code</em> as well. We will cover those details in due course. For now we're just focusing on macroscopic relationships between the parts of a Substrate node.</p>
<p>Some recipes explore aspects of Blockchain development that are outside of the runtime. Looking back to our node architecture at the beginning of this section, you can imagine that changing a node's RPC or Consensus would be conceptually similar to changing its runtime.</p>
<h2><a class="header" href="#additional-resources" id="additional-resources">Additional Resources</a></h2>
<p>Substrate Developer Hub offers tutorials that go into more depth about writing pallets and including them in runtimes. If you desire, you may read them as well.</p>
<ul>
<li><a href="https://substrate.dev/docs/en/next/tutorials/creating-a-runtime-module">Creating an External Pallet</a></li>
<li><a href="https://substrate.dev/docs/en/next/tutorials/adding-a-module-to-your-runtime">Adding a Pallet to Your Runtime Tutorial</a></li>
</ul>
<h1><a class="header" href="#lets-get-cooking" id="lets-get-cooking">Let's Get Cooking!</a></h1>
<p>When you're ready, we can begin by cooking some appetizer pallets.</p>
<h1><a class="header" href="#appetizers" id="appetizers">Appetizers</a></h1>
<p>This section of the cookbook will focus on Appetizers, small runtime pallets that teach you the basics of writing pallets with a little hand-holding. If you are brand new to Substrate, you should follow through these appetizers in order. If you've already got the basics of pallet development down, you may skip ahead to the entrees which may be read in any order.</p>
<p>This section covers:</p>
<ul>
<li><a href="2-appetizers/./1-hello-substrate.html">Dispatchable Calls</a> - How users submit transactions</li>
<li><a href="2-appetizers/./2-storage-values.html">Storage Values</a> - Storing the state of the blockchain</li>
<li><a href="2-appetizers/./3-errors.html">Errors</a> - When things go wrong during a transaction</li>
<li><a href="2-appetizers/./4-events.html">Events</a> - Notifying the offchain world of success</li>
</ul>
<h1><a class="header" href="#hello-substrate" id="hello-substrate">Hello Substrate</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/hello-substrate"><code>pallets/hello-substrate</code></a></em></p>
<p>The first pallet we'll explore is a simple &quot;hello world&quot; example. This pallet will have one dispatchable call that prints a message to the node's output. Because this is our first pallet, we'll also explore the structure that every pallet has. This code lives in <code>pallets/hello-substrate/src/lib.rs</code>.</p>
<h2><a class="header" href="#no-std" id="no-std">No Std</a></h2>
<p>The very first line of code tells the rust compiler that this crate should not use rust's standard library except when explicitly told to. This is useful because Substrate runtimes compile to Web Assembly where the standard library is not available.</p>
<pre><code class="language-rust ignore">#![cfg_attr(not(feature = &quot;std&quot;), no_std)]
</code></pre>
<h2><a class="header" href="#imports" id="imports">Imports</a></h2>
<p>Next, you'll find imports that come from various parts of the Substrate framework. All pallets will import from a few common crates including <a href="https://substrate.dev/rustdocs/master/frame_support/index.html"><code>frame-support</code></a>, and <a href="https://substrate.dev/rustdocs/master/frame_system/index.html"><code>frame-system</code></a>.  Complex pallets will have many imports as we'll see later. The <code>hello-substrate</code> pallet uses these imports.</p>
<pre><code class="language-rust ignore">use frame_support::{ decl_module, dispatch::DispatchResult, debug };
use frame_system::{ self as system, ensure_signed };
use sp_runtime::print;
</code></pre>
<h2><a class="header" href="#tests" id="tests">Tests</a></h2>
<p>Next we see a reference to the tests module. This pallet has tests written in a separate file called <code>tests.rs</code>. We will not discuss the tests further at this point, but they are covered in the <a href="2-appetizers/../3-entrees/testing/index.html">Testing section</a> of the book.</p>
<h2><a class="header" href="#configuration-trait" id="configuration-trait">Configuration Trait</a></h2>
<p>Next, each pallet has a configuration trait which is called <code>Trait</code>. The configuration trait can be used to access features from other pallets, or <a href="2-appetizers/../3-entrees/constants.html">constants</a> that effect the pallet's behavior. This pallet is simple enough that our configuration trait can remain empty, although it must still exist.</p>
<pre><code class="language-rust ignore">pub trait Trait: system::Trait {}
</code></pre>
<h2><a class="header" href="#dispatchable-calls" id="dispatchable-calls">Dispatchable Calls</a></h2>
<p>A Dispatchable call is a function that a blockchain user can call as part of an Extrinsic. &quot;Extrinsic&quot; is Substrate jargon meaning a call from outside of the chain. Most of the time they are transactions, and for now it is fine to think of them as transactions. Dispatchable calls are defined in the <a href="https://substrate.dev/rustdocs/master/frame_support/macro.decl_module.html"><code>decl_module!</code> macro</a>.</p>
<pre><code class="language-rust ignore">decl_module! {
	pub struct Module&lt;T: Trait&gt; for enum Call where origin: T::Origin {

		/// A function that says hello to the user by printing messages to the node log
		#[weight = 10_000]
		pub fn say_hello(origin) -&gt; DispatchResult {
			// --snip--
		}

		// More dispatchable calls could go here
	}
}
</code></pre>
<p>As you can see, our <code>hello-substrate</code> pallet has a dispatchable call that takes a single argument, called <code>origin</code> which we'll investigate shortly. The call returns a <a href="https://substrate.dev/rustdocs/master/frame_support/dispatch/type.DispatchResult.html"><code>DispatchResult</code></a> which can be either <code>Ok(())</code> indicating that the call succeeded, or an <code>Err</code> which we'll investigate in the <a href="2-appetizers/./3-errors.html">appetizer about errors</a>.</p>
<h3><a class="header" href="#weight-annotations" id="weight-annotations">Weight Annotations</a></h3>
<p>Right before the <code>hello-substrate</code> function, we see the line <code>#[weight = 10_000]</code>. This line attaches a default weight to the call. Ultimately weights affect the fees a user will have to pay to call the function. Weights are a very interesting aspect of developing with Substrate, but they too shall be covered later in the section on <a href="2-appetizers/../3-entrees/weights.html">Weights</a>. For now, and for may of the recipes pallets, we will simply use the default weight as we have done here.</p>
<h2><a class="header" href="#inside-a-dispatchable-call" id="inside-a-dispatchable-call">Inside a Dispatchable Call</a></h2>
<p>Let's take a closer look at our dispatchable call.</p>
<pre><code class="language-rust ignore">pub fn say_hello(origin) -&gt; DispatchResult {
	// Ensure that the caller is a regular keypair account
	let caller = ensure_signed(origin)?;

	// Print a message
	print(&quot;Hello World&quot;);
	// Inspecting variables
	debug::info!(&quot;Request sent by: {:?}&quot;, caller);

	// Indicate that this call succeeded
	Ok(())
}
</code></pre>
<p>This function essentially does three things. First, it uses the <a href="https://substrate.dev/rustdocs/master/frame_system/fn.ensure_signed.html"><code>ensure_signed</code> function</a> to ensure that the caller of the function was a regular user who owns a private key. This function also returns who that caller was. We store the caller's identity in the <code>caller</code> variable.</p>
<p>Second, it prints a message and logs the caller. Notice that we aren't using Rust's normal <code>println!</code> macro, but rather a special <a href="https://substrate.dev/rustdocs/master/sp_runtime/fn.print.html"><code>print</code> function</a> and <a href="https://substrate.dev/rustdocs/master/frame_support/debug/macro.info.html"><code>debug::info!</code> macro</a>. The reason for this is explained in the next section.</p>
<p>Finally, the call returns <code>Ok(())</code> to indicate that the call has succeeded. At a glance it seems that there is no way for this call to fail, but this is not quite true. The <code>ensure_signed</code> function, used at the beginning, can return an error if the call was not from a signed origin. This is the first time we're seeing the important paradigm &quot;<strong>Verify first, write last</strong>&quot;. In Substrate development, it is important that you always ensure preconditions are met and return errors at the beginning. After these checks have completed, then you may begin the functions computation.</p>
<h2><a class="header" href="#printing-from-the-runtime" id="printing-from-the-runtime">Printing from the Runtime</a></h2>
<p>Printing to the terminal from a Rust program is typically very simple using the <code>println!</code> macro. However, Substrate runtimes are compiled to Web Assembly as well as a regular native binary, and do not have access to rust's standard library. That means we cannot use the regular <code>println!</code>. I encourage you to modify the code to try using <code>println!</code> and confirm that it will not compile. Nonetheless, printing a message from the runtime is useful both for logging information, and also for debugging.</p>
<p><img src="2-appetizers/../img/substrate-architecture.png" alt="Substrate Architecture Diagram" /></p>
<p>At the top of our pallet, we imported <code>sp_runtime</code>'s <a href="https://substrate.dev/rustdocs/master/sp_runtime/fn.print.html"><code>print</code> function</a>. This special function allows the runtime to pass a message for printing to the outer part of the node which is not built to Wasm. This function is only able to print items that implement the <a href="https://substrate.dev/rustdocs/master/sp_runtime/traits/trait.Printable.html"><code>Printable</code> trait</a>. Luckily all the primitive types already implement this trait, and you can implement the trait for your own datatypes too.</p>
<p><strong>Print function note:</strong> To actually see the printed messages, we need to use the flag <code>-lruntime=debug</code> when running the kitchen node. So, for the kitchen node, the command would become <code>./target/release/kitchen-node --dev -lruntime=debug</code>.</p>
<p>The next line demonstrates using <code>debug::info!</code> macro to log to the screen and also inspecting the variable's content. The syntax inside the macro is very similar to what regular rust macro <code>println!</code> takes.</p>
<p><strong>Runtime logger note:</strong> When we execute the runtime in native, <code>debug::info!</code> messages are printed. However, if we execute the runtime in Wasm, then an additional step to initialise <a href="https://substrate.dev/rustdocs/master/frame_support/debug/struct.RuntimeLogger.html">RuntimeLogger</a> is required.</p>
<h2><a class="header" href="#installing-the-pallet-in-a-runtime" id="installing-the-pallet-in-a-runtime">Installing the Pallet in a Runtime</a></h2>
<p>In order to actually use a pallet, it must be installed in a Substrate runtime. This particular pallet is installed in the <code>super-runtime</code> which you built as part of the kitchen node. To install a pallet in a runtime, you must do three things.</p>
<h3><a class="header" href="#depend-on-the-pallet" id="depend-on-the-pallet">Depend on the Pallet</a></h3>
<p>First we must include the pallet in our runtime's <code>Cargo.toml</code> file. In the case of the super-runtime, this file is at <code>runtimes/super-runtime/Cargo.toml</code>.</p>
<pre><code class="language-toml">[dependencies]
# --snip--
hello-substrate = { path = &quot;../../pallets/hello-substrate&quot;, default-features = false }
</code></pre>
<p>Because the runtime is built to both native and Wasm, we must ensure that our pallet is built to the correct target as well. At the bottom of the <code>Cargo.toml</code> file, we see this.</p>
<pre><code class="language-toml">[features]
default = [&quot;std&quot;]
std = [
	# --snip--
	&quot;hello-substrate/std&quot;,
]
</code></pre>
<h3><a class="header" href="#implement-its-configuration-trait" id="implement-its-configuration-trait">Implement its Configuration Trait</a></h3>
<p>Next we must implement the pallet's configuration trait. This happens in the runtime's main <code>lib.rs</code> file. In the case of the super-runtime, this file is at <code>runtimes/super-runtime/src/lib.rs</code>. Because this pallet's configuration trait is trivial, so is implementing it.</p>
<pre><code class="language-rustignore">impl hello_substrate::Trait for Runtime {}
</code></pre>
<p>You can see the other pallets' trait implementations in the surrounding lines. Most of them are more complex.</p>
<h3><a class="header" href="#add-it-to-construct_runtime" id="add-it-to-construct_runtime">Add it to <code>construct_runtime!</code></a></h3>
<p>Finally, we add our pallet to the <a href="https://substrate.dev/rustdocs/master/frame_support/macro.construct_runtime.html"><code>construct_runtime!</code> macro</a>.</p>
<pre><code class="language-rust ignore">construct_runtime!(
	pub enum Runtime where
		Block = Block,
		NodeBlock = opaque::Block,
		UncheckedExtrinsic = UncheckedExtrinsic
	{
		// --snip--
		HelloSubstrate: hello_substrate::{Module, Call},
	}
);
</code></pre>
<p>This macro does the heavy lifting of composing each individual pallet into a single usable runtime. Let's explain the syntax for each line. Each Pallet listed in the macro needs several pieces of information.</p>
<p>First is a convenient name to give to this pallet. We've chosen <code>HelloSubstrate</code>. It is common to choose the same name as the pallet itself except when there is <a href="2-appetizers/../3-entrees/instantiable.html">more than one instance</a>. Next is the name of the crate that the pallet lives in. And finally there is a list of features the pallet provides. All pallets require <code>Module</code>. Our pallet also provides dispatchable calls, so it requires <code>Call</code>.</p>
<h2><a class="header" href="#try-it-out" id="try-it-out">Try it Out</a></h2>
<p>If you haven't already, try interacting with the pallet using the Apps UI. You should see your message printed to the log of your node. Remember to run the kitchen node with the correct flags: <code>./target/release/kitchen-node --dev -lruntime=debug</code></p>
<p>You're now well on your way to becoming a blockchain chef. Let's continue to build our skills with another appetizer.</p>
<h1><a class="header" href="#single-value" id="single-value">Single Value</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/single-value"><code>pallets/single-value</code></a></em></p>
<p>Storage is used for data that should be kept between blocks, and accessible to future transactions. Most runtimes will have many storage values, and together the storage values make up the blockchain's &quot;state&quot;. The storage values themselves are <em>not</em> stored in the blocks. Instead the blocks contains extrinsics which represent <em>changes</em> to the storage values. It is the job of each node in a blockchain network to keep track of the current storage. The current state of storage can be determined by executing all of the blocks in the chain.</p>
<h2><a class="header" href="#declaring-storage" id="declaring-storage">Declaring Storage</a></h2>
<p>A pallet's storage items are declared with the <a href="https://substrate.dev/rustdocs/master/frame_support/macro.decl_storage.html"><code>decl_storage!</code> macro</a>.</p>
<pre><code class="language-rust ignore">decl_storage! {
    trait Store for Module&lt;T: Trait&gt; as SingleValue {
        // --snip--
    }
}
</code></pre>
<p>The code above is boilerplate that does not change with the exception of the <code>SingleValue</code>. The macro uses this as the name for a struct that it creates. As a pallet author you don't need to worry about this value much, and it is fine to use the name of the pallet itself.</p>
<p>This pallet has two storage items, both of which are single storage values. Substrate's storage API also supports more complex storage types which are <a href="2-appetizers/../3-entrees/storage-api/index.html">covered in the entrees</a>. The fundamentals for all types are the same.</p>
<p>Our first storage item is a <code>u32</code> value which is declared with this syntax</p>
<pre><code class="language-rust ignore">StoredValue get(fn stored_value): u32;
</code></pre>
<p>The <code>StorageValue</code> is the name of the storage item, similar to a variable name. We will use this name any time we write to the storage item. The <code>get(fn stored_value)</code> is optional. It tells the <code>decl_storage!</code> macro to create a getter function for us. That means we get a function called <code>stored_value</code> which returns the value in that storage item. Finally, the <code>: u32</code> declares the type of the item.</p>
<p>The next storage item is an <code>AccountId</code>. This is not a primitive type, but rather comes from the system pallet. Types like this need to be prefixed with a <code>T::</code> as we see here.</p>
<pre><code class="language-rust ignore">StoredAccount get(fn stored_account): T::AccountId;
</code></pre>
<h2><a class="header" href="#reading-and-writing-to-storage" id="reading-and-writing-to-storage">Reading and Writing to Storage</a></h2>
<p>Functions used to access a single storage value are defined in the <a href="https://substrate.dev/rustdocs/master/frame_support/storage/trait.StorageValue.html"><code>StorageValue</code> trait</a>. In this pallet, we use the most common method, <code>put</code>, but it is worth skimming the other methods so you know what is available.</p>
<p>The <code>set_value</code> method demonstrates writing to storage, as well as taking a parameter in our dispatchable call.</p>
<pre><code class="language-rust ignore">fn set_value(origin, value: u32) -&gt; DispatchResult {
	let _ = ensure_signed(origin)?;

	StoredValue::put(value);

	Ok(())
}
</code></pre>
<p>To read a value from storage, we could use the <code>get</code> method, or we could use the getter method we declared in <code>decl_storage!</code>.</p>
<pre><code class="language-rust ignore">// The following lines are equivalent
let my_val = StoredValue::get();
let my_val = Self::stored_value();
</code></pre>
<h2><a class="header" href="#storing-the-callers-account" id="storing-the-callers-account">Storing the Callers Account</a></h2>
<p>In terms of storage, the <code>set_account</code> method is quite similar to <code>set_value</code>, but it also demonstrates how to retreive the <code>AccountId</code> of the caller using the <a href="https://substrate.dev/rustdocs/master/frame_system/fn.ensure_signed.html"><code>ensure_signed</code> function</a>.</p>
<pre><code class="language-rust ignore">fn set_account(origin) -&gt; DispatchResult {
	let who = ensure_signed(origin)?;

	&lt;StoredAccount&lt;T&gt;&gt;::put(&amp;who);

	Ok(())
}
</code></pre>
<p>Because <code>AccountId</code> type comes from the configuration trait, we must use slightly different syntax. Notice the <code>&lt;T&gt;</code> attached to the name of the storage value this time. Notice also that because <code>AccountId</code> is not primitive, we lend a reference to it rather than transferring ownership.</p>
<h2><a class="header" href="#constructing-the-runtime" id="constructing-the-runtime">Constructing the Runtime</a></h2>
<p>We learned about the <a href="https://substrate.dev/rustdocs/master/frame_support/macro.construct_runtime.html"><code>construct_runtime!</code> macro</a> in the previous section. Because this pallet uses storage items, we must add this to the line in construct runtime. In the Super Runtime, we see the additional <code>Storage</code> feature.</p>
<pre><code class="language-rust ignore">construct_runtime!(
	pub enum Runtime where
		Block = Block,
		NodeBlock = opaque::Block,
		UncheckedExtrinsic = UncheckedExtrinsic
	{
		// --snip--
		SingleValue: single_value::{Module, Call, Storage},
	}
);
</code></pre>
<h1><a class="header" href="#handling-errors" id="handling-errors">Handling Errors</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/adding-machine"><code>pallets/adding-machine</code></a></em></p>
<p>As we've mentioned before, in Substrate development, it is important to <strong>Verify first, write last</strong>. In this recipe, we'll create an adding machine checks for unlucky numbers (a silly example) as well as integer overflow (a serious and realistic example), and throws the appropriate errors.</p>
<h2><a class="header" href="#declaring-errors" id="declaring-errors">Declaring Errors</a></h2>
<p>Errors are declared with the <a href="https://substrate.dev/rustdocs/master/frame_support/macro.decl_error.html"><code>decl_error!</code> macro</a>. Although it is optional, it is good practice to write doc comments for each error variant as demonstrated here.</p>
<pre><code class="language-rust ignore">decl_error! {
	pub enum Error for Module&lt;T: Trait&gt; {
		/// Thirteen is unlucky and prohibitted
		UnluckyThirteen,
		/// Sum would have overflowed if we had added
		SumTooLarge,
	}
}
</code></pre>
<h2><a class="header" href="#throwing-errors-in-match-statement" id="throwing-errors-in-match-statement">Throwing Errors in <code>match</code> Statement</a></h2>
<p>Errors can be thrown in two different ways, both of which are demonstrated in the the <code>add</code> dispatchable call. The first is with the <a href="https://substrate.dev/rustdocs/master/frame_support/macro.ensure.html"><code>ensure!</code> macro</a> where the error to throw is the second parameter. The second is to throw the error by explicitly returning it.</p>
<pre><code class="language-rust ignore">fn add(origin, val_to_add: u32) -&gt; DispatchResult {
	let _ = ensure_signed(origin)?;

	// First check for unlucky number 13
	ensure!(val_to_add != 13, &lt;Error&lt;T&gt;&gt;::UnluckyThirteen);

	// Now check for overflow while adding
	let result = match Self::sum().checked_add(val_to_add) {
		Some(r) =&gt; r,
		None =&gt; return Err(&lt;Error&lt;T&gt;&gt;::SumTooLarge.into()),
	};

	// Write the new sum to storage
	Sum::put(result);

	Ok(())
}
</code></pre>
<p>Notice that the <code>Error</code> type always takes the generic parameter <code>T</code>. Notice also that we have verified all preconditions, and thrown all possible errors before ever writing to storage.</p>
<h2><a class="header" href="#throwing-errors-with-ok_or-and-map_err" id="throwing-errors-with-ok_or-and-map_err">Throwing Errors with <code>.ok_or</code> and <code>.map_err</code></a></h2>
<p>In fact, the pattern of:</p>
<ul>
<li>calling functions that returned a <code>Result</code> or <code>Option</code>, and</li>
<li>checking if the result is <code>Some</code> or <code>Ok</code>. If not, returns from the function early with an error</li>
</ul>
<p>are so common that there are two standard Rust methods help performing the task.</p>
<pre><code class="language-rust ignore">fn add_alternate(origin, val_to_add: u32) -&gt; DispatchResult {
	let _ = ensure_signed(origin)?;

	ensure!(val_to_add != 13, &lt;Error&lt;T&gt;&gt;::UnluckyThirteen);

	// Using `ok_or()` to check if the returned value is `Ok` and unwrap the value.
	//   If not, returns error from the function.
	let result = Self::sum().checked_add(val_to_add).ok_or(&lt;Error&lt;T&gt;&gt;::SumTooLarge)?;

	Sum::put(result);
	Ok(())
}
</code></pre>
<p>Notice the pattern of <code>.ok_or(&lt;Error&lt;T&gt;&gt;::MyError)?;</code>. This is really handy when you have a function call that returns an <code>Option</code> and you expect there should be a value inside. If not, returns early with an error message, all the while unwrapping the value for your further processing.</p>
<p>If your function returns a <code>Result&lt;T, E&gt;</code>, you could apply <code>.map_err(|_e| &lt;Error&lt;T&gt;&gt;::MyError)?;</code> in the same spirit.</p>
<h2><a class="header" href="#constructing-the-runtime-1" id="constructing-the-runtime-1">Constructing the Runtime</a></h2>
<p>Unlike before, adding errors to our pallet does <em>not</em> require a change to the line in <code>construct_runtime!</code>. This is just an idiosyncrasy of developing in Substrate.</p>
<h1><a class="header" href="#using-events" id="using-events">Using Events</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/simple-event"><code>pallets/simple-event</code></a></em>, <em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/generic-event"><code>pallets/generic-event</code></a></em></p>
<p>Having a <a href="https://substrate.dev/docs/en/overview/glossary#transaction">transaction</a> included in a block does not guarantee that the function executed successfully. As we saw in the previous recipe, many calls can cause errors, but still be included in a block. To verify that functions have executed successfully, emit an <a href="https://substrate.dev/docs/en/overview/glossary#events">event</a> at the bottom of the function body.</p>
<p>Events notify the off-chain world of successful state transitions.</p>
<h2><a class="header" href="#some-prerequisites" id="some-prerequisites">Some Prerequisites</a></h2>
<p>When using events, we have to include the <code>Event</code> type in our configuration trait. Although the syntax is a bit complex, it is the same every time. If you are a skilled Rust programmer you will recognize this as a series of <a href="https://doc.rust-lang.org/book/ch10-02-traits.html">trait bounds</a>. If you don't recognize this feature of Rust yet, don't worry; it is the same every time, so you can just copy it and move on.</p>
<pre><code class="language-rust ignore">pub trait Trait: system::Trait {
	type Event: From&lt;Event&gt; + Into&lt;&lt;Self as system::Trait&gt;::Event&gt;;
}
</code></pre>
<p>Next we have to add a line inside of the <code>decl_module!</code> macro which generates the 	<code>deposit_event</code> function we'll use later when emitting our events. Even experienced Rust programmers will not recognize this syntax because it is unique to this macro. Just copy it each time.</p>
<pre><code class="language-rust ignore">decl_module! {
	pub struct Module&lt;T: Trait&gt; for enum Call where origin: T::Origin {

		// This line is new
		fn deposit_event() = default;

		// --snip--
	}
}
</code></pre>
<h2><a class="header" href="#declaring-events" id="declaring-events">Declaring Events</a></h2>
<p>To declare an event, use the <a href="https://substrate.dev/rustdocs/master/frame_support/macro.decl_event.html"><code>decl_event!</code> macro</a>. Like any rust enum, Events have names, and can optionally carry data with them. The syntax is slightly different depending on whether the events carry data of primitive types, or generic types from the pallet's configuration trait. These two techniques are demonstrated in the <code>simple-event</code> and <code>generic-event</code> pallets respectively.</p>
<h3><a class="header" href="#simple-events" id="simple-events">Simple Events</a></h3>
<p>The simplest example of an event uses the following syntax</p>
<pre><code class="language-rust ignore">decl_event!(
	pub enum Event {
		EmitInput(u32),
	}
);
</code></pre>
<h3><a class="header" href="#events-with-generic-types" id="events-with-generic-types">Events with Generic Types</a></h3>
<p><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/generic-event">Sometimes</a> events might contain types from the pallet's Configuration Trait. In this case, it is necessary to specify additional syntax</p>
<pre><code class="language-rust ignore">decl_event!(
	pub enum Event&lt;T&gt; where AccountId = &lt;T as system::Trait&gt;::AccountId {
		EmitInput(AccountId, u32),
	}
);
</code></pre>
<p>This example also demonstrates how the <code>where</code> clause can be used to specify type aliasing for more readable code.</p>
<h2><a class="header" href="#emitting-events" id="emitting-events">Emitting Events</a></h2>
<p>Events are emitted from dispatchable calls using the <code>deposit_event</code> method.</p>
<blockquote>
<p>Events are not emitted on block 0. So any dispatchable calls made during genesis block formation
will have no events emitted.</p>
</blockquote>
<h3><a class="header" href="#simple-events-1" id="simple-events-1">Simple Events</a></h3>
<p>The event is emitted at the bottom of the <code>do_something</code> function body.</p>
<pre><code class="language-rust ignore">Self::deposit_event(Event::EmitInput(new_number));
</code></pre>
<h3><a class="header" href="#events-with-generic-types-1" id="events-with-generic-types-1">Events with Generic Types</a></h3>
<p>The syntax for <code>deposit_event</code> now takes the <code>RawEvent</code> type because it is generic over the pallet's configuration trait.</p>
<pre><code class="language-rust ignore">Self::deposit_event(RawEvent::EmitInput(user, new_number));
</code></pre>
<h3><a class="header" href="#constructing-the-runtime-2" id="constructing-the-runtime-2">Constructing the Runtime</a></h3>
<p>For the first time in the recipes, our pallet has an associated type in its configuration trait. We must specify this type when implementing its trait. In the case of the <code>Event</code> type, this is entirely straight forward, and looks the same for both simple events and generic events.</p>
<pre><code class="language-rust ignore">impl simple_event::Trait for Runtime {
	type Event = Event;
}
</code></pre>
<p>Events, like dispatchable calls and storage items, requires a slight change to the line in <code>construct_runtime!</code>. Notice that the <code>&lt;T&gt;</code> is necessary for generic events.</p>
<pre><code class="language-rust ignore">construct_runtime!(
	pub enum Runtime where
		Block = Block,
		NodeBlock = opaque::Block,
		UncheckedExtrinsic = UncheckedExtrinsic
	{
		// --snip--
		GenericEvent: generic_event::{Module, Call, Event&lt;T&gt;},
		SimpleEvent: simple_event::{Module, Call, Event},
	}
);
</code></pre>
<h1><a class="header" href="#entrees" id="entrees">Entrees</a></h1>
<p>These Entrees are for chefs who have the basics down. If you've read through the first two chapters of this cookbook, that includes you! The entrees cover a wide variety of topics in Substrate development, and are meant to be read in <em>any order</em>.</p>
<h1><a class="header" href="#storage-api" id="storage-api">Storage API</a></h1>
<p>We've already encountered the <a href="https://substrate.dev/rustdocs/master/frame_support/macro.decl_storage.html"><code>decl_storage!</code> macro</a> in the appetizer on <a href="3-entrees/storage-api/../../2-appetizers/2-storage-values.html">storage items</a>. There is a rich storage API in Substrate which we will explore in this section.</p>
<p>For crypto<em>currencies</em>, storage might consist of a mapping between account keys and corresponding balances.</p>
<p>More generally, blockchains provide an interface to store and interact with data in a verifiable and globally irreversible way. In this context, data is stored in a series of snapshots, each of which may be accessed at a later point in time, but, once created, snapshots are considered irreversible.</p>
<p>Arbitrary data may be stored, as long as its data type is serializable in Substrate i.e. implements <a href="https://docs.rs/parity-scale-codec/1.3.0/parity_scale_codec/#encode"><code>Encode</code></a> and <a href="https://docs.rs/parity-scale-codec/1.3.0/parity_scale_codec/#decode"><code>Decode</code></a> traits.</p>
<p>The previous <em><a href="3-entrees/storage-api/../../2-appetizers/2-storage-values.html">single-value storage recipe</a></em> showed how a single value can be stored in runtime storage. In this section, we cover</p>
<ul>
<li><a href="3-entrees/storage-api/./cache.html">caching values rather than calling to storage multiple times</a></li>
<li><a href="3-entrees/storage-api/./sets-vecs-iteration.html">storing sets, checking membership, and iteration</a></li>
<li><a href="3-entrees/storage-api/./double.html">efficient subgroup removal by key prefix with double maps</a></li>
<li><a href="3-entrees/storage-api/./structs.html">storing custom structs</a></li>
</ul>
<p><em>in-progress</em></p>
<ul>
<li><a href="3-entrees/storage-api/./childtries.html">cheap inclusion proofs with child tries</a></li>
<li><a href="3-entrees/storage-api/./ringbuffer.html">transient storage adapters by example of a ringbuffer queue</a></li>
</ul>
<h1><a class="header" href="#storage-maps" id="storage-maps">Storage Maps</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/simple-map"><code>pallets/simple-map</code></a></em></p>
<p>In the appetizer on <a href="3-entrees/storage-api/../../2-appetizers/2-storage-values.html">storage values</a> we learned to store a single value in blockchain storage to be persisted between blocks. In this recipe, we will see how to store a mapping from keys to values, similar to Rust's own <a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a>.</p>
<h2><a class="header" href="#declaring-a-storagemap" id="declaring-a-storagemap">Declaring a <code>StorageMap</code></a></h2>
<p>We declare a single storage map with the following syntax.</p>
<pre><code class="language-rust ignore">decl_storage! {
	trait Store for Module&lt;T: Trait&gt; as SimpleMap {
		SimpleMap get(fn simple_map): map hasher(blake2_128_concat) T::AccountId =&gt; u32;
	}
}
</code></pre>
<p>Much of this should look familiar to you from storage values. Reading the line from left to right we have:</p>
<ul>
<li><code>SimpleMap</code> - the name of the storage map</li>
<li><code>get(fn simple_map)</code> - the name of a getter function that will return values from the map.</li>
<li><code>: map hasher(blake2_128_concat)</code> - beginning of the type declaration. This is a map and it will use the <a href="https://substrate.dev/rustdocs/master/frame_support/trait.Hashable.html#tymethod.blake2_128_concat"><code>blake2_128_concat</code></a> hasher. More on this below.</li>
<li><code>T::AccountId =&gt; u32</code> - The specific key and value tyes of the map. This is a map from <code>AccountId</code>s to <code>u32</code>s.</li>
</ul>
<h2><a class="header" href="#choosing-a-hasher" id="choosing-a-hasher">Choosing a Hasher</a></h2>
<p>Although the syntax above is complex, most of it should be straightforward if you've understood the recipe on storage values. The last unfamiliar piece of writing a storage map is choosing which hasher to use. In general you should choose one of the three following hashers. The choice of hasher will affect the performance and security of your chain. If you don't want to think much about this, just choose <code>blake2_128_concat</code> and skip to the next section.</p>
<h3><a class="header" href="#blake2_128_concat" id="blake2_128_concat"><code>blake2_128_concat</code></a></h3>
<p>This is a cryptographically secure hash function, and is always safe to use. It is reasonably efficient, and will keep your storage tree balanced. You <em>must</em> choose this hasher if users of your chain have the ability to affect the storage keys. In this pallet, the keys are <code>AccountId</code>s. At first it may <em>seem</em> that the user doesn't affect the <code>AccountId</code>, but in reality a malicious user can generate thousands of accounts and use the one that will affect the chain's storage tree in the way the attacker likes. For this reason, we have chosen to use the <code>blake2_128_concat</code> hasher.</p>
<h3><a class="header" href="#twox_64_concat" id="twox_64_concat"><code>twox_64_concat</code></a></h3>
<p>This hasher is <em>not</em> cryptographically secure, but is more efficient than blake2. Thus it represents trading security for performance. You should <em>not</em> use this hasher if chain users can affect the storage keys. However, it is perfectly safe to use this hasher to gain performance in scenarios where the users do not control the keys. For example, if the keys in your map are sequentially increasing indices and users cannot cause the indices to rapidly increase, then this is a perfectly reasonable choice.</p>
<h3><a class="header" href="#identity" id="identity"><code>identity</code></a></h3>
<p>The <code>identity</code> &quot;hasher&quot; is really not a hasher at all, but merely an <a href="https://en.wikipedia.org/wiki/Identity_function">identity function</a> that returns the same value it receives. This hasher is only an option when the key type in your storage map is <em>already</em> a hash, and is not controllable by the user. If you're in doubt whether the user can influence the key just use blake2.</p>
<h2><a class="header" href="#the-storage-map-api" id="the-storage-map-api">The Storage Map API</a></h2>
<p>This pallet demonstrated some of the most common methods available in a storage map including <code>insert</code>, <code>get</code>, <code>take</code>, and <code>contains_key</code>.</p>
<pre><code class="language-rust ignore">// Insert
&lt;SimpleMap&lt;T&gt;&gt;::insert(&amp;user, entry);

// Get
let entry = &lt;SimpleMap&lt;T&gt;&gt;::get(account);

// Take
let entry = &lt;SimpleMap&lt;T&gt;&gt;::take(&amp;user);

// Contains Key
&lt;SimpleMap&lt;T&gt;&gt;::contains_key(&amp;user)
</code></pre>
<p>The rest of the API is documented in the rustdocs on the <a href="https://substrate.dev/rustdocs/master/frame_support/storage/trait.StorageMap.html"><code>StorageMap</code> trait</a>. You do not need to explicitly <code>use</code> this trait because the <code>decl_storage!</code> macro will do it for you if you use a storage map.</p>
<h1><a class="header" href="#cache-multiple-calls" id="cache-multiple-calls">Cache Multiple Calls</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/storage-cache"><code>pallets/storage-cache</code></a></em></p>
<p>Calls to runtime storage have an associated cost. With this in mind, multiple calls to storage values should be avoided when possible.</p>
<pre><code class="language-rust ignore">decl_storage! {
	trait Store for Module&lt;T: Trait&gt; as StorageCache {
		// copy type
		SomeCopyValue get(fn some_copy_value): u32;

		// clone type
		KingMember get(fn king_member): T::AccountId;
		GroupMembers get(fn group_members): Vec&lt;T::AccountId&gt;;
	}
}
</code></pre>
<h2><a class="header" href="#copy-types" id="copy-types">Copy Types</a></h2>
<p>For <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a> types, it is easy to reuse previous storage calls by simply reusing the value (which is automatically cloned upon reuse). With this in mind, the second call in the following code is unnecessary:</p>
<pre><code class="language-rust ignore">fn increase_value_no_cache(origin, some_val: u32) -&gt; DispatchResult {
	let _ = ensure_signed(origin)?;
	let original_call = &lt;SomeCopyValue&gt;::get();
	let some_calculation = original_call.checked_add(some_val).ok_or(&quot;addition overflowed1&quot;)?;
	// this next storage call is unnecessary and is wasteful
	let unnecessary_call = &lt;SomeCopyValue&gt;::get();
	// should've just used `original_call` here because u32 is copy
	let another_calculation = some_calculation.checked_add(unnecessary_call).ok_or(&quot;addition overflowed2&quot;)?;
	&lt;SomeCopyValue&gt;::put(another_calculation);
	let now = &lt;system::Module&lt;T&gt;&gt;::block_number();
	Self::deposit_event(RawEvent::InefficientValueChange(another_calculation, now));
	Ok(())
}
</code></pre>
<p>Instead, the initial call value should be reused. In this example, the <code>SomeCopyValue</code> value is <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a> so we should prefer the following code without the unnecessary second call to storage:</p>
<pre><code class="language-rust ignore">fn increase_value_w_copy(origin, some_val: u32) -&gt; DispatchResult {
	let _ = ensure_signed(origin)?;
	let original_call = &lt;SomeCopyValue&gt;::get();
	let some_calculation = original_call.checked_add(some_val).ok_or(&quot;addition overflowed1&quot;)?;
	// uses the original_call because u32 is copy
	let another_calculation = some_calculation.checked_add(original_call).ok_or(&quot;addition overflowed2&quot;)?;
	&lt;SomeCopyValue&gt;::put(another_calculation);
	let now = &lt;system::Module&lt;T&gt;&gt;::block_number();
	Self::deposit_event(RawEvent::BetterValueChange(another_calculation, now));
	Ok(())
}
</code></pre>
<h2><a class="header" href="#clone-types" id="clone-types">Clone Types</a></h2>
<p>If the type was not <code>Copy</code>, but was <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a>, then it is still preferred to clone the value in the method than to make another call to runtime storage.</p>
<p>The runtime methods enable the calling account to swap the <code>T::AccountId</code> value in storage if</p>
<ol>
<li>the existing storage value is not in <code>GroupMembers</code> AND</li>
<li>the calling account is in <code>GroupMembers</code></li>
</ol>
<p>The first implementation makes a second unnecessary call to runtime storage instead of cloning the call for <code>existing_key</code>:</p>
<pre><code class="language-rust ignore">fn swap_king_no_cache(origin) -&gt; DispatchResult {
	let new_king = ensure_signed(origin)?;
	let existing_king = &lt;KingMember&lt;T&gt;&gt;::get();

	// only places a new account if
	// (1) the existing account is not a member &amp;&amp;
	// (2) the new account is a member
	ensure!(!Self::is_member(&amp;existing_king), &quot;current king is a member so maintains priority&quot;);
	ensure!(Self::is_member(&amp;new_king), &quot;new king is not a member so doesn't get priority&quot;);

	// BAD (unnecessary) storage call
	let old_king = &lt;KingMember&lt;T&gt;&gt;::get();
	// place new king
	&lt;KingMember&lt;T&gt;&gt;::put(new_king.clone());

	Self::deposit_event(RawEvent::InefficientKingSwap(old_king, new_king));
	Ok(())
}
</code></pre>
<p>If the <code>existing_key</code> is used without a <code>clone</code> in the event emission instead of <code>old_king</code>, then the compiler returns the following error</p>
<pre><code class="language-bash">error[E0382]: use of moved value: `existing_king`
  --&gt; src/lib.rs:93:63
   |
80 |             let existing_king = &lt;KingMember&lt;T&gt;&gt;::get();
   |                 ------------- move occurs because `existing_king` has type `&lt;T as frame_system::Trait&gt;::AccountId`, which does not implement the `Copy` trait
...
85 |             ensure!(!Self::is_member(existing_king), &quot;is a member so maintains priority&quot;);
   |                                      ------------- value moved here
...
93 |             Self::deposit_event(RawEvent::InefficientKingSwap(existing_king, new_king));
   |                                                               ^^^^^^^^^^^^^ value used here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: Could not compile `storage-cache`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Fixing this only requires cloning the original value before it is moved:</p>
<pre><code class="language-rust ignore">fn swap_king_with_cache(origin) -&gt; DispatchResult {
	let new_king = ensure_signed(origin)?;
	let existing_king = &lt;KingMember&lt;T&gt;&gt;::get();
	// prefer to clone previous call rather than repeat call unnecessarily
	let old_king = existing_king.clone();

	// only places a new account if
	// (1) the existing account is not a member &amp;&amp;
	// (2) the new account is a member
	ensure!(!Self::is_member(&amp;existing_king), &quot;current king is a member so maintains priority&quot;);
	ensure!(Self::is_member(&amp;new_king), &quot;new king is not a member so doesn't get priority&quot;);

	// &lt;no (unnecessary) storage call here&gt;
	// place new king
	&lt;KingMember&lt;T&gt;&gt;::put(new_king.clone());

	Self::deposit_event(RawEvent::BetterKingSwap(old_king, new_king));
	Ok(())
}
</code></pre>
<p>Not all types implement <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a> or <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a>, so it is important to discern other patterns that minimize and alleviate the cost of calls to storage.</p>
<h1><a class="header" href="#set-storage-and-iteration" id="set-storage-and-iteration">Set Storage and Iteration</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/vec-set"><code>pallets/vec-set</code></a></em></p>
<p>Storing a vector in the runtime can often be useful for managing groups and verifying membership. This recipe discusses common patterns encounted when storing vectors in runtime storage.</p>
<ul>
<li><a href="3-entrees/storage-api/sets-vecs-iteration.html#group">verifying group membership</a></li>
<li><a href="3-entrees/storage-api/sets-vecs-iteration.html#append">Append vs Mutate</a></li>
<li><a href="3-entrees/storage-api/sets-vecs-iteration.html#iterate">Iteration in the Runtime</a></li>
</ul>
<h2><a class="header" href="#verifying-group-membership-a-name--groupa" id="verifying-group-membership-a-name--groupa">Verifying Group Membership <a name = "group"></a></a></h2>
<p>To maintain a set of <code>AccountId</code> to establish group ownership of decisions, it is straightforward to store a vector in the runtime of <code>AccountId</code>.</p>
<pre><code class="language-rust ignore">decl_storage! {
	trait Store for Module&lt;T: Trait&gt; as VecMap {
        Members get(fn members): Vec&lt;T::AccountId&gt;;
	}
}
</code></pre>
<p>It is easy to add the following helper method to verify membership elsewhere in the runtime.</p>
<pre><code class="language-rust ignore">impl&lt;T: Trait&gt; Module&lt;T&gt; {
    fn is_member(who: &amp;T::AccountId) -&gt; bool {
        &lt;Members&lt;T&gt;&gt;::get().contains(who)
    }
}
</code></pre>
<p>This helper method can be placed in other runtime methods to restrict certain changes to runtime storage to privileged groups. Depending on the incentive structure of the network/chain, the members in these groups may have earned membership and the subsequent access rights through loyal contributions to the system.</p>
<pre><code class="language-rust ignore">// use support::ensure
fn member_action(origin) -&gt; Result {
    let member = ensure_signed(origin)?;
    ensure!(Self::is_member(&amp;member), &quot;not a member =&gt; cannot do action&quot;);
    // &lt;action &amp;&amp; || storage change&gt;
    Ok(())
}
</code></pre>
<p>In this example, the helper method facilitates isolation of runtime storage access rights according to membership. In general, <strong>place <code>ensure!</code> checks at the top of each runtime function's logic to verify that all of the requisite checks pass before performing any storage changes.</strong></p>
<blockquote>
<p>NOTE: <em><a href="https://github.com/substrate-developer-hub/recipes/issues/35">child trie</a> storage provides a more efficient data structure for tracking group membership</em></p>
</blockquote>
<h2><a class="header" href="#append-vs-mutate" id="append-vs-mutate">Append vs. Mutate</a></h2>
<pre><code class="language-rust ignore">decl_storage! {
	trait Store for Module&lt;T: Trait&gt; as VecMap {
	    CurrentValues get(fn current_values): Vec&lt;u32&gt;;
        NewValues get(fn new_values): Vec&lt;u32&gt;;
	}
}
</code></pre>
<p>Before <a href="https://github.com/paritytech/substrate/pull/3071">3071</a> was merged, it was necessary to call <a href="https://substrate.dev/rustdocs/master/frame_support/storage/trait.StorageValue.html#tymethod.mutate"><code>mutate</code></a> to push new values to a vector stored in runtime storage.</p>
<pre><code class="language-rust ignore">fn mutate_to_append(origin) -&gt; Result {
    let user = ensure_signed(origin)?;

    // this decodes the existing vec, appends the new values, and re-encodes the whole thing
    &lt;CurrentValues&gt;::mutate(|v| v.extend_from_slice(&amp;Self::new_values()));
    Self::deposit_event(RawEvent::MutateToAppend(user));
    Ok(())
}
</code></pre>
<p>For vectors stored in the runtime, mutation can be relatively expensive. This follows from the fact that <code>mutate</code> entails decoding the vector, making changes, and re-encoding the whole vector. It seems wasteful to decode the entire vector, push a new item, and then re-encode the whole thing. This provides sufficient motivation for <a href="https://substrate.dev/rustdocs/master/frame_support/storage/trait.StorageValue.html#tymethod.append"><code>append</code></a>:</p>
<pre><code class="language-rust ignore">fn append_new_entries(origin) -&gt; Result {
    let user = ensure_signed(origin)?;

    // this encodes the new values and appends them to the already encoded existing evc
    let mut current_values = Self::current_values();
    current_values.append(&amp;mut Self::new_values());
    Self::deposit_event(RawEvent::AppendVec(user));
    Ok(())
}
</code></pre>
<p><code>append</code> encodes the new values, and pushes them to the already encoded vector without decoding the existing entries. This method removes the unnecessary steps for decoding and re-encoding the unchanged elements.</p>
<h2><a class="header" href="#iteration-in-the-runtime-a-name--iteratea" id="iteration-in-the-runtime-a-name--iteratea">Iteration in the Runtime <a name = "iterate"></a></a></h2>
<p>In general, iteration in the runtime should be avoided. <em>In the future</em>, <a href="https://github.com/substrate-developer-hub/recipes/issues/45">offchain-workers</a> may provide a less expensive way to iterate over runtime storage items. Moreover, <em><a href="https://github.com/substrate-developer-hub/recipes/issues/35">child tries</a></em> enable cheap inclusion proofs without the same lookup costs associated with vectors.</p>
<p>Even so, there are a few tricks to alleviate the costs of iterating over runtime storage items like vectors. For example, it is <a href="https://twitter.com/heinz_gies/status/1121490424739303425">cheaper to iterate over a slice</a> than a vector. With this in mind, store items in the runtime as vectors and transform them into slices after making storage calls. <a href="https://github.com/paritytech/substrate/pull/3041">3041</a> introduced <code>insert_ref</code> and <code>put_ref</code> in order to allow equivalent reference-style types to be placed without copy (e.g. a storage item of <code>Vec&lt;AccountId&gt;</code> can now be written from a <code>&amp;[AccountId]</code>). This enables greater flexibility when working with slices that are associated with vectors stored in the runtime.</p>
<h1><a class="header" href="#efficent-subgroup-removal-by-subkey-double-maps" id="efficent-subgroup-removal-by-subkey-double-maps">Efficent Subgroup Removal by Subkey: Double Maps</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/double-map"><code>pallets/double-map</code></a></em></p>
<p>For some runtimes, it may be necessary to remove a subset of values in a key-value mapping. If the subset maintain an associated identifier type, this can be done in a clean way with the <a href="https://substrate.dev/rustdocs/master/frame_support/storage/trait.StorageDoubleMap.html"><code>double_map</code></a> via the <code>remove_prefix</code> api.</p>
<pre><code class="language-rust ignore">pub type GroupIndex = u32; // this is Encode (which is necessary for double_map)

decl_storage! {
	trait Store for Module&lt;T: Trait&gt; as Dmap {
		/// Member score (double map)
		MemberScore get(fn member_score):
			double_map hasher(blake2_128_concat) GroupIndex, hasher(blake2_128_concat) T::AccountId =&gt; u32;
		/// Get group ID for member
		GroupMembership get(fn group_membership): map hasher(blake2_128_concat) T::AccountId =&gt; GroupIndex;
		/// For fast membership checks, see check-membership recipe for more details
		AllMembers get(fn all_members): Vec&lt;T::AccountId&gt;;
	}
}
</code></pre>
<p>For the purposes of this example, store the scores of each members in a map that associates this <code>u32</code> value with two keys: (1) a <code>GroupIndex</code> identifier, and (2) the member's <code>AccountId</code>. This allows for efficient removal of all values associated with a specific <code>GroupIndex</code> identifier.</p>
<pre><code class="language-rust ignore">fn remove_group_score(origin, group: GroupIndex) -&gt; DispatchResult {
	let member = ensure_signed(origin)?;

	let group_id = &lt;GroupMembership&lt;T&gt;&gt;::get(member);
	// check that the member is in the group
	ensure!(group_id == group, &quot;member isn't in the group, can't remove it&quot;);

	// remove all group members from MemberScore at once
	&lt;MemberScore&lt;T&gt;&gt;::remove_prefix(&amp;group_id);

	Self::deposit_event(RawEvent::RemoveGroup(group_id));
	Ok(())
}
</code></pre>
<h1><a class="header" href="#child-tries" id="child-tries">Child Tries</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/child-trie"><code>pallets/child-trie</code></a></em>, <em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/simple-crowdfund"><code>pallets/simple-crowdfund</code></a></em></p>
<ul>
<li><a href="3-entrees/storage-api/childtries.html#storj">Runtime Child Storage</a></li>
<li><a href="3-entrees/storage-api/childtries.html#smplcrwd">Crowdfund Example</a></li>
</ul>
<p>A <a href="https://en.wikipedia.org/wiki/Trie">trie</a> is an ordered tree structure for managing dynamic sets. For any given parent node, all descendants (children) share a common prefix associated with the parent.</p>
<p>This construction lends itself to efficient removal of subgroups of a dataset (similar to <a href="3-entrees/storage-api/./double.html"><code>double_map</code></a>). By associating a common prefix with related data, the dataset can be partitioned to effectively batch deletions.</p>
<p>Every change in the leaves percolates up to the root, thereby providing a complete, succinct history of all changes to the underlying data structure in the form of the trie root hash.</p>
<h2><a class="header" href="#runtime-child-storage-a-name--storja" id="runtime-child-storage-a-name--storja">Runtime Child Storage <a name = "storj"></a></a></h2>
<p>To interact with child tries, there are methods exposed in <a href="https://substrate.dev/rustdocs/master/frame_support/storage/child/index.html">runtime child storage</a>. Of the methods listed in the documentation, it is worth emphasizing the method associated with batch deletion.</p>
<pre><code class="language-rust ignore">pub fn kill_trie(index: ObjectCount) {
	let id = Self::id_from_index(index);
	child::kill_storage(
		id.as_ref(),
		trie_unique_id(id.as_ref()),
	);
}
</code></pre>
<p><a href="https://substrate.dev/rustdocs/master/frame_support/storage/child/fn.kill_storage.html"><code>kill_storage</code></a> deletes all  <code>(key, value)</code> pairs associated with the <code>storage_key</code>. The basic API for interacting with a given child trie follows this format:</p>
<pre><code class="language-rust ignore">// pseudocode
child::do(trie_id, key, value);
</code></pre>
<p>To put an object in a child trie, the code would look something like</p>
<pre><code class="language-rust ignore">pub fn kv_put(index: ObjectCount, who: &amp;T::AccountId, value_to_put: ValAppended) {
	let id = Self::id_from_index(index);
	who.using_encoded(|b| child::put(
			id.as_ref(),
			trie_unique_id(id.as_ref()),
			b,
			&amp;value_to_put
	));
}
</code></pre>
<p>The code in <a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/child-trie"><code>pallets/child-trie</code></a> demonstrates a minimal way of organizing the basic child-trie api methods (as done in <a href="https://github.com/paritytech/polkadot/blob/c003d73c65cdcc0367340db09522c91d1d3851fc/runtime/common/src/crowdfund.rs"><code>polkadot/runtime/crowdfund</code></a>). It separates out the generation of the child trie id from the index with a runtime method <code>id_from_index</code>.</p>
<pre><code class="language-rust ignore">pub fn id_from_index(index: ObjectCount) -&gt; Vec&lt;u8&gt; {
	let mut buf = Vec::new();
	buf.extend_from_slice(b&quot;exchildtr&quot;);
	buf.extend_from_slice(&amp;index.to_le_bytes()[..]);

	CHILD_STORAGE_KEY_PREFIX
		.into_iter()
		.chain(b&quot;default:&quot;)
		.chain(Blake2Hasher::hash(&amp;buf[..]).as_ref().into_iter())
		.cloned()
		.collect()
}
</code></pre>
<p>This results in less code for each method.</p>
<h2><a class="header" href="#smpl-crowdfund-a-name--smplcrwda" id="smpl-crowdfund-a-name--smplcrwda">smpl-crowdfund <a name = "smplcrwd"></a></a></h2>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/simple-crowdfund"><code>pallets/simple-crowdfund</code></a></em></p>
<p>Child tries are useful for batch deletion of <code>(key, value)</code> pairs associated with a specific <code>trie_id</code>. This is relevant to the <a href="https://github.com/paritytech/polkadot/blob/master/runtime/common/src/crowdfund.rs">polkadot/crowdfund</a> pallet, which tracks <code>(AccountId, BalanceOf&lt;T&gt;)</code> associated with a specific crowdfund. <code>BalanceOf&lt;T&gt;</code> represents the contributions of an <code>AccountId</code>. The identifier for each crowdfund is defined</p>
<pre><code class="language-rust ignore">type FundIndex = u32
</code></pre>
<p>With these three types, this storage item effectively manages <code>(FundIndex, AccountId, BalanceOf&lt;T&gt;)</code>. By maintaining a separate <code>child</code> for every <code>FundIndex</code>, this api allows for efficient batch deletions when crowdfunds are ended and dissolved.</p>
<pre><code class="language-rust ignore">// polkadot/runtime/crowdfund
pub fn crowdfund_kill(index: FundIndex) {
    let id = Self::id_from_index(index);
    child::kill_storage(id.as_ref());
}
</code></pre>
<p>The child trie api is useful when data associated with an identifier needs to be isolated to facilitate efficient batch removal. In this case, all the information associated with a given crowdfund should be removed when the crowdfund is dissolved.</p>
<h3><a class="header" href="#caveat-coder" id="caveat-coder">caveat coder</a></h3>
<p>Each individual call to read/write to the child trie is more expensive than it would be for <code>map</code> or <code>double_map</code>. This cost is poorly amortized over a large number of calls, but can be significantly reduced by following a proper batch execution strategy.</p>
<h1><a class="header" href="#using-and-storing-structs" id="using-and-storing-structs">Using and Storing Structs</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/struct-storage"><code>pallets/struct-storage</code></a></em></p>
<p>In Rust, a <code>struct</code>, or structure, is a custom data type that lets you name and package together multiple related values that make up a meaningful group. If you‚Äôre familiar with an object-oriented language, a <code>struct</code> is like an object‚Äôs data attributes (read more in <a href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html">The Rust Book</a>).</p>
<h2><a class="header" href="#defining-a-struct" id="defining-a-struct">Defining a Struct</a></h2>
<p>To define a <em>simple</em> custom struct for the runtime, the following syntax may be used:</p>
<pre><code class="language-rust ignore">#[derive(Encode, Decode, Default, Clone, PartialEq)]
pub struct MyStruct {
    some_number: u32,
    optional_number: Option&lt;u32&gt;,
}
</code></pre>
<p>In the code snippet above, the <a href="https://doc.rust-lang.org/rust-by-example/trait/derive.html">derive macro</a> is declared to ensure <code>MyStruct</code> conforms to shared behavior according to the specified <a href="https://doc.rust-lang.org/book/ch10-02-traits.html">traits</a>: <code>Encode, Decode, Default, Clone, PartialEq</code>. If you wish the store this struct in blockchain storage, you will need to derive (or manually ipmlement) each of these traits.</p>
<p>To use the <code>Encode</code> and <code>Decode</code> traits, it is necessary to import them.</p>
<pre><code class="language-rust ignore">use frame_support::codec::{Encode, Decode};
</code></pre>
<h2><a class="header" href="#structs-with-generic-fields" id="structs-with-generic-fields">Structs with Generic Fields</a></h2>
<p>The simple struct shown earlier only uses Rust primitive types for its fields. In the common case where you want to store types that come from your pallet's configuration trait (or the configuration trait of another pallet in your runtime), you must use generic type parameters in your struct's definition.</p>
<pre><code class="language-rust ignore">#[derive(Encode, Decode, Clone, Default, RuntimeDebug)]
pub struct InnerThing&lt;Hash, Balance&gt; {
	number: u32,
	hash: Hash,
	balance: Balance,
}
</code></pre>
<p>Here you can see that we want to store items of type <code>Hash</code> and <code>Balance</code> in the struct. Because these types come from the system and balances pallets' configuration traits, we must specify them as generics when declaring the struct.</p>
<p>It is often convenient to make a type alias that takes <code>T</code>, your pallet's configuration trait, as a single type parameter. Doing so simply saves you typing in the future.</p>
<pre><code class="language-rust ignore">type InnerThingOf&lt;T&gt; = InnerThing&lt;&lt;T as system::Trait&gt;::Hash, &lt;T as balances::Trait&gt;::Balance&gt;;
</code></pre>
<h2><a class="header" href="#structs-in-storage" id="structs-in-storage">Structs in Storage</a></h2>
<p>Using one of our structs as a storage item is not significantly different than using a primitive type. When using a generic struct, we must supply all of the generic type parameters. This snippet shows how to supply thos parameters when you have a type alias (like we do for <code>InnerThing</code>) as well as when you don't. Whether to include the type alias is a matter of style and taste, but it is generally preferred when the entire type exceeds the preferred line length.</p>
<pre><code class="language-rust ignore">decl_storage! {
	trait Store for Module&lt;T: Trait&gt; as NestedStructs {
		InnerThingsByNumbers get(fn inner_things_by_numbers):
			map hasher(blake2_128_concat) u32 =&gt; InnerThingOf&lt;T&gt;;
		SuperThingsBySuperNumbers get(fn super_things_by_super_numbers):
			map hasher(blake2_256) u32 =&gt; SuperThing&lt;T::Hash, T::Balance&gt;;
	}
}
</code></pre>
<p>Interacting with the storage maps is now exactly as it was when we didn't use any custom structs</p>
<pre><code class="language-rust ignore">fn insert_inner_thing(origin, number: u32, hash: T::Hash, balance: T::Balance) -&gt; DispatchResult {
	let _ = ensure_signed(origin)?;
	let thing = InnerThing {
					number,
					hash,
					balance,
				};
	&lt;InnerThingsByNumbers&lt;T&gt;&gt;::insert(number, thing);
	Self::deposit_event(RawEvent::NewInnerThing(number, hash, balance));
	Ok(())
}
</code></pre>
<h2><a class="header" href="#nested-structs" id="nested-structs">Nested Structs</a></h2>
<p>Structs can also contain other structs as their fields. We have demonstrated this with the type <code>SuperThing</code>. As you see, any generic types needed by the inner struct must also be supplied to the outer.</p>
<pre><code class="language-rust ignore">#[derive(Encode, Decode, Default, RuntimeDebug)]
pub struct SuperThing&lt;Hash, Balance&gt; {
	super_number: u32,
	inner_thing: InnerThing&lt;Hash, Balance&gt;,
}
</code></pre>
<h1><a class="header" href="#ringbuffer-queue" id="ringbuffer-queue">Ringbuffer Queue</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/ringbuffer-queue"><code>pallets/ringbuffer-queue</code></a></em></p>
<blockquote>
<p>Building a transient adapter on top of storage.</p>
</blockquote>
<p>This pallet provides a trait and implementation for a <a href="https://en.wikipedia.org/wiki/Circular_buffer">ringbuffer</a> that abstracts over storage items and presents them as a <a href="https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)">FIFO</a> queue.</p>
<p>When building more sophisticated pallets you might notice a need for more complex data structures stored in storage. This recipe shows how to build a transient storage adapter by walking through the implementation of a ringbuffer FIFO queue. The adapter in this recipe manages a queue that is persisted as a <code>StorageMap</code> and a <code>(start, end)</code> range in storage.</p>
<p>The <a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/ringbuffer-queue/src/lib.rs"><code>ringbuffer-queue/src/lib.rs</code></a> file contains the <a href="3-entrees/storage-api/ringbuffer.html#usage">usage</a> of the transient storage adapter while <a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/ringbuffer-queue/src/ringbuffer.rs"><code>ringbuffer-queue/src/ringbuffer.rs</code></a> contains the implementation.</p>
<h2><a class="header" href="#defining-the-ringbuffer-trait-a-name--traita" id="defining-the-ringbuffer-trait-a-name--traita">Defining the RingBuffer Trait <a name = "trait"></a></a></h2>
<p>First we define the queue interface we want to use:</p>
<pre><code class="language-rust ignore">pub trait RingBufferTrait&lt;Item&gt;
where
	Item: Codec + EncodeLike,
{
	/// Store all changes made in the underlying storage.
	fn commit(&amp;self);
	/// Push an item onto the end of the queue.
	fn push(&amp;mut self, i: Item);
	/// Pop an item from the start of the queue.
	fn pop(&amp;mut self) -&gt; Option&lt;Item&gt;;
	/// Return whether the queue is empty.
	fn is_empty(&amp;self) -&gt; bool;
}
</code></pre>
<p>It defines the usual <code>push</code>, <code>pop</code> and <code>is_empty</code> functions we expect from a queue as well as a <code>commit</code> function that will be used to sync the changes made to the underlying storage.</p>
<h2><a class="header" href="#specifying-the-ringbuffer-transient-a-name--transienta" id="specifying-the-ringbuffer-transient-a-name--transienta">Specifying the RingBuffer Transient <a name = "transient"></a></a></h2>
<p>Now we want to add an implementation of the trait. We will be storing the start and end of the ringbuffer separately from the actual items and will thus need to store these in our struct:</p>
<pre><code class="language-rust ignore">pub struct RingBufferTransient&lt;Index&gt;
where
	Index: Codec + EncodeLike + Eq + Copy,
{
	start: Index,
	end: Index,
}
</code></pre>
<h3><a class="header" href="#defining-the-storage-interface" id="defining-the-storage-interface">Defining the Storage Interface</a></h3>
<p>In order to access the underlying storage we will also need to include the bounds (we will call the type <code>B</code>) and the item storage (whose type will be <code>M</code>). In order to specify the constraints on the storage map (<code>M</code>) we will also need to specify the <code>Item</code> type.
This results in the following struct definition:</p>
<pre><code class="language-rust ignore">pub struct RingBufferTransient&lt;Item, B, M, Index&gt;
where
	Item: Codec + EncodeLike,
	B: StorageValue&lt;(Index, Index), Query = (Index, Index)&gt;,
	M: StorageMap&lt;Index, Item, Query = Item&gt;,
	Index: Codec + EncodeLike + Eq + Copy,
{
	start: Index,
	end: Index,
	_phantom: PhantomData&lt;(Item, B, M)&gt;,
}
</code></pre>
<p>The bounds <code>B</code> will be a <code>StorageValue</code> storing a tuple of indices <code>(Index, Index)</code>. The item storage will be a <code>StorageMap</code> mapping from our <code>Index</code> type to the <code>Item</code> type. We specify the associated <code>Query</code> type for both of them to help with type inference (because the value returned can be different from the stored representation).</p>
<p>The <a href="https://docs.rs/parity-scale-codec/1.3.0/parity_scale_codec/trait.Codec.html"><code>Codec</code></a> and <a href="https://docs.rs/parity-scale-codec/1.3.0/parity_scale_codec/trait.EncodeLike.html"><code>EncodeLike</code></a> type constraints make sure that both items and indices can be stored in storage.</p>
<p>We need the <a href="https://doc.rust-lang.org/std/marker/struct.PhantomData.html"><code>PhantomData</code></a> in order to &quot;hold on to&quot; the types during the lifetime of the transient object.</p>
<h3><a class="header" href="#the-complete-type" id="the-complete-type">The Complete Type</a></h3>
<p>There are two more alterations we will make to our struct to make it work well:</p>
<pre><code class="language-rust ignore">type DefaultIdx = u16;
pub struct RingBufferTransient&lt;Item, B, M, Index = DefaultIdx&gt;
where
	Item: Codec + EncodeLike,
	B: StorageValue&lt;(Index, Index), Query = (Index, Index)&gt;,
	M: StorageMap&lt;Index, Item, Query = Item&gt;,
	Index: Codec + EncodeLike + Eq + WrappingOps + From&lt;u8&gt; + Copy,
{
	start: Index,
	end: Index,
	_phantom: PhantomData&lt;(Item, B, M)&gt;,
}
</code></pre>
<p>We specify a default type for <code>Index</code> and define it as <code>u16</code> to allow for 65536 entries in the ringbuffer per default. We also add the <code>WrappingOps</code> and <code>From&lt;u8&gt;</code> type bounds to enable the kind of operations we need in our implementation. More details in the <a href="3-entrees/storage-api/ringbuffer.html#implementation">implementation</a> section, especially in the <a href="3-entrees/storage-api/ringbuffer.html#wrapping_ops"><code>WrappingOps</code></a> subsection.</p>
<h2><a class="header" href="#implementation-of-the-ringbuffer-a-name--implementationa" id="implementation-of-the-ringbuffer-a-name--implementationa">Implementation of the RingBuffer <a name = "implementation"></a></a></h2>
<p>Now that we have the type definition for <code>RingBufferTransient</code> we need to write the implementation.</p>
<h3><a class="header" href="#instantiating-the-transient" id="instantiating-the-transient">Instantiating the Transient</a></h3>
<p>First we need to specify how to create a new instance by providing a <code>new</code> function:</p>
<pre><code class="language-rust ignore">impl&lt;Item, B, M, Index&gt; RingBufferTransient&lt;Item, B, M, Index&gt;
where // ... same where clause as the type, elided here
{
	pub fn new() -&gt; RingBufferTransient&lt;Item, B, M, Index&gt; {
		let (start, end) = B::get();
		RingBufferTransient {
			start, end, _phantom: PhantomData,
		}
	}
}
</code></pre>
<p>Here we access the bounds stored in storage to initialize the transient.</p>
<blockquote>
<p><strong>Aside</strong>: Of course we could also provide a <code>with_bounds</code> function that takes the bounds as a parameter. Feel free to add that function as an exercise.</p>
</blockquote>
<blockquote>
<p><strong>Second Aside</strong>: This <code>B::get()</code> is one of the reasons for specifying the <code>Query</code> associated type on the <code>StorageValue</code> type constraint.</p>
</blockquote>
<h3><a class="header" href="#implementing-the-ringbuffertrait" id="implementing-the-ringbuffertrait">Implementing the <code>RingBufferTrait</code></a></h3>
<p>We will now implement the <code>RingBufferTrait</code>:</p>
<pre><code class="language-rust ignore">impl&lt;Item, B, M, Index&gt; RingBufferTrait&lt;Item&gt; for RingBufferTransient&lt;Item, B, M, Index&gt;
where // same as the struct definition
	Item: Codec + EncodeLike,
	B: StorageValue&lt;(Index, Index), Query = (Index, Index)&gt;,
	M: StorageMap&lt;Index, Item, Query = Item&gt;,
	Index: Codec + EncodeLike + Eq + WrappingOps + From&lt;u8&gt; + Copy,
{
	fn commit(&amp;self) {
		B::put((self.start, self.end));
	}
</code></pre>
<p><code>commit</code> just consists of putting the potentially changed bounds into storage. You will notice that we don't update the bounds' storage when changing them in the other functions.</p>
<pre><code class="language-rust ignore">	fn is_empty(&amp;self) -&gt; bool {
		self.start == self.end
	}
</code></pre>
<p>The <code>is_empty</code> function just checks whether the start and end bounds have the same value to determine whether the queue is empty, thus avoiding expensive storage accesses. This means we need to uphold the corresponding invariant in the other (notably the <code>push</code>) functions.</p>
<pre><code class="language-rust ignore">	fn push(&amp;mut self, item: Item) {
		M::insert(self.end, item);
		// this will intentionally overflow and wrap around when bonds_end
		// reaches `Index::max_value` because we want a ringbuffer.
		let next_index = self.end.wrapping_add(1.into());
		if next_index == self.start {
			// queue presents as empty but is not
			// --&gt; overwrite the oldest item in the FIFO ringbuffer
			self.start = self.start.wrapping_add(1.into());
		}
		self.end = next_index;
	}
</code></pre>
<p>In the <code>push</code> function, we insert the pushed <code>item</code> into the map and calculate the new bounds by using the <code>wrapping_add</code> function. This way our ringbuffer will wrap around when reaching <code>max_value</code> of the <code>Index</code> type. This is why we need the <code>WrappingOps</code> type trait for <code>Index</code>.</p>
<p>The <code>if</code> is necessary because we need to keep the invariant that <code>start == end</code> means that the queue is empty, otherwise we would need to keep track of this state separately. We thus &quot;toss away&quot; the oldest item in the queue if a new item is pushed into a full queue by incrementing the start index.</p>
<blockquote>
<h5><a class="header" href="#note-the-wrappingops-trait-a-name--wrapping_opsa" id="note-the-wrappingops-trait-a-name--wrapping_opsa">Note: The <code>WrappingOps</code> Trait <a name = "wrapping_ops"></a></a></h5>
<p>The ringbuffer should be agnostic to the concrete <code>Index</code> type used. In order to be able to decrement and increment the start and end index, though, any concrete type needs to implement <code>wrapping_add</code> and <code>wrapping_sub</code>. Because <code>std</code> does not provide such a trait, we need another way to require this behavior. One possbility would be using the <a href="https://crates.io/crates/num-traits"><code>num_traits</code> crate</a>, but to keep things simple here we just implement our own trait <code>WrappingOps</code> for the types we want to support (<code>u8</code>, <code>u16</code>, <code>u32</code> and <code>u64</code>).</p>
</blockquote>
<p>The last function we implement is <code>pop</code>:</p>
<pre><code class="language-rust ignore">	fn pop(&amp;mut self) -&gt; Option&lt;Item&gt; {
		if self.is_empty() {
			return None;
		}
		let item = M::take(self.start);
		self.start = self.start.wrapping_add(1.into());

		item.into()
	}
</code></pre>
<p>We can return <code>None</code> on <code>is_empty</code> because we are upholding the invariant. If the queue is not empty we <code>take</code> the value at <code>self.start</code> from storage, i.e. the first value is removed from storage and passed to us. We then increment <code>self.start</code> to point to the new first item of the queue, again using the <code>wrapping_add</code> to get the ringbuffer behavior.</p>
<h3><a class="header" href="#implementing-drop" id="implementing-drop">Implementing Drop</a></h3>
<p>In order to make the usage more ergonomic and to avoid synchronization errors (where the storage map diverges from the bounds) we also implement the <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code> trait</a>:</p>
<pre><code class="language-rust ignore">impl&lt;Item, B, M, Index&gt; Drop for RingBufferTransient&lt;Item, B, M, Index&gt;
where // ... same where clause elided
{
	fn drop(&amp;mut self) {
		&lt;Self as RingBufferTrait&lt;Item&gt;&gt;::commit(self);
	}
}
</code></pre>
<p>On <code>drop</code>, we <code>commit</code> the bounds to storage. With this implementation of <code>Drop</code>, <code>commit</code> is called when our transient goes out of scope, making sure that the storage state is consistent for the next call to the using pallet.</p>
<h2><a class="header" href="#typical-usage-a-name--usagea" id="typical-usage-a-name--usagea">Typical Usage <a name = "usage"></a></a></h2>
<p>The <a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/ringbuffer-queue/src/lib.rs"><code>lib.rs</code></a> file of the pallet shows typical usage of the transient.</p>
<pre><code class="language-rust ignore">impl&lt;T: Trait&gt; Module&lt;T&gt; {
	fn queue_transient() -&gt; Box&lt;dyn RingBufferTrait&lt;ValueStruct&gt;&gt; {
		Box::new(RingBufferTransient::&lt;
			ValueStruct,
			&lt;Self as Store&gt;::BufferRange,
			&lt;Self as Store&gt;::BufferMap,
			BufferIndex,
		&gt;::new())
	}
}
</code></pre>
<p>First we define a constructor function (<code>queue_transient</code>) so we don't have to specify the types every time we want to access the transient. This function constructs a ringbuffer transient and returns it as a boxed trait object.
See the Rust book's section on <a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html#trait-objects-perform-dynamic-dispatch">trait objects</a> for an explanation of why we need a boxed trait object (defined with the syntax <code>dyn TraitName</code>) when using dynamic dispatch.</p>
<p>The <code>add_multiple</code> function shows the actual typical usage of our transient:</p>
<pre><code class="language-rust ignore">pub fn add_multiple(origin, integers: Vec&lt;i32&gt;, boolean: bool) -&gt; DispatchResult {
	let _user = ensure_signed(origin)?;
	let mut queue = Self::queue_transient();
	for integer in integers {
		queue.push(ValueStruct{ integer, boolean });
	}
	Ok(())
} // commit happens on drop
</code></pre>
<p>Here we use the <code>queue_transient</code> function defined above to get a <code>queue</code> object. We then <code>push</code> into it repeatedly with <code>commit</code> happening on <code>drop</code> of the <code>queue</code> object at the end of the function.
<code>pop</code> works analogously and can of course be intermixed with <code>push</code>es.</p>
<h1><a class="header" href="#basic-token" id="basic-token">Basic Token</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/basic-token"><code>pallets/basic-token</code></a></em></p>
<p>This recipe demonstrates a simple but functional token in a pallet.</p>
<h2><a class="header" href="#mapping-accounts-to-balances" id="mapping-accounts-to-balances">Mapping Accounts to Balances</a></h2>
<p>Mappings are a very powerful primitive. A <em>stateful</em> cryptocurrency might store a mapping between accounts and balances. Likewise, mappings prove useful when representing <em>owned</em> data. By tracking ownership with maps, it is easy manage permissions for modifying values specific to individual users or groups.</p>
<h2><a class="header" href="#storage-items" id="storage-items">Storage Items</a></h2>
<p>The primary storage item is the mapping between AccountIds and Balances described above. Every account that holds tokens appears as a key in that map and its value is the number of tokens it holds.</p>
<p>The next two storage items set the total supply of the token and keep track of whether the token has been initialized yet.</p>
<pre><code class="language-rust ignore">decl_storage! {
	trait Store for Module&lt;T: Trait&gt; as Token {
		pub Balances get(get_balance): map hasher(blake2_128_concat) T::AccountId =&gt; u64;

		pub TotalSupply get(total_supply): u64 = 21000000;

		Init get(is_init): bool;
	}
}
</code></pre>
<p>Because users can influence the keys in our storage map, we've chosen the <code>blake2_128_concat</code> hasher as described in the recipe on <a href="3-entrees/storage-api/storage-maps.html">storage maps</a>s.</p>
<h2><a class="header" href="#events-and-errors" id="events-and-errors">Events and Errors</a></h2>
<p>The pallet defines events and errors for common lifecycle events such as successful and failed transfers, and successful and failed initialization.</p>
<pre><code class="language-rust ignore">decl_event!(
	pub enum Event&lt;T&gt;
	where
		AccountId = &lt;T as system::Trait&gt;::AccountId,
	{
		/// Token was initialized by user
		Initialized(AccountId),
		/// Tokens successfully transferred between users
		Transfer(AccountId, AccountId, u64), // (from, to, value)
	}
);

decl_error! {
	pub enum Error for Module&lt;T: Trait&gt; {
		/// Attempted to initialize the token after it had already been initialized.
		AlreadyInitialized,
		/// Attempted to transfer more funds than were available
		InsufficientFunds,
	}
}
</code></pre>
<h2><a class="header" href="#initializing-the-token" id="initializing-the-token">Initializing the Token</a></h2>
<p>In order for the token to be useful, some accounts need to own it. There are many possible ways to initialize a token including genesis config, claims process, lockdrop, and many more. This pallet will use a simple process where the first user to call the <code>init</code> function receives all of the funds. The total supply is hard-coded in the pallet in a fairly naive way: It is specified as the default value in the <code>decl_storage!</code> block.</p>
<pre><code class="language-rustignore">fn init(origin) -&gt; DispatchResult {
	let sender = ensure_signed(origin)?;
	ensure!(!Self::is_init(), &lt;Error&lt;T&gt;&gt;::AlreadyInitialized);

	&lt;Balances&lt;T&gt;&gt;::insert(sender, Self::total_supply());

	Init::put(true);
	Ok(())
}
</code></pre>
<p>As usual, we first check for preconditions. In this case that means making sure that the token is not already initialized. Then we do any mutation necessary.</p>
<h2><a class="header" href="#transferring-tokens" id="transferring-tokens">Transferring Tokens</a></h2>
<p>To transfer tokens, a user who owns some tokens calls the <code>transfer</code> method specifying the recipient and the amount of tokens to transfer as parameters.</p>
<p>We again check for error conditions before mutating storage. In this case it is <em>not</em> necessary to check whether the token has been initialized. If it has not, nobody has any funds and the transfer will simply fail with <code>InsufficientFunds</code>.</p>
<pre><code class="language-rust ignore">fn transfer(_origin, to: T::AccountId, value: u64) -&gt; DispatchResult {
	let sender = ensure_signed(_origin)?;
	let sender_balance = Self::get_balance(&amp;sender);
	let receiver_balance = Self::get_balance(&amp;to);

	// Calculate new balances
	let updated_from_balance = sender_balance.checked_sub(value).ok_or(&lt;Error&lt;T&gt;&gt;::InsufficientFunds)?;
	let updated_to_balance = receiver_balance.checked_add(value).expect(&quot;Entire supply fits in u64; qed&quot;);

	// Write new balances to storage
	&lt;Balances&lt;T&gt;&gt;::insert(&amp;sender, updated_from_balance);
	&lt;Balances&lt;T&gt;&gt;::insert(&amp;to, updated_to_balance);

	Self::deposit_event(RawEvent::Transfer(sender, to, value));
	Ok(())
}
</code></pre>
<h2><a class="header" href="#dont-panic" id="dont-panic">Don't Panic!</a></h2>
<p>When adding the incoming balance, notice the peculiar <code>.expect</code> method. In a Substrate runtime, <strong>you must never panic</strong>. To encourage careful thinking about your code, you use the <code>.expect</code> method and provide a proof of why the potential panic will never happen.</p>
<h1><a class="header" href="#configurable-pallet-constants" id="configurable-pallet-constants">Configurable Pallet Constants</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/constant-config"><code>pallets/constant-config</code></a></em></p>
<p>To declare constant values within a runtime, it is necessary to import the <a href="https://substrate.dev/rustdocs/master/frame_support/traits/trait.Get.html"><code>Get</code></a> trait from <code>frame_support</code></p>
<pre><code class="language-rust ignore">use frame_support::traits::Get;
</code></pre>
<p>Configurable constants are declared as associated types in the pallet's configuration trait using the <code>Get&lt;T&gt;</code> syntax for any type <code>T</code>.</p>
<pre><code class="language-rust ignore">pub trait Trait: system::Trait {
	type Event: From&lt;Event&gt; + Into&lt;&lt;Self as system::Trait&gt;::Event&gt;;

	/// Maximum amount added per invocation
	type MaxAddend: Get&lt;u32&gt;;

	/// Frequency with which the stored value is deleted
	type ClearFrequency: Get&lt;Self::BlockNumber&gt;;
}
</code></pre>
<p>In order to make these constants and their values appear in the runtime metadata, it is necessary to declare them with the <code>const</code> syntax in the <code>decl_module!</code> block. Usually constants are declared at the top of this block, right after <code>fn deposit_event</code>.</p>
<pre><code class="language-rust ignore">decl_module! {
	pub struct Module&lt;T: Trait&gt; for enum Call where origin: T::Origin {
		fn deposit_event() = default;

		const MaxAddend: u32 = T::MaxAddend::get();

		const ClearFrequency: T::BlockNumber = T::ClearFrequency::get();

		// --snip--
	}
}
</code></pre>
<p>This example manipulates a single value in storage declared as <code>SingleValue</code>.</p>
<pre><code class="language-rust ignore">decl_storage! {
	trait Store for Module&lt;T: Trait&gt; as Example {
		SingleValue get(fn single_value): u32;
	}
}
</code></pre>
<p><code>SingleValue</code> is set to <code>0</code> every <code>ClearFrequency</code> number of blocks in the <code>on_finalize</code> function that runs at the end of blocks execution.</p>
<pre><code class="language-rust ignore">fn on_finalize(n: T::BlockNumber) {
	if (n % T::ClearFrequency::get()).is_zero() {
		let c_val = &lt;SingleValue&gt;::get();
		&lt;SingleValue&gt;::put(0u32);
		Self::deposit_event(Event::Cleared(c_val));
	}
}
</code></pre>
<p>Signed transactions may invoke the <code>add_value</code> runtime method to increase <code>SingleValue</code> as long as each call adds less than <code>MaxAddend</code>. <em>There is no anti-sybil mechanism so a user could just split a larger request into multiple smaller requests to overcome the <code>MaxAddend</code></em>, but overflow is still handled appropriately.</p>
<pre><code class="language-rust ignore">fn add_value(origin, val_to_add: u32) -&gt; DispatchResult {
	let _ = ensure_signed(origin)?;
	ensure!(val_to_add &lt;= T::MaxAddend::get(), &quot;value must be &lt;= maximum add amount constant&quot;);

	// previous value got
	let c_val = &lt;SingleValue&gt;::get();

	// checks for overflow when new value added
	let result = match c_val.checked_add(val_to_add) {
		Some(r) =&gt; r,
		None =&gt; return Err(DispatchError::Other(&quot;Addition overflowed&quot;)),
	};
	&lt;SingleValue&gt;::put(result);
	Self::deposit_event(Event::Added(c_val, val_to_add, result));
	Ok(())
}
</code></pre>
<p>In more complex patterns, the constant value may be used as a static, base value that is scaled by a multiplier to incorporate stateful context for calculating some dynamic fee (ie floating transaction fees).</p>
<p>To test the range of pallet configurations introduced by configurable constants, see <em><a href="3-entrees/./testing/externalities.html">custom configuration of externalities</a></em></p>
<h2><a class="header" href="#supplying-the-constant-value" id="supplying-the-constant-value">Supplying the Constant Value</a></h2>
<p>When the pallet is included in a runtime, the runtime developer supplies the value of the constant using the <a href="https://substrate.dev/rustdocs/master/frame_support/macro.parameter_types.html"><code>parameter_types!</code> macro</a>. This pallet is included in the <code>super-runtime</code> where we see the following macro invocation and trat implementation.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>parameter_types! {
	pub const MaxAddend: u32 = 1738;
	pub const ClearFrequency: u32 = 10;
}

impl constant_config::Trait for Runtime {
	type Event = Event;
	type MaxAddend = MaxAddend;
	type ClearFrequency = ClearFrequency;
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#instantiable-pallets" id="instantiable-pallets">Instantiable Pallets</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/last-caller"><code>pallets/last-caller</code></a></em> <em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/default-instance"><code>pallets/default-instance</code></a></em></p>
<p>Instantiable pallets enable multiple instances of the same pallet logic within a single runtime. Each instance of the pallet has its own independent storage, and extrinsics must specify which instance of the pallet they are intended for. These patterns are illustrated in the kitchen in the last-caller and default-instance pallets.</p>
<p>Some use cases:</p>
<ul>
<li>Token chain hosts two independent cryptocurrencies.</li>
<li>Marketplace track users' reputations as buyers separately from their reputations as sellers.</li>
<li>Governance has two (or more) houses which act similarly internally.</li>
</ul>
<p>Substrate's own Balances and Collective pallets are good examples of real-world code using this technique. The default Substrate node has two instances of the Collectives pallet that make up its Council and Technical Committee. Each collective has its own storage, events, and configuration.</p>
<pre><code class="language-rust ignore">Council: collective::&lt;Instance1&gt;::{Module, Call, Storage, Origin&lt;T&gt;, Event&lt;T&gt;, Config&lt;T&gt;},
TechnicalCommittee: collective::&lt;Instance2&gt;::{Module, Call, Storage, Origin&lt;T&gt;, Event&lt;T&gt;, Config&lt;T&gt;}
</code></pre>
<h2><a class="header" href="#writing-an-instantiable-pallet" id="writing-an-instantiable-pallet">Writing an Instantiable Pallet</a></h2>
<p>Writing an instantiable pallet is almost entirely the same process as writing a plain non-instantiable pallet. There are just a few places where the syntax differs.</p>
<blockquote>
<p>You must call <code>decl_storage!</code></p>
<p>Instantiable pallets <em>must</em> call the <code>decl_storage!</code> macro so that the <code>Instance</code> type is created.</p>
</blockquote>
<h3><a class="header" href="#configuration-trait-1" id="configuration-trait-1">Configuration Trait</a></h3>
<pre><code class="language-rust ignore">pub trait Trait&lt;I: Instance&gt;: system::Trait {
	/// The overarching event type.
	type Event: From&lt;Event&lt;Self, I&gt;&gt; + Into&lt;&lt;Self as system::Trait&gt;::Event&gt;;
}
</code></pre>
<h3><a class="header" href="#storage-declaration" id="storage-declaration">Storage Declaration</a></h3>
<pre><code class="language-rust ignore">decl_storage! {
	trait Store for Module&lt;T: Trait&lt;I&gt;, I: Instance&gt; as TemplatePallet {
		...
	}
}
</code></pre>
<h3><a class="header" href="#declaring-the-module-struct" id="declaring-the-module-struct">Declaring the <code>Module</code> Struct</a></h3>
<pre><code class="language-rust ignore">decl_module! {
	/// The module declaration.
	pub struct Module&lt;T: Trait&lt;I&gt;, I: Instance&gt; for enum Call where origin: T::Origin {
		...
	}
}
</code></pre>
<h3><a class="header" href="#accessing-storage" id="accessing-storage">Accessing Storage</a></h3>
<pre><code class="language-rust ignore">&lt;Something&lt;T, I&gt;&gt;::put(something);
</code></pre>
<p>If the storage item does not use any types specified in the configuration trait, the T is omitted, as always.</p>
<pre><code class="language-rust ignore">&lt;Something&lt;I&gt;&gt;::put(something);
</code></pre>
<h3><a class="header" href="#event-initialization" id="event-initialization">Event initialization</a></h3>
<pre><code class="language-rust ignore">fn deposit_event() = default;
</code></pre>
<h3><a class="header" href="#event-declaration" id="event-declaration">Event Declaration</a></h3>
<pre><code class="language-rust ignore">decl_event!(
	pub enum Event&lt;T, I&gt; where AccountId = &lt;T as system::Trait&gt;::AccountId {
		...
	}
}
</code></pre>
<h2><a class="header" href="#installing-a-pallet-instance-in-a-runtime" id="installing-a-pallet-instance-in-a-runtime">Installing a Pallet Instance in a Runtime</a></h2>
<p>The syntax for including an instance of an instantiable pallet in a runtime is slightly different than for a regular pallet. The only exception is for pallets that use the <a href="3-entrees/instantiable.html#default-instance">Default Instance</a> feature described below.</p>
<h3><a class="header" href="#implementing-configuration-traits" id="implementing-configuration-traits">Implementing Configuration Traits</a></h3>
<p>Each instance needs to be configured separately. Configuration consists of implementing the specific instance's trait. The following snippet shows a configuration for <code>Instance1</code>.</p>
<pre><code class="language-rust ignore">impl template::Trait&lt;template::Instance1&gt; for Runtime {
	type Event = Event;
}
</code></pre>
<h3><a class="header" href="#using-the-construct_runtime-macro" id="using-the-construct_runtime-macro">Using the <code>construct_runtime!</code> Macro</a></h3>
<p>The final step of installing the pallet instance in your runtime is updating the <code>construct_runtime!</code> macro. You may give each instance a meaningful name. Here I've called <code>Instance1</code> <code>FirstTemplate</code>.</p>
<pre><code class="language-rust ignore">FirstTemplate: template::&lt;Instance1&gt;::{Module, Call, Storage, Event&lt;T&gt;, Config},
</code></pre>
<h2><a class="header" href="#default-instance-a-namedefault-instancea" id="default-instance-a-namedefault-instancea">Default Instance <a name="default-instance"></a></a></h2>
<p>One drawback of instantiable pallets, as we've presented them so far, is that they require the runtime designer to use the more elaborate syntax even if they only desire a single instance of the pallet. To alleviate this inconvenience, Substrate provides a feature known as DefaultInstance. This allows runtime developers to deploy an instantiable pallet exactly as they would if it were not instantiable provided they <strong>only use a single instance</strong>.</p>
<p>To make your instantiable pallet support DefaultInstance, you must specify it in four places.</p>
<pre><code class="language-rust ignore">pub trait Trait&lt;I=DefaultInstance&gt;: system::Trait {
</code></pre>
<pre><code class="language-rust ignore">decl_storage! {
	trait Store for Module&lt;T: Trait&lt;I&gt;, I: Instance=DefaultInstance&gt; as TemplateModule {
		...
	}
}
</code></pre>
<pre><code class="language-rust ignore">decl_module! {
	pub struct Module&lt;T: Trait&lt;I&gt;, I: Instance = DefaultInstance&gt; for enum Call where origin: T::Origin {
		...
	}
}
</code></pre>
<pre><code class="language-rust ignore">decl_event!(
	pub enum Event&lt;T, I=DefaultInstance&gt; where ... {
		...
	}
}
</code></pre>
<p>Having made these changes, a developer who uses your pallet doesn't need to know or care that your pallet is instantable. They can deploy it just as they would any other pallet.</p>
<h2><a class="header" href="#genesis-configuration" id="genesis-configuration">Genesis Configuration</a></h2>
<p>Some pallets require a genesis configuration to be specified. Let's look to the default Substrate node's use of the Collective pallet as an example.</p>
<p>In its <code>chain_spec.rs</code> file we see</p>
<pre><code class="language-rust ignore">GenesisConfig {
	...
	collective_Instance1: Some(CouncilConfig {
		members: vec![],
		phantom: Default::default(),
	}),
	collective_Instance2: Some(TechnicalCommitteeConfig {
		members: vec![],
		phantom: Default::default(),
	}),
	...
}
</code></pre>
<h1><a class="header" href="#computational-resources-and-weights" id="computational-resources-and-weights">Computational Resources and Weights</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/weights"><code>pallets/weights</code></a></em></p>
<p>Any computational resources used by a transaction must be accounted for so that appropriate fees can be applied, and it is a pallet author's job to ensure that this accounting happens. Substrate provides a mechanism known as transaction weighting to quantify the resources consumed while executing a transaction.</p>
<p><em>Indeed, mispriced EVM operations have shown how operations that underestimate cost can open economic DOS attack vectors: <a href="https://www.parity.io/onwards/">Onwards; Underpriced EVM Operations</a>, <a href="https://www4.comp.polyu.edu.hk/%7Ecsxluo/DoSEVM.pdf">Under-Priced DOS Attacks on Ethereum</a></em></p>
<h2><a class="header" href="#assigning-transaction-weights" id="assigning-transaction-weights">Assigning Transaction Weights</a></h2>
<p>Pallet authors can annotate their dispatchable function with a weight using syntax like this,</p>
<pre><code class="language-rust ignore">#[weight = &lt;Some Weighting Instance&gt;]
fn some_call(...) -&gt; Result {
	// --snip--
}
</code></pre>
<p>For simple transactions a fixed weight will do. Substrate provides the <a href="https://substrate.dev/rustdocs/master/frame_support/weights/enum.SimpleDispatchInfo.html"><code>SimpleDispatchInfo</code> enum</a> for situations like this.</p>
<pre><code class="language-rust ignore">decl_module! {
	pub struct Module&lt;T: Trait&gt; for enum Call {

		#[weight = SimpleDispatchInfo::FixedNormal(100)]
		fn store_value(_origin, entry: u32) -&gt; Result {
			// --snip--
		}
</code></pre>
<p>For more complex transactions, custom weight calculations can be performed that consider the parameters passed to the call. This snippet shows a weighting struct that weighs transactions where the first parameter
is a <code>boo</code>l. If the first parameter is <code>true</code>, then the weight is linear in the second parameter. Otherwise the weight is constant. A transaction where this weighting scheme makes sense is demonstrated in the kitchen.</p>
<pre><code class="language-rust ignore">pub struct Conditional(u32);

impl WeighData&lt;(&amp;bool, &amp;u32)&gt; for Conditional {
	fn weigh_data(&amp;self, (switch, val): (&amp;bool, &amp;u32)) -&gt; Weight {

		if *switch {
			val.saturating_mul(self.0)
		}
		else {
			self.0
		}
	}
}
</code></pre>
<p>In addition to the <a href="https://substrate.dev/rustdocs/master/frame_support/weights/trait.WeighData.html"><code>WeightData</code>
Trait</a>, shown
above, types that are used to calculate transaction weights, must also implement
<a href="https://substrate.dev/rustdocs/master/frame_support/weights/trait.ClassifyDispatch.html"><code>ClassifyDispatch</code></a>,
and <a href="https://substrate.dev/rustdocs/master/frame_support/weights/trait.PaysFee.html"><code>PaysFee</code></a>.</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; ClassifyDispatch&lt;T&gt; for Conditional {
    fn classify_dispatch(&amp;self, _: T) -&gt; DispatchClass {
        // Classify all calls as Normal (which is the default)
        Default::default()
    }
}
</code></pre>
<pre><code class="language-rust ignore">impl PaysFee for Conditional {
    fn pays_fee(&amp;self) -&gt; bool {
        true
    }
}
</code></pre>
<p>The complete code for this example as well as several others can be found in the kitchen.</p>
<h2><a class="header" href="#cautions" id="cautions">Cautions</a></h2>
<p>While you can make reasonable estimates of resource consumption at
design time, it is always best to actually measure the resources
required of your functions through an empirical process. Failure to
perform such rigorous measurement may result in an economically
insecure chain.</p>
<p>While it isn't enforced, calculating a transaction's weight should itself be a cheap operation. If the weight calculation itself is expensive, your chain will be insecure.</p>
<h2><a class="header" href="#what-about-fees" id="what-about-fees">What About Fees?</a></h2>
<p>Weights are used only to describe the computational resources consumed by a transaction, and enable accounting of these resources. To learn how to turn these weights into actual fees charged to transactors, continue to the recipe on <a href="3-entrees/./fees.html">Fees</a>.</p>
<h1><a class="header" href="#transaction-fees" id="transaction-fees">Transaction Fees</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/runtimes/weight-fee-runtime">runtimes/weight-fee-runtime</a></em></p>
<p>Substrate provides the <a href="https://substrate.dev/rustdocs/master/pallet_transaction_payment/index.html"><code>transaction_payment</code> pallet</a> for calculating and collecting fees for executing transactions. Fees are broken down into several components:</p>
<ul>
<li>Base fee - A fixed fee applied to each transaction. A parameter in the <code>transaction_payment</code> pallet.</li>
<li>Length fee - A fee proportional to the transaction's length in bytes. The proportionality constant is a parameter in the <code>transaction_payment</code> pallet.</li>
<li>Weight fee - A fee calculated from the transaction's weight. Weights are intended to capture the actual resources consumed by the transaction. Learn more in the <a href="3-entrees/./weights.html">recipe on weights</a>. It doesn't need to be linear, although it often is. The same conversion function is applied across all transactions from all pallets in the runtime.</li>
<li>Fee Multiplier - A multiplier for the computed fee, that can change as the chain progresses. This topic is not (yet) covered further in the recipes.</li>
</ul>
<pre><code>total_fee = base_fee + transaction_length * length_fee + weight_to_fee(total_weight)
</code></pre>
<h2><a class="header" href="#setting-the-constants" id="setting-the-constants">Setting the Constants</a></h2>
<p>Each of the parameters described above is set in the <code>transaction_payment</code> pallet's configuration trait. For example, the <code>super-runtime</code> sets these parameters as follows.</p>
<p>src: <a href="https://github.com/substrate-developer-hub/recipes/tree/master/runtimes/super-runtime/src/lib.rs"><code>runtimes/super-runtime/src/lib.rs</code></a></p>
<pre><code class="language-rust ignore">parameter_types! {
	pub const TransactionBaseFee: u128 = 0;
	pub const TransactionByteFee: u128 = 1;
}

impl transaction_payment::Trait for Runtime {
	type Currency = balances::Module&lt;Runtime&gt;;
	type OnTransactionPayment = ();
	type TransactionBaseFee = TransactionBaseFee;
	type TransactionByteFee = TransactionByteFee;
	type WeightToFee = ConvertInto;
	type FeeMultiplierUpdate = ();
}
</code></pre>
<h2><a class="header" href="#converting-weight-to-fees" id="converting-weight-to-fees">Converting Weight To Fees</a></h2>
<p>In many cases converting weight to fees in a one-to-one fashion, as shown above, will suffice and can be accomplished with <a href="https://substrate.dev/rustdocs/master/sp_runtime/traits/struct.ConvertInto.html"><code>ConvertInto</code></a>. This approach is also taken in the <a href="https://github.com/substrate-developer-hub/substrate-node-template/blob/43ee95347b6626580b1d9d554c3c8b77dc85bc01/runtime/src/lib.rs#L230">node template</a>. It is also possible to provide a type that makes a more complex calculation. Any type that implements <code>Convert&lt;Weight, Balance&gt;</code> will suffice.</p>
<p>This example uses a quadratic conversion and supports custom coefficients.</p>
<p>src: <a href="https://github.com/substrate-developer-hub/recipes/tree/master/runtimes/weight-fee-runtime/src/lib.rs"><code>runtimes/weight-fee-runtime/src/lib.rs</code></a></p>
<pre><code class="language-rust ignore">pub struct QuadraticWeightToFee&lt;C0, C1, C2&gt;(C0, C1, C2);

impl&lt;C0, C1, C2&gt; Convert&lt;Weight, Balance&gt; for QuadraticWeightToFee&lt;C0, C1, C2&gt;
	where C0: Get&lt;Balance&gt;, C1: Get&lt;Balance&gt;, C2: Get&lt;Balance&gt; {

	fn convert(w: Weight) -&gt; Balance {
		let c0 = C0::get();
		let c1 = C1::get();
		let c2 = C2::get();
		let w = Balance::from(w);

		// TODO use safe math
		c0 + c1 * w + c2 * w * w
	}
}
</code></pre>
<h2><a class="header" href="#collecting-fees" id="collecting-fees">Collecting Fees</a></h2>
<p>Having calculated the amount of fees due, runtime authors must decide which asset the fees should be paid in. A common choice is the use the <a href="https://substrate.dev/rustdocs/master/pallet_balances/index.html"><code>Ballances</code> pallet</a>, but any type that implements the <a href="https://substrate.dev/rustdocs/master/frame_support/traits/trait.Currency.html"><code>Currency</code> trait</a> can be used. The weight-fee-runtime demonstrates how to use an asset provided by the <a href="https://substrate.dev/rustdocs/master/pallet_generic_asset/index.html"><code>Generic Asset</code> pallet</a>.</p>
<p>src: <a href="https://github.com/substrate-developer-hub/recipes/tree/master/runtimes/weight-fee-runtime/src/lib.rs"><code>runtimes/weight-fee-runtime/src/lib.rs</code></a></p>
<pre><code class="language-rust ignore">impl transaction_payment::Trait for Runtime {

	// A generic asset whose ID is stored in the generic_asset pallet's runtime storage
	type Currency = SpendingAssetCurrency&lt;Self&gt;;

	// --snip--
}
</code></pre>
<h1><a class="header" href="#charity" id="charity">Charity</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/charity"><code>pallets/charity</code></a></em></p>
<p>The Charity pallet represents a simple charitable organization that collects funds into a pot that it controls, and allocates those funds to the appropriate causes. It demonstrates two useful concepts in Substrate development:</p>
<ul>
<li>A pallet-controlled shared pot of funds</li>
<li>Absorbing imbalances from the runtime</li>
</ul>
<h2><a class="header" href="#instantiate-a-pot" id="instantiate-a-pot">Instantiate a Pot</a></h2>
<p>Our charity needs an account to hold its funds. Unlike other accounts, it will not be controlled by a user's cryptographic key pair, but directly by the pallet. To instantiate such a pool of funds, import <a href="https://substrate.dev/rustdocs/master/sp_runtime/struct.ModuleId.html"><code>ModuleId</code></a> and <a href="https://substrate.dev/rustdocs/master/sp_runtime/traits/trait.AccountIdConversion.html"><code>AccountIdConversion</code></a> from <a href="https://substrate.dev/rustdocs/master/sp_runtime/index.html"><code>sp-runtime</code></a>.</p>
<pre><code class="language-rust ignore">use sp-runtime::{ModuleId, traits::AccountIdConversion};
</code></pre>
<p>With these imports, a <code>PALLET_ID</code> constant can be generated as an identifier for the pool of funds. The <code>PALLET_ID</code> must be exactly eight characters long which is why we've included the exclamation point. (Well, that and Charity work is just so exciting!) This identifier can be converted into an <code>AccountId</code> with the <code>into_account()</code> method provided by the <code>AccountIdConversion</code> trait.</p>
<pre><code class="language-rust ignore">const PALLET_ID: ModuleId = ModuleId(*b&quot;Charity!&quot;);

impl&lt;T: Trait&gt; Module&lt;T&gt; {
	/// The account ID that holds the Charity's funds
	pub fn account_id() -&gt; T::AccountId {
		PALLET_ID.into_account()
	}

	/// The Charity's balance
	fn pot() -&gt; BalanceOf&lt;T&gt; {
		T::Currency::free_balance(&amp;Self::account_id())
	}
}
</code></pre>
<h1><a class="header" href="#receiving-funds" id="receiving-funds">Receiving Funds</a></h1>
<p>Our charity can receive funds in two different ways.</p>
<h2><a class="header" href="#donations" id="donations">Donations</a></h2>
<p>The first and perhaps more familiar way is through charitable donations. Donations can be made through a standard <code>donate</code> extrinsic which accepts the amount to be donated as a parameter.</p>
<pre><code class="language-rust ignore">fn donate(
		origin,
		amount: BalanceOf&lt;T&gt;
) -&gt; DispatchResult {
		let donor = ensure_signed(origin)?;

		let _ = T::Currency::transfer(&amp;donor, &amp;Self::account_id(), amount, AllowDeath);

		Self::deposit_event(RawEvent::DonationReceived(donor, amount, Self::pot()));
		Ok(())
}
</code></pre>
<h2><a class="header" href="#imbalances" id="imbalances">Imbalances</a></h2>
<p>The second way the charity can receive funds is by absorbing imbalances created elsewhere in the runtime. An <a href="https://substrate.dev/rustdocs/master/frame_support/traits/trait.Imbalance.html"><code>Imbalance</code></a> is created whenever tokens are burned, or minted. Because our charity wants to <em>collect</em> funds, we are specifically interested in <a href="https://substrate.dev/rustdocs/master/pallet_balances/struct.NegativeImbalance.html"><code>NegativeImbalance</code></a>s. Negative imbalances are created, for example, when a validator is slashed for violating consensus rules, transaction fees are collected, or another pallet burns funds as part of an incentive-alignment mechanism. To allow our pallet to absorb these imbalances, we implement the <a href="https://substrate.dev/rustdocs/master/frame_support/traits/trait.OnUnbalanced.html"><code>OnUnbalanced</code> trait</a>.</p>
<pre><code class="language-rust ignore">use frame_support::traits::{OnUnbalanced, Imbalance};
type NegativeImbalanceOf&lt;T&gt; = &lt;&lt;T as Trait&gt;::Currency as Currency&lt;&lt;T as system::Trait&gt;::AccountId&gt;&gt;::NegativeImbalance;

impl&lt;T: Trait&gt; OnUnbalanced&lt;NegativeImbalanceOf&lt;T&gt;&gt; for Module&lt;T&gt; {
	fn on_nonzero_unbalanced(amount: NegativeImbalanceOf&lt;T&gt;) {
		let numeric_amount = amount.peek();

		// Must resolve into existing but better to be safe.
		let _ = T::Currency::resolve_creating(&amp;Self::account_id(), amount);

		Self::deposit_event(RawEvent::ImbalanceAbsorbed(numeric_amount, Self::pot()));
	}
}
</code></pre>
<h1><a class="header" href="#allocating-funds" id="allocating-funds">Allocating Funds</a></h1>
<p>In order for the charity to affect change with the funds it has collected it must be able to allocate those funds. Our charity pallet abstracts the governance of where funds will be allocated to the rest of the runtime. Funds can be allocated by a root call to the <code>allocate</code> extrinsic. One good example of a governance mechanism for such decisions is Substrate's own <a href="https://substrate.dev/rustdocs/master/pallet_democracy/index.html">Democracy pallet</a>.</p>
<h1><a class="header" href="#fixed-point-arithmetic" id="fixed-point-arithmetic">Fixed Point Arithmetic</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/fixed-point"><code>pallets/fixed-point</code></a></em> <em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/compounding-interest"><code>pallets/compounding-interest</code></a></em></p>
<p>When programmers learn to use non-integer numbers in their programs, they are usually taught to use <a href="https://en.wikipedia.org/wiki/Floating-point_arithmetic">floating point</a>s. In blockchain, we use an alternative representation of fractional numbers called <a href="https://en.wikipedia.org/wiki/Fixed-point_arithmetic">fixed point</a>. There are several ways to use fixed point numbers, and this recipe will introduce three of them. In particular we'll see:</p>
<ul>
<li>Substrate's own fixed point structs and traits</li>
<li>The <a href="https://github.com/encointer/substrate-fixed/">substrate-fixed</a> library</li>
<li>A manual fixed point implementation (and why it's nicer to use a library)</li>
<li>A comparison of the two libraries in a compounding interest example</li>
</ul>
<h2><a class="header" href="#whats-wrong-with-floats" id="whats-wrong-with-floats">What's Wrong with Floats?</a></h2>
<p>Floats are cool for all kinds of reasons, but they also have one important drawback. Floating point arithmetic is <strong>nondeterministic</strong> which means that different processors compute (slightly) different results for the same operation. Although there is an <a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE spec</a>, nondeterminism can come from specific libraries used, or even hardware. In order for the nodes in a blockchain network to reach agreement on the state of the chain, all operations must be completely deterministic. Luckily fixed point arithmetic is deterministic, and is often not much harder to use once you get the hang of it.</p>
<h2><a class="header" href="#multiplicative-accumulators" id="multiplicative-accumulators">Multiplicative Accumulators</a></h2>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/fixed-point"><code>pallets/fixed-point</code></a></em></p>
<p>The first pallet covered in this recipe contains three implementations of a multiplicative accumulator. That's a fancy way to say the pallet lets users submit fractional numbers and keeps track of the product from multiplying them all together. The value starts out at one (the <a href="https://en.wikipedia.org/wiki/Identity_element">multiplicative identity</a>), and it gets multiplied by whatever values the users submit. These three independent implementations compare and contrast the features of each.</p>
<h3><a class="header" href="#permill-accumulator" id="permill-accumulator">Permill Accumulator</a></h3>
<p>We'll using the most common approach which takes its fixed point implementation from Substrate itself. There are a few fixed-point structs available in Substrate, all of which implement the <a href="https://substrate.dev/rustdocs/master/sp_arithmetic/trait.PerThing.html"><code>PerThing</code> trait</a>, that cover different amounts of precision. For this accumulator example, we'll use the <a href="https://substrate.dev/rustdocs/master/sp_arithmetic/struct.Permill.html"><code>PerMill</code> struct</a> which represents fractions as parts per million. There are also <a href="https://substrate.dev/rustdocs/master/sp_arithmetic/struct.Perbill.html"><code>Perbill</code></a>, <a href="https://substrate.dev/rustdocs/master/sp_arithmetic/struct.Percent.html"><code>PerCent</code></a>, and <a href="https://substrate.dev/rustdocs/master/sp_arithmetic/struct.PerU16.html"><code>PerU16</code></a>, which all provide the same interface (because it comes from the trait). Substrate's fixed-point structs are somewhat unique because they represent <em>only</em> fractional parts of numbers. That means they can represent numbers between 0 and 1 inclusive, but <em>not</em> numbers with whole parts like 2.718 or 3.14.</p>
<p>To begin we declare the storage item that will hold our accumulated product. You can see that the trait provides a handy function for getting the identity value which we use to set the default storage value to <code>1</code>.</p>
<pre><code class="language-rust ignore">decl_storage! {
	trait Store for Module&lt;T: Trait&gt; as Example {
		// --snip--

		/// Permill accumulator, value starts at 1 (multiplicative identity)
		PermillAccumulator get(fn permill_value): Permill = Permill::one();
	}
}
</code></pre>
<p>The only extrinsic for this Permill accumulator is the one that allows users to submit new <code>Permill</code> values to get multiplied into the accumulator.</p>
<pre><code class="language-rust ignore">fn update_permill(origin, new_factor: Permill) -&gt; DispatchResult {
	ensure_signed(origin)?;

	let old_accumulated = Self::permill_value();

	// There is no need to check for overflow here. Permill holds values in the range
	// [0, 1] so it is impossible to ever overflow.
	let new_product = old_accumulated.saturating_mul(new_factor);

	// Write the new value to storage
	PermillAccumulator::put(new_product);

	// Emit event
	Self::deposit_event(Event::PermillUpdated(new_factor, new_product));
	Ok(())
}
</code></pre>
<p>The code of this extrinsic largely speaks for itself. One thing to take particular note of is that we <em>don't</em> check for overflow on the multiplication. If you've read many of the recipes you know that a Substrate runtime must never panic, and a developer must be extremely diligent in always checking for and gracefully handling error conditions. Because <code>Permill</code> only holds values between 0 and 1, we know that their product will always be in that same range. Thus it is impossible to overflow or saturate. So we can happily use <code>saturating_mul</code> and move on.</p>
<h3><a class="header" href="#substrate-fixed-accumulator" id="substrate-fixed-accumulator">Substrate-fixed Accumulator</a></h3>
<p><a href="https://github.com/encointer/substrate-fixed/">Substrate-fixed</a> takes a more traditional approach in that their types represent numbers with both whole <em>and</em> fractional parts. For this implementation, we'll use the <code>U16F16</code> type. This type contains an unsigned number (indicated by the <code>U</code> at the beginning) and has 32 <em>total</em> bits of precision - 16 for the integer part, and 16 for the fractional part. There are several other types provided that follow the same naming convention. Some examples include <code>U32F32</code> and <code>I32F32</code> where the <code>I</code> indicates a signed number, just like in Rust primitive types.</p>
<p>As in the <code>Permill</code> example, we begin by declaring the storage item. With substrate-fixed, there is not a <code>one</code> function, but there is a <code>from_num</code> function that we use to set the storage item's default value. This <code>from_num</code> method and its counterpart <code>to-num</code> are your primary ways of converting between substrate-fixed types and Rust primitive types. If your use case does a lot of fixed-point arithmetic, like ours does, it is advisable to keep your data in substrate-fixed types.</p>
<blockquote>
<p>We're able to use <code>U16F16</code> as a storage item type because it, and the other substrate-fixed types, implements the parity scale codec.</p>
</blockquote>
<pre><code class="language-rust ignore">decl_storage! {
	trait Store for Module&lt;T: Trait&gt; as Example {
		// --snip--

		/// Substrate-fixed accumulator, value starts at 1 (multiplicative identity)
		FixedAccumulator get(fn fixed_value): U16F16 = U16F16::from_num(1);
	}
}
</code></pre>
<p>Next we implement the extrinsic that allows users to update the accumulator by multiplying in a new value.</p>
<pre><code class="language-rust ignore">fn update_fixed(origin, new_factor: U16F16) -&gt; DispatchResult {
	ensure_signed(origin)?;

	let old_accumulated = Self::fixed_value();

	// Multiply, handling overflow
	let new_product = old_accumulated.checked_mul(new_factor)
		.ok_or(Error::&lt;T&gt;::Overflow)?;

	// Write the new value to storage
	FixedAccumulator::put(new_product);

	// Emit event
	Self::deposit_event(Event::FixedUpdated(new_factor, new_product));
	Ok(())
}
</code></pre>
<p>This extrinsic is quite similar to the <code>Permill</code> version with one notable difference. Because <code>U16F16</code> handles numbers greater than one, overflow is possible, and we need to handle it. The error handling here is straightforward, the important part is just that you remember to do it.</p>
<p>This example has shown the fundamentals of substrate-fixed, but this library has much more to offer as we'll see in the compounding interest example.</p>
<h3><a class="header" href="#manual-accumulator" id="manual-accumulator">Manual Accumulator</a></h3>
<p>In this final accumulator implementation, we manually track fixed point numbers using Rust's native <code>u32</code> as the underlying data type. This example is educational, but is only practical in the simplest scenarios. Generally you will have a <del>more fun</del> less error-prone time coding if you use one of the previous two fixed-point types in your real-world applications.</p>
<p>Fixed point is not very complex conceptually. We represent fractional numbers as regular old integers, and we decide in advance to consider some of the place values fractional. It's just like saying we'll omit the decimal point when talking about money and all agree that &quot;1995&quot; actually <em>means</em> 19.95 ‚Ç¨. This is exactly how Substrate's <a href="https://substrate.dev/rustdocs/master/pallet_balances/index.html">Balances pallet</a> works, a tradition that's been in blockchain since Bitcon. In our example we will treat 16 bits as integer values, and 16 as fractional, just as substrate-fixed's <code>U16F16</code> did.</p>
<p>If you're rusty or unfamiliar with place values in the <a href="https://en.wikipedia.org/wiki/Binary_number">binary number system</a>, it may be useful to brush up. (Or skip this detailed section and proceed to the compounding interest example.)</p>
<pre><code>Normal interpretation of u32 place values
... ___ ___ ___ ___ ___ ___ ___ .
...  64  32  16  8   4   2   1

Fixed interpretation of u32 place values
... ___ ___ ___ ___ . ___ ___ ___ ___ ...
...  8   4   2   1    1/2 1/4 1/8 1/16...
</code></pre>
<p>Although the concepts are straight-forward, you'll see that manually implementing operations like multiplication is quite error prone. Therefore, when writing your own blockchain applications, it is often best to use on of the provided libraries covered in the other two implementations of the accumulator.</p>
<p>As before, we begin by declaring the storage value. This time around it is just a simple u32. But the default value, <code>1 &lt;&lt; 16</code> looks quite funny. If you haven't encountered it before <code>&lt;&lt;</code> is Rust's <a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#arithmetic-and-logical-binary-operators">bit shift operator</a>. It takes a value and moves all the bits to the left. In this case we start with the value <code>1</code> and move it 16 bits to the left. This is because Rust interprets <code>1</code> as a regular <code>u32</code> value and puts the <code>1</code> in the far right place value. But because we're treating this <code>u32</code> specially, we need to shift that bit to the middle just left of the imaginary radix point.</p>
<pre><code class="language-rust ignore">decl_storage! {
	trait Store for Module&lt;T: Trait&gt; as Example {
		// --snip--

		/// Manual accumulator, value starts at 1 (multiplicative identity)
		ManualAccumulator get(fn manual_value): u32 = 1 &lt;&lt; 16;
	}
}
</code></pre>
<p>The extrinsic to multiply a new factor into the accumulator follows the same general flow as in the other two implementations. In this case, there are more intermediate values calculated, and more comments explaining the bit-shifting operations. In the function body most intermediate values are held in <code>u64</code> variables. This is because when you multiply two 32-bit numbers, you can end up with as much as 64 bits in the product.</p>
<pre><code class="language-rust ignore">fn update_manual(origin, new_factor: u32) -&gt; DispatchResult {
	ensure_signed(origin)?;

	// To ensure we don't overflow unnecessarily, the values are cast up to u64 before multiplying.
	// This intermediate format has 48 integer positions and 16 fractional.
	let old_accumulated : u64 = Self::manual_value() as u64;
	let new_factor_u64 : u64 = new_factor as u64;

	// Perform the multiplication on the u64 values
	// This intermediate format has 32 integer positions and 32 fractional.
	let raw_product : u64 = old_accumulated * new_factor_u64;

	// Right shift to restore the convention that 16 bits are fractional.
	// This is a lossy conversion.
	// This intermediate format has 48 integer positions and 16 fractional.
	let shifted_product : u64 = raw_product &gt;&gt; 16;

	// Ensure that the product fits in the u32, and error if it doesn't
	if shifted_product &gt; (u32::max_value() as u64) {
		return Err(Error::&lt;T&gt;::Overflow.into())
	}

	// Write the new value to storage
	ManualAccumulator::put(shifted_product as u32);

	// Emit event
	Self::deposit_event(Event::ManualUpdated(new_factor, shifted_product as u32));
	Ok(())
}
</code></pre>
<p>As mentioned above, when you multiply two 32-bit numbers, you can end up with as much as 64 bits in the product. In this 64-bit intermediate product, we have 32 integer bits and 32 fractional. We can simply throw away the 16 right-most fractional bits that merely provide extra precision. But we need to be careful with the 16 left-most integer bits. If any of those bits are non-zero after the multiplication it means overflow has occurred. If they are all zero, then we can safely throw them away as well.</p>
<blockquote>
<p>If this business about having more bits after the multiplication is confusing, try this exercise in the more familiar decimal system. Consider these numbers that have 4 total digits (2 integer, and two fractional): 12.34 and 56.78. Multiply them together. How many integer and fractional digits are in the product? Try that again with larger numbers like 01.23 * 02.48 and smaller like 11.11 and 22.22. Which of these products can be fit back into a 4-digit number like the ones we started with?</p>
</blockquote>
<h2><a class="header" href="#compounding-interest" id="compounding-interest">Compounding Interest</a></h2>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/compounding-interest"><code>pallets/compounding-interest</code></a></em></p>
<p>Many financial agreements involve interest for loaned or borrowed money. <a href="https://en.wikipedia.org/wiki/Compound_interest">Compounding interest</a> is when new interest is paid on top of not only the original loan amount, the so-called &quot;principal&quot;, but also any interest that has been previously paid.</p>
<h3><a class="header" href="#discrete-compounding" id="discrete-compounding">Discrete Compounding</a></h3>
<p>Our first example will look at discrete compounding interest. This is when interest is paid at a fixed interval. In our case, interest will be paid every ten blocks.</p>
<p>For this implementation we've chosen to use Substrate's <a href="https://substrate.dev/rustdocs/master/sp_arithmetic/struct.Percent.html"><code>Percent</code> type</a>. It works nearly the same as <code>Permill</code>, but it represents numbers as &quot;parts per hundred&quot; rather than &quot;parts per million&quot;. We could also have used Substrate-fixed for this implementation, but chose to save it for the next example.</p>
<p>The only storage item needed is a tracker of the account's balance. In order to focus on the fixed-point- and interest-related topics, this pallet does not actually interface with a <code>Currency</code>. Instead we just allow anyone to &quot;deposit&quot; or &quot;withdraw&quot; funds with no source or destination.</p>
<pre><code class="language-rust ignore">decl_storage! {
	trait Store for Module&lt;T: Trait&gt; as Example {
		// --snip--

		/// Balance for the discrete interest account
		DiscreteAccount get(fn discrete_account): u64;
	}
}
</code></pre>
<p>There are two extrinsics associated with the discrete interest account. The <code>deposit_discrete</code> extrinsic is shown here, and the <code>withdraw_discrete</code> extrinsic is nearly identical. Check it out in the kitchen.</p>
<pre><code class="language-rust ignore">fn deposit_discrete(origin, val_to_add: u64) -&gt; DispatchResult {
	ensure_signed(origin)?;

	let old_value = DiscreteAccount::get();

	// Update storage for discrete account
	DiscreteAccount::put(old_value + val_to_add);

	// Emit event
	Self::deposit_event(Event::DepositedDiscrete(val_to_add));
	Ok(())
}
</code></pre>
<p>The flow of these deposit and withdraw extrinsics is entirely straight-forward. They each perform a simple addition or substraction from the stored value, and they have nothing to do with interest.</p>
<p>Because the interest is paid discretely every ten blocks it can be handled independently of deposits and withdrawals. The interest calculation happens automatically in the <code>on_finalize</code> block.</p>
<pre><code class="language-rust ignore">fn on_finalize(n: T::BlockNumber) {
	// Apply newly-accrued discrete interest every ten blocks
	if (n % 10.into()).is_zero() {

		// Calculate interest Interest = principal * rate * time
		// We can use the `*` operator for multiplying a `Percent` by a u64
		// because `Percent` implements the trait Mul&lt;u64&gt;
		let interest = Self::discrete_interest_rate() * DiscreteAccount::get() * 10;

		// The following line, although similar, does not work because
		// u64 does not implement the trait Mul&lt;Percent&gt;
		// let interest = DiscreteAccount::get() * Self::discrete_interest_rate() * 10;

		// Update the balance
		let old_balance = DiscreteAccount::get();
		DiscreteAccount::put(old_balance + interest);

		// Emit the event
		Self::deposit_event(Event::DiscreteInterestApplied(interest));
	}
}
</code></pre>
<p><code>on_finalize</code> is called at the end of every block, but we only want to pay interest every ten blocks, so the first thing we do is check whether this block is a multiple of ten. If it is we calculate the interest due by the formula <code>interest = principal * rate * time</code>. As the comments explain, there is some subtlety in the order of the multiplication. You can multiply <code>PerCent * u64</code> but not <code>u64 * PerCent</code>.</p>
<h3><a class="header" href="#continuously-compounding" id="continuously-compounding">Continuously Compounding</a></h3>
<p>You can imagine increasing the frequency at which the interest is paid out. Increasing the frequency enough approaches <a href="https://en.wikipedia.org/wiki/Compound_interest#Continuous_compounding">continuously compounding interest</a>. Calculating continuously compounding interest requires the <a href="https://en.wikipedia.org/wiki/Exponential_function">exponential function</a> which is not available using Substrate's <code>PerThing</code> types. Luckily exponential and other <a href="https://en.wikipedia.org/wiki/Transcendental_function">transcendental functions</a> are available in substrate-fixed, which is why we've chosen to use it for this example.</p>
<p>With continuously compounded interest, we <em>could</em> update the interest in <code>on_finalize</code> as we did before, but it would need to be updated every single block. Instead we wait until a user tries to use the account (to deposit or withdraw funds), and then calculate the account's current value &quot;just in time&quot;.</p>
<p>To facilitate this implementation, we represent the state of the account not only as a balance, but as a balance, paired with the time when that balance was last updated.</p>
<pre><code class="language-rust ignore">#[derive(Encode, Decode, Default)]
pub struct ContinuousAccountData&lt;BlockNumber&gt; {
	/// The balance of the account after last manual adjustment
	principal: I32F32,
	/// The time (block height) at which the balance was last adjusted
	deposit_date: BlockNumber,
}
</code></pre>
<p>You can see we've chosen substrate-fixed's <code>I32F32</code> as our balance type this time. While we don't intend to handle negative balances, there is currently a limitation in the transcendental functions that requires using signed types.</p>
<p>With the struct to represent the account's state defined, we can initialize the storage value.</p>
<pre><code class="language-rust ignore">decl_storage! {
	trait Store for Module&lt;T: Trait&gt; as Example {
		// --snip--

		/// Balance for the continuously compounded account
		ContinuousAccount get(fn balance_compound): ContinuousAccountData&lt;T::BlockNumber&gt;;
	}
}
</code></pre>
<p>As before, there are two relevant extrinsics, <code>deposit_continuous</code> and <code>withdraw_continuous</code>. They are nearly identical so we'll only show one.</p>
<pre><code class="language-rust ignore">fn deposit_continuous(origin, val_to_add: u64) -&gt; DispatchResult {
	ensure_signed(origin)?;

	let current_block = system::Module::&lt;T&gt;::block_number();
	let old_value = Self::value_of_continuous_account(&amp;current_block);

	// Update storage for compounding account
	ContinuousAccount::&lt;T&gt;::put(
		ContinuousAccountData {
			principal: old_value + I32F32::from_num(val_to_add),
			deposit_date: current_block,
		}
	);

	// Emit event
	Self::deposit_event(Event::DepositedContinuous(val_to_add));
	Ok(())
}
</code></pre>
<p>This function itself isn't too insightful. It does the same basic things as the discrete variant: look up the old value and the deposit, update storage, and emit an event. The one interesting part is that it calls a helper function to get the account's previous value. This helper function calculates the value of the account considering all the interest that has accrued since the last time the account was touched. Let's take a closer look.</p>
<pre><code class="language-rust ignore">fn value_of_continuous_account(now: &amp;&lt;T as system::Trait&gt;::BlockNumber) -&gt; I32F32 {
	// Get the old state of the accout
	let ContinuousAccountData{
		principal,
		deposit_date,
	} = ContinuousAccount::&lt;T&gt;::get();

	// Calculate the exponential function (lots of type conversion)
	let elapsed_time_block_number = *now - deposit_date;
	let elapsed_time_u32 = TryInto::try_into(elapsed_time_block_number)
		.expect(&quot;blockchain will not exceed 2^32 blocks; qed&quot;);
	let elapsed_time_i32f32 = I32F32::from_num(elapsed_time_u32);
	let exponent : I32F32 = Self::continuous_interest_rate() * elapsed_time_i32f32;
	let exp_result : I32F32 = exp(exponent)
		.expect(&quot;Interest will not overflow account (at least not until the learner has learned enough about fixed point :)&quot;);

	// Return the result interest = principal * e ^ (rate * time)
	principal * exp_result
}
</code></pre>
<p>This function gets the previous state of the account, makes the interest calculation and returns the result. The reality of making these fixed point calculations is that type conversion will likely be your biggest pain point. Most of the lines are doing type conversion between the <code>BlockNumber</code>, <code>u32</code>, and <code>I32F32</code> types.</p>
<p>We've already seen that this helper function is used within the runtime for calculating the current balance &quot;just in time&quot; to make adjustments. In a real-world scenario, chain users would also want to check their balance at any given time. Because the current balance is not stored in runtime storage, it would be wise to <a href="3-entrees/./runtime-api.html">implement a runtime API</a> so this helper can be called from outside the runtime.</p>
<h1><a class="header" href="#off-chain-workers" id="off-chain-workers">Off-chain Workers</a></h1>
<blockquote>
<p>Before learning how to build your own off-chain worker, you may want to learn about what off-chain workers are, why you want to use them, and what kinds of problems they can solve best. These topics are covered in <a href="https://substrate.dev/docs/en/conceptual/core/off-chain-workers">our guide</a>. Here, we will focus on using off-chain workers in Substrate.</p>
</blockquote>
<p>Off-chain workers contain a set of powerful tools allowing your Substrate node to offload tasks that take too long or too much CPU / memory resources to compute, or have non-deterministic result. In particular we have a set of helpers allowing fetching of HTTP requests and using a community-contributed tool for parsing the returned JSON. It also provides its own storage that is unique to the particular off-chain worker node and not synchronized across the network.</p>
<p>Once the off-chain computation is completed, off-chain workers can submit either signed or unsigned transactions back on-chain.</p>
<p>We will deep-dive into each of the topics below.</p>
<ul>
<li><a href="3-entrees/off-chain-workers/./transactions.html">Signed and Unsigned Transactions</a></li>
<li><a href="3-entrees/off-chain-workers/./http-json.html">HTTP fetching and JSON parsing</a></li>
<li><a href="3-entrees/off-chain-workers/./storage.html">Local storage in Off-chain Workers</a></li>
</ul>
<h1><a class="header" href="#transactions-in-off-chain-workers" id="transactions-in-off-chain-workers">Transactions in Off-chain Workers</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/offchain-demo"><code>pallets/offchain-demo</code></a></em></p>
<h2><a class="header" href="#compiling-this-pallet" id="compiling-this-pallet">Compiling this Pallet</a></h2>
<p>This <code>offchain-demo</code> pallet is included in the <a href="https://github.com/substrate-developer-hub/recipes/tree/master/runtimes/ocw-runtime">ocw-runtime</a>. That runtime can be used in the kitchen node.</p>
<p>In order to use the Offchain worker, the node must inject some keys into its keystore, and that is enabled with a feature flag.</p>
<p>First, edit <code>nodes/kitchen-node/Cargo.toml</code> to enable the <code>ocw-runtime</code>.</p>
<p>Then, build the kitchen node with these commands.</p>
<pre><code class="language-bash"># Switch to kitchen-node directory
cd nodes/kitchen-node

# Compile with OCW feature
cargo build --release --features ocw
</code></pre>
<h2><a class="header" href="#life-cycle-of-off-chain-worker" id="life-cycle-of-off-chain-worker">Life-cycle of Off-chain Worker</a></h2>
<p>Running the <code>kitchen-node</code>, you will see the off-chain worker is run after each block generation phase, as shown by <code>Entering off-chain workers</code> in the node output message:</p>
<pre><code>...
2020-03-14 13:30:36 Starting BABE Authorship worker
2020-03-14 13:30:36 Prometheus server started at 127.0.0.1:9615
2020-03-14 13:30:41 Idle (0 peers), best: #0 (0x2658‚Ä¶9a5b), finalized #0 (0x2658‚Ä¶9a5b), ‚¨á 0 ‚¨Ü 0
2020-03-14 13:30:42 Starting consensus session on top of parent 0x26582455e63448e8dafe1e70f04d7d74d39358c6b71c306eb7013e2c54069a5b
2020-03-14 13:30:42 Prepared block for proposing at 1 [hash: 0xdc7a76fc89c45a3f318e29df06cbdb097cc3094112b204f10e1e84e0799eba88; parent_hash: 0x2658‚Ä¶9a5b; extrinsics (1): [0xf572‚Ä¶63c0]]
2020-03-14 13:30:42 Pre-sealed block for proposal at 1. Hash now 0x3558accae1325a2ae5569512b8542e90ae11b4f0de6834ba901eb03b97a680aa, previously 0xdc7a76fc89c45a3f318e29df06cbdb097cc3094112b204f10e1e84e0799eba88.
2020-03-14 13:30:42 New epoch 0 launching at block 0x3558‚Ä¶80aa (block slot 264027307 &gt;= start slot 264027307).
2020-03-14 13:30:42 Next epoch starts at slot 264027407
2020-03-14 13:30:42 Imported #1 (0x3558‚Ä¶80aa)
2020-03-14 13:30:42 Entering off-chain workers
2020-03-14 13:30:42 off-chain send_signed: acc: 5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY| number: 0
...
</code></pre>
<p>Referring to the code at <a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/offchain-demo/src/lib.rs"><code>pallets/offchain-demo/src/lib.rs</code></a>, there is an <code>offchain_worker</code> function inside <code>decl_module!</code>. This is the entry point of the off-chain worker that is executed once after each block generation, so we put all the off-chain logic here.</p>
<p>Two kinds of transactions can be sent back on-chain from off-chain workers, <strong>Signed Transactions</strong> and <strong>Unsigned Transactions</strong>. Signed transactions are used if the transaction requires the sender to be specified. Unsigned transactions are used when the sender does not need to be known, and additional logic is written in the code to provide extra data verification. Let's walk through how to set up each one.</p>
<h2><a class="header" href="#signed-transactions" id="signed-transactions">Signed Transactions</a></h2>
<h3><a class="header" href="#setup" id="setup">Setup</a></h3>
<p>For signed transactions, the first thing you will notice is that we have defined another sub-module here:</p>
<p>src: <a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/offchain-demo/src/lib.rs"><code>pallets/offchain-demo/src/lib.rs</code></a></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub const KEY_TYPE: KeyTypeId = KeyTypeId(*b&quot;demo&quot;);

pub mod crypto {
	use crate::KEY_TYPE;
	use sp_runtime::app_crypto::{app_crypto, sr25519};
	app_crypto!(sr25519, KEY_TYPE);
}
<span class="boring">}
</span></code></pre></pre>
<p>This is the application key to be used as the prefix for this pallet in underlying storage.</p>
<p>Second, we have added an additional associated type <code>SubmitSignedTransaction</code>.</p>
<p>src: <a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/offchain-demo/src/lib.rs"><code>pallets/offchain-demo/src/lib.rs</code></a></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub trait Trait: system::Trait {
	//...snip
	type SubmitSignedTransaction: offchain::SubmitSignedTransaction&lt;Self, &lt;Self as Trait&gt;::Call&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>This associated type needs to be specified by the runtime when the runtime is to include this pallet (implement this pallet trait).</p>
<p>Looking at the <a href="https://substrate.dev/rustdocs/master/frame_system/offchain/trait.SubmitSignedTransaction.html">rustdoc of <code>SubmitSignedTransaction</code></a>, it says that we should use the <code>TransactionSubmitter</code> implementation type. Let's do that in our runtime.</p>
<p>src: <a href="https://github.com/substrate-developer-hub/recipes/tree/master/runtimes/ocw-runtime/src/lib.rs"><code>runtimes/ocw-runtime/src/lib.rs</code></a></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>type SubmitTransaction = system::offchain::TransactionSubmitter&lt;
	offchain_demo::crypto::Public,
	Runtime,
	UncheckedExtrinsic
&gt;;

impl offchain_demo::Trait for Runtime {
	type Call = Call;
	type Event = Event;
	type SubmitSignedTransaction = SubmitTransaction;
	//...snip
}
<span class="boring">}
</span></code></pre></pre>
<p>Now if we build the <code>kitchen-node</code>, we will see the compiler complain that the trait bound for <code>Runtime: frame_system::offchain::CreateTransaction</code> is not satisfied. We learn that when using <code>SubmitSignedTransaction</code>, we also need to have our runtime implement the <a href="https://substrate.dev/rustdocs/master/frame_system/offchain/trait.CreateTransaction.html"><code>CreateTransaction</code> trait</a>. So let's implement this in our runtime.</p>
<p>src: <a href="https://github.com/substrate-developer-hub/recipes/tree/master/runtimes/ocw-runtime/src/lib.rs"><code>runtimes/ocw-runtime/src/lib.rs</code></a></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl system::offchain::CreateTransaction&lt;Runtime, UncheckedExtrinsic&gt; for Runtime {
	type Public = &lt;Signature as Verify&gt;::Signer;
	type Signature = Signature;

	fn create_transaction&lt;TSigner: system::offchain::Signer&lt;Self::Public, Self::Signature&gt;&gt; (
		call: Call,
		public: Self::Public,
		account: AccountId,
		index: Index,
	) -&gt; Option&lt;(Call, &lt;UncheckedExtrinsic as sp_runtime::traits::Extrinsic&gt;::SignaturePayload)&gt; {
		let period = BlockHashCount::get() as u64;
		let current_block = System::block_number()
			.saturated_into::&lt;u64&gt;().saturating_sub(1);
		let tip = 0;
		let extra: SignedExtra = (
			system::CheckVersion::&lt;Runtime&gt;::new(),
			system::CheckGenesis::&lt;Runtime&gt;::new(),
			system::CheckEra::&lt;Runtime&gt;::from(generic::Era::mortal(period, current_block)),
			system::CheckNonce::&lt;Runtime&gt;::from(index),
			system::CheckWeight::&lt;Runtime&gt;::new(),
			transaction_payment::ChargeTransactionPayment::&lt;Runtime&gt;::from(tip),
		);

		let raw_payload = SignedPayload::new(call, extra).map_err(|e| {
			debug::native::warn!(&quot;SignedPayload error: {:?}&quot;, e);
		}).ok()?;

		let signature = TSigner::sign(public, &amp;raw_payload)?;
		let address = account;
		let (call, extra, _) = raw_payload.deconstruct();
		Some((call, (address, signature, extra)))
	}
}

// ...snip
<span class="boring">}
</span></code></pre></pre>
<p>There is a lot happening in the code. But basically we are:</p>
<ul>
<li>Signing the <code>call</code> and <code>extra</code>, also called signed extension, and</li>
<li>Making the call(<code>call</code>, which includes the call paramters) and passing the sender <code>address</code>, signature of the data <code>signature</code>, and its signed extension <code>extra</code> on-chain as a transaction.</li>
</ul>
<p>We also define <code>SignedExtra</code> data type later in the runtime.</p>
<p>src: <a href="https://github.com/substrate-developer-hub/recipes/tree/master/runtimes/ocw-runtime/src/lib.rs"><code>runtimes/ocw-runtime/src/lib.rs</code></a></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>/// The SignedExtension to the basic transaction logic.
pub type SignedExtra = (
	system::CheckTxVersion&lt;Runtime&gt;,
	system::CheckGenesis&lt;Runtime&gt;,
	system::CheckEra&lt;Runtime&gt;,
	system::CheckNonce&lt;Runtime&gt;,
	system::CheckWeight&lt;Runtime&gt;,
	transaction_payment::ChargeTransactionPayment&lt;Runtime&gt;,
);
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#sending-signed-transactions" id="sending-signed-transactions">Sending Signed Transactions</a></h3>
<p>A signed transaction is sent with <code>T::SubmitSignedTransaction::submit_signed</code>, as shown below:</p>
<p>src: <a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/offchain-demo/src/lib.rs"><code>pallets/offchain-demo/src/lib.rs</code></a></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn send_signed(block_number: T::BlockNumber) -&gt; Result&lt;(), Error&lt;T&gt;&gt; {
	use system::offchain::SubmitSignedTransaction;
	//..snip

	let submission: u64 = block_number.try_into().ok().unwrap() as u64;
	let call = Call::submit_number_signed(submission);

	// Using `SubmitSignedTransaction` associated type we create and submit a transaction
	//   representing the call, we've just created.
	let results = T::SubmitSignedTransaction::submit_signed(call);
	for (acc, res) in &amp;results {
		match res {
			Ok(()) =&gt; { debug::native::info!(&quot;off-chain send_signed: acc: {}| number: {}&quot;, acc, submission); },
			Err(e) =&gt; {
				debug::native::error!(&quot;[{:?}] Failed to submit signed tx: {:?}&quot;, acc, e);
				return Err(&lt;Error&lt;T&gt;&gt;::SendSignedError);
			}
		};
	}
	Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>We have a function reference to <code>Call::submit_number_signed(submission)</code>. This is the function we are going to submit back to on-chain, and passing it to <code>T::SubmitSignedTransaction::submit_signed(call)</code>.</p>
<p>You will notice that we run a for loop in the returned result. This implies that this call may make multiple transactions and return multiple results. It is because this call actually signs and sends the transaction with each of the accounts that can be found locally under the application crypto (which we defined earlier in <code>pub mod crypto {...}</code>). You can view this as the local accounts that are managed under this pallet namespace. Right now, we only have one key in the app crypto, so only one signed transaction is made.</p>
<p>Eventually, the <code>call</code> transaction is made on-chain via the <code>create_transaction</code> function we defined earlier when we implemented <code>CreateTransaction</code> trait in our runtime.</p>
<p>If you are wondering where we insert the local account in the pallet app crypto, it is actually in the outer node's <a href="https://substrate.dev/rustdocs/master/sc_service/index.html">service</a>.</p>
<p>src: <a href="https://github.com/substrate-developer-hub/recipes/tree/master/nodes/kitchen-node/src/service.rs"><code>nodes/kitchen-node/src/service.rs</code></a></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub fn new_full(config: Configuration&lt;GenesisConfig&gt;)
	-&gt; Result&lt;impl AbstractService, ServiceError&gt;
{
	// ...snip
	let dev_seed = config.dev_key_seed.clone();

	// ...snip
	// Initialize seed for signing transaction using off-chain workers
	if let Some(seed) = dev_seed {
		service
			.keystore()
			.write()
			.insert_ephemeral_from_seed_by_type::&lt;runtime::offchain_demo::crypto::Pair&gt;(
				&amp;seed,
				runtime::offchain_demo::KEY_TYPE,
			)
			.expect(&quot;Dev Seed should always succeed.&quot;);
	}
	// ...snip
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#unsigned-transactions" id="unsigned-transactions">Unsigned Transactions</a></h2>
<h3><a class="header" href="#setup-1" id="setup-1">Setup</a></h3>
<p>For unsigned transactions, we have the equivalent setup in the pallet configuration trait. In the first step, we add back the <code>SubmitUnsignedTransaction</code> associated type.</p>
<p>src: <a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/offchain-demo/src/lib.rs"><code>pallets/offchain-demo/src/lib.rs</code></a></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub trait Trait: system::Trait {
	/// The overarching dispatch call type.
	type Call: From&lt;Call&lt;Self&gt;&gt;;
	/// The overarching event type.
	type Event: From&lt;Event&lt;Self&gt;&gt; + Into&lt;&lt;Self as system::Trait&gt;::Event&gt;;
	/// The type to submit unsigned transactions.
	type SubmitUnsignedTransaction:
		offchain::SubmitUnsignedTransaction&lt;Self, &lt;Self as Trait&gt;::Call&gt;;
	// ...snip
}
<span class="boring">}
</span></code></pre></pre>
<p>By default, unsigned transactions are rejected by the Substrate runtime unless they are explicitly allowed. So in the second step, we need to write the logic to allow unsigned transactions for certain particular dispatched functions as follows:</p>
<p>src: <a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/offchain-demo/src/lib.rs"><code>pallets/offchain-demo/src/lib.rs</code></a></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl&lt;T: Trait&gt; support::unsigned::ValidateUnsigned for Module&lt;T&gt; {
	type Call = Call&lt;T&gt;;

	fn validate_unsigned(call: &amp;Self::Call) -&gt; TransactionValidity {
		if let Call::submit_number_unsigned(block_num, number) = call {
			debug::native::info!(&quot;off-chain send_unsigned: block_num: {}| number: {}&quot;, block_num, number);

			Ok(ValidTransaction {
				priority: 1 &lt;&lt; 20,
				requires: vec![],
				provides: vec![codec::Encode::encode(&amp;(KEY_TYPE.0, block_num))],
				longevity: 3,
				propagate: false,
			})
		} else {
			InvalidTransaction::Call.into()
		}
	}
}
<span class="boring">}
</span></code></pre></pre>
<p>We implement <code>ValidateUnsigned</code>, and the allowance logic is added inside the <code>validate_unsigned</code> function. We check if the call is to <code>Call::submit_number_unsigned</code> and returns <code>Ok()</code> if this is the case. Otherwise, <code>InvalidTransaction::Call</code>.</p>
<p>The <code>ValidTransaction</code> object has some fields that touch on concepts that we have not discussed before:</p>
<ul>
<li><code>priority</code>: Ordering of two transactions, given their dependencies are satisfied.</li>
<li><code>requires</code>: List of tags this transaction depends on.</li>
<li><code>provides</code>: List of tags provided by this transaction. Successfully importing the transaction will enable other transactions that depend on these tags to be included as well. <code>provides</code> and <code>requires</code> tags allow Substrate to build a dependency graph of transactions and import them in the right order.</li>
<li><code>longevity</code>: Transaction longevity, which describes the minimum number of blocks the transaction is valid for. After this period the transaction should be removed from the pool or revalidated.</li>
<li><code>propagate</code>: Indication if the transaction should be propagated to other peers. By setting to <code>false</code> the transaction will still be considered for inclusion in blocks that are authored on the current node, but will never be sent to other peers.</li>
</ul>
<p>Third, we define the associated type of <code>SubmitUnsignedTransaction</code> in our runtime.</p>
<p>src: <a href="https://github.com/substrate-developer-hub/recipes/tree/master/runtimes/ocw-runtime/src/lib.rs"><code>runtimes/ocw-runtime/src/lib.rs</code></a></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>type SubmitTransaction = system::offchain::TransactionSubmitter&lt;
	offchain_demo::crypto::Public,
	Runtime,
	UncheckedExtrinsic
&gt;;

impl offchain_demo::Trait for Runtime {
	//...snip
	type SubmitUnsignedTransaction = SubmitTransaction;
}
<span class="boring">}
</span></code></pre></pre>
<p>Finally, to tell the runtime that we have our own <code>ValidateUnsigned</code> logic, we also need to pass this as a parameter when constructing the runtime.</p>
<p>src: <a href="https://github.com/substrate-developer-hub/recipes/tree/master/runtimes/ocw-runtime/src/lib.rs"><code>runtimes/ocw-runtime/src/lib.rs</code></a></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>construct_runtime!(
	pub enum Runtime where
		Block = Block,
		NodeBlock = opaque::Block,
		UncheckedExtrinsic = UncheckedExtrinsic
	{
		//...snip
		OffchainDemo: offchain_demo::{Module, Call, Storage, Event&lt;T&gt;, ValidateUnsigned},
	}
);
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#sending-unsigned-transactions" id="sending-unsigned-transactions">Sending Unsigned Transactions</a></h3>
<p>We can now make an unsigned transaction from offchain worker with the <code>T::SubmitUnsignedTransaction::submit_unsigned</code> function, as shown in the code.</p>
<p>src: <a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/offchain-demo/src/lib.rs"><code>pallets/offchain-demo/src/lib.rs</code></a></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn send_unsigned(block_number: T::BlockNumber) -&gt; Result&lt;(), Error&lt;T&gt;&gt; {
	use system::offchain::SubmitUnsignedTransaction;

	let submission: u64 = block_number.try_into().ok().unwrap() as u64;
	// the `block_number` param should be unique within each block generation phase
	let call = Call::submit_number_unsigned(block_number, submission);

	T::SubmitUnsignedTransaction::submit_unsigned(call).map_err(|e| {
		debug::native::error!(&quot;Failed to submit unsigned tx: {:?}&quot;, e);
		&lt;Error&lt;T&gt;&gt;::SendUnsignedError
	})
}
<span class="boring">}
</span></code></pre></pre>
<p>As in signed transactions, we prepare a function reference with its parameters and then call <code>T::SubmitUnsignedTransaction::submit_unsigned</code>.</p>
<h2><a class="header" href="#testing" id="testing">Testing</a></h2>
<p>For writing test cases for off-chain worker, refer to our <a href="3-entrees/off-chain-workers//3-entrees/testing/off-chain-workers.html">testing section</a>.</p>
<h1><a class="header" href="#http-fetching-and-json-parsing-in-off-chain-workers" id="http-fetching-and-json-parsing-in-off-chain-workers">HTTP Fetching and JSON Parsing in Off-chain Workers</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/offchain-demo"><code>pallets/offchain-demo</code></a></em></p>
<h2><a class="header" href="#http-fetching" id="http-fetching">HTTP Fetching</a></h2>
<p>In traditional web app, it is often necessary to communicate with third-party APIs to fetch data that the app itself does not contains. But this becomes tricky in blockchain decentralized apps because HTTP requests are indeterministic. There are uncertainty in terms of whether the HTTP request will come back, how long it takes, and if the result stays the same when the result is being validated by another node at a future point.</p>
<p>In Substrate, we solve this problem by using off-chain workers to issue HTTP requests and get the result back.</p>
<p>In <code>pallets/offchain-demo/src/lib.rs</code>, we have an example of fetching information of github organization <code>substrate-developer-hub</code> via its public API. Then we extract the <code>login</code>, <code>blog</code>, and <code>public_repos</code> values out.</p>
<p>First, include the tools implemented in <code>sp_runtime::offchain</code> at the top.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use sp_runtime::{
	offchain as rt_offchain
}
<span class="boring">}
</span></code></pre></pre>
<p>We then issue http requests inside the <code>fetch_from_remote()</code> function.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Initiate an external HTTP GET request. This is using high-level wrappers from `sp_runtime`.
let remote_url = str::from_utf8(&amp;remote_url_bytes)
	.map_err(|_| &lt;Error&lt;T&gt;&gt;::HttpFetchingError)?;

let request = rt_offchain::http::Request::get(remote_url);
<span class="boring">}
</span></code></pre></pre>
<p>We should also set a timeout period so the http request does not hold indefinitely. For github API usage, we also need to add extra HTTP header information to it. This is how we do it.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Keeping the offchain worker execution time reasonable, so limiting the call to be within 3s.
//   `sp_io` pallet offers a timestamp() to get the current timestamp from off-chain perspective.
let timeout = sp_io::offchain::timestamp().add(rt_offchain::Duration::from_millis(3000));

// For github API request, we also need to specify `user-agent` in http request header.
//   See: https://developer.github.com/v3/#user-agent-required
let pending = request
	.add_header(&quot;User-Agent&quot;, str::from_utf8(&amp;user_agent)
		.map_err(|_| &lt;Error&lt;T&gt;&gt;::HttpFetchingError)?)
	.deadline(timeout) // Setting the timeout time
	.send() // Sending the request out by the host
	.map_err(|_| &lt;Error&lt;T&gt;&gt;::HttpFetchingError)?; // Here we capture and return any http error.
<span class="boring">}
</span></code></pre></pre>
<p>HTTP requests from off-chain worker are fetched asynchronously. Here we use <code>try_wait()</code> to wait for the result to come back, and terminate and return if any errors occured.</p>
<p>Then, We check for the response status code to ensure it is okay with HTTP status code equals to 200. Any status code that is non-200 is regarded as error and return.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let response = pending.try_wait(timeout)
	.map_err(|_| &lt;Error&lt;T&gt;&gt;::HttpFetchingError)?
	.map_err(|_| &lt;Error&lt;T&gt;&gt;::HttpFetchingError)?;

if response.code != 200 {
	debug::error!(&quot;Unexpected http request status code: {}&quot;, response.code);
	return Err(&lt;Error&lt;T&gt;&gt;::HttpFetchingError);
}
<span class="boring">}
</span></code></pre></pre>
<p>Finally, get the response back with <code>response.body()</code> iterator. Since we are in a <code>no_std</code> environment, we collect them back as a vector of bytes instead of a string and return.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>Ok(response.body().collect::&lt;Vec&lt;u8&gt;&gt;())
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#json-parsing" id="json-parsing">JSON Parsing</a></h2>
<p>We usually get JSON objects back when requesting from HTTP APIs. The next task is to parse the JSON object and fetch the required (key, value) pair out. This is demonstrated in the <code>fetch_n_parse</code> function.</p>
<h3><a class="header" href="#setup-2" id="setup-2">Setup</a></h3>
<p>In Rust, <code>serde</code> and <code>serde-json</code> are the popular combo-package used for JSON parsing. Due to the project setup of compiling Substrate node with <code>serde</code> feature <code>std</code> on and cargo feature unification limitation, we cannot simultaneously have <code>serde</code> feature <code>std</code> off (<code>no_std</code> on) when compiling the runtime (<a href="https://github.com/rust-lang/cargo/issues/4463">details described in this issue</a>). So we are going to use a renamed <code>serde</code> crate, <code>alt_serde</code>, in our offchain-demo pallet to remedy this situation.</p>
<p>src: <code>pallets/offchain-demo/Cargo.toml</code></p>
<pre><code class="language-toml">[package]
# ...

[dependencies]
# external dependencies
# ...

alt_serde = { version = &quot;1&quot;, default-features = false, features = [&quot;derive&quot;] }
# updated to `alt_serde_json` when latest version supporting feature `alloc` is released
serde_json = { version = &quot;1&quot;, default-features = false, git = &quot;https://github.com/Xanewok/json&quot;, branch = &quot;no-std&quot;, features = [&quot;alloc&quot;] }

# ...
</code></pre>
<p>We also use a modified version of <code>serde_json</code> that has the latest <code>alloc</code> feature and again depends on only <code>alt_serde</code>.</p>
<blockquote>
<p>Another way of compiling <code>serde</code> with <code>no_std</code> in runtime is to use a cargo nightly feature, <a href="https://github.com/rust-lang/cargo/pull/7820">additional feature resolver</a> (<a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#resolver">relevant doc</a>).</p>
</blockquote>
<h3><a class="header" href="#deserializing-json-string-to-struct" id="deserializing-json-string-to-struct">Deserializing JSON string to struct</a></h3>
<p>Then we use the usual <code>serde-derive</code> approach on deserializing. First we define the struct with fields we are interested to extract out.</p>
<p>src: <code>pallets/offchain-demo/src/lib.rs</code></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// We use `alt_serde`, and Xanewok-modified `serde_json` so that we can compile the program
//   with serde(features `std`) and alt_serde(features `no_std`).
use alt_serde::{Deserialize, Deserializer};

// Specifying serde path as `alt_serde`
// ref: https://serde.rs/container-attrs.html#crate
#[serde(crate = &quot;alt_serde&quot;)]
#[derive(Deserialize, Encode, Decode, Default)]
struct GithubInfo {
	// Specify our own deserializing function to convert JSON string to vector of bytes
	#[serde(deserialize_with = &quot;de_string_to_bytes&quot;)]
	login: Vec&lt;u8&gt;,
	#[serde(deserialize_with = &quot;de_string_to_bytes&quot;)]
	blog: Vec&lt;u8&gt;,
	public_repos: u32,
}
<span class="boring">}
</span></code></pre></pre>
<p>By default, <code>serde</code> deserialize JSON string to the datatype <code>String</code>. We want to write our own deserializer to convert it to vector of bytes.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub fn de_string_to_bytes&lt;'de, D&gt;(de: D) -&gt; Result&lt;Vec&lt;u8&gt;, D::Error&gt;
where D: Deserializer&lt;'de&gt; {
	let s: &amp;str = Deserialize::deserialize(de)?;
	Ok(s.as_bytes().to_vec())
}
<span class="boring">}
</span></code></pre></pre>
<p>Now the actual deserialization takes place in the <code>Self::fetch_n_parse</code> function.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>/// Fetch from remote and deserialize the JSON to a struct
fn fetch_n_parse() -&gt; Result&lt;GithubInfo, Error&lt;T&gt;&gt; {
	let resp_bytes = Self::fetch_from_remote()
		.map_err(|e| {
			debug::error!(&quot;fetch_from_remote error: {:?}&quot;, e);
			&lt;Error&lt;T&gt;&gt;::HttpFetchingError
		})?;

	let resp_str = str::from_utf8(&amp;resp_bytes)
		.map_err(|_| &lt;Error&lt;T&gt;&gt;::HttpFetchingError)?;

	// Deserializing JSON to struct, thanks to `serde` and `serde_derive`
	let gh_info: GithubInfo = serde_json::from_str(&amp;resp_str).unwrap();
	Ok(gh_info)
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#local-storage-in-off-chain-workers" id="local-storage-in-off-chain-workers">Local Storage in Off-chain Workers</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/offchain-demo"><code>pallets/offchain-demo</code></a></em></p>
<p>Remember we mentioned that off-chain workers (short for <strong>ocw</strong> below) cannot write directly to the on-chain storage, that is why they have to submit transactions back on-chain to modify the state.</p>
<p>Fortunately, there is also a local storage that persist across runs in off-chain workers. Storage is local within off-chain workers and not passed within network. Storage of off-chain workers is persisted across runs of off-chain workers and blockchain re-organizations.</p>
<p>Off-chain workers are asynchronously run during block import. Since ocws are not limited by how long they run, at any single instance there could be multiple ocws running, being initiated by previous block imports. See diagram below.</p>
<p><img src="3-entrees/off-chain-workers//img/multiple-ocws.png" alt="More than one off-chain workers at a single instance" /></p>
<p>The storage has a similar API usage as on-chain <a href="3-entrees/off-chain-workers//2-appetizers/2-storage-values.html"><code>StorageValue</code></a> with <code>get</code>, <code>set</code>, and <code>mutate</code>. <code>mutate</code> is using a <a href="https://en.wikipedia.org/wiki/Compare-and-swap"><code>compare-and-set</code></a> pattern. It compares the contents of a memory location with a given value and, only if they are the same, modifies the contents of that memory location to a new given value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail.</p>
<p>In this recipe, we will add a cache and lock over our previous <a href="3-entrees/off-chain-workers/./http-json.html">http fetching example</a>. If the cached value existed, we will return using the cached value. Otherwise we acquire the lock and then fetch from github public API and save it to the cache.</p>
<h2><a class="header" href="#setup-3" id="setup-3">Setup</a></h2>
<p>First, include the relevant module.</p>
<p>src: <code>offchain-demo/src/lib.rs</code></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use sp_runtime::{
	// ...
	offchain::{storage::StorageValueRef},
	// ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Then, in the <code>fetch_if_needed()</code> function, we first define a storage reference used by the off-chain worker.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn fetch_if_needed() -&gt; Result&lt;(), Error&lt;T&gt;&gt; {

	// Start off by creating a reference to Local Storage value.
	// Since the local storage is common for all offchain workers, it's a good practice
	// to prepend our entry with the pallet name.
	let storage = StorageValueRef::persistent(b&quot;offchain-demo::gh-info&quot;);
	let s_lock = StorageValueRef::persistent(b&quot;offchain-demo::lock&quot;);
	// ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Looking at the <a href="https://substrate.dev/rustdocs/master/sp_runtime/offchain/storage/struct.StorageValueRef.html">API doc</a>, we see there are two type of StorageValueRef, created via <code>::persistent()</code> and <code>::local()</code>. <code>::local()</code> is not fully implemented yet and <code>::persistent()</code> is enough for this use cases. We passed in a key as our storage key. As storage keys are namespaced globally, a good practice would be to prepend our pallet name in front of our storage key.</p>
<h2><a class="header" href="#access" id="access">Access</a></h2>
<p>Once we have the storage reference, we can access the storage via <code>get</code>, <code>set</code>, and <code>mutate</code>. Let's demonstrate the <code>mutate</code> function as the usage of the remaining two functions are pretty self-explanatory.</p>
<p>First we fetch to see if github info has been fetched and cached. If yes, we return early.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn fetch_if_needed() -&gt; Result&lt;(), Error&lt;T&gt;&gt; {
	// ...
	if let Some(Some(gh_info)) = s_info.get::&lt;GithubInfo&gt;() {
		// gh-info has already been fetched. Return early.
		debug::info!(&quot;cached gh-info: {:?}&quot;, gh_info);
		return Ok(());
	}
	// ...
}
<span class="boring">}
</span></code></pre></pre>
<p>As with general on-chain storage, if we have a storage access pattern of <strong>get-check-set</strong>, it is a good indicator we should use <code>mutate</code>. This makes sure that multiple off-chain workers running concurrently does not modify the same storage entry.</p>
<p>We then try to acquire the lock in order to fetch github info.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn fetch_if_needed() -&gt; Result&lt;(), Error&lt;T&gt;&gt; {
	//...
	// We are implementing a mutex lock here with `s_lock`
	let res: Result&lt;Result&lt;bool, bool&gt;, Error&lt;T&gt;&gt; = s_lock.mutate(|s: Option&lt;Option&lt;bool&gt;&gt;| {
		match s {
			// `s` can be one of the following:
			//   `None`: the lock has never been set. Treated as the lock is free
			//   `Some(None)`: unexpected case, treated it as AlreadyFetch
			//   `Some(Some(false))`: the lock is free
			//   `Some(Some(true))`: the lock is held

			// If the lock has never been set or is free (false), return true to execute `fetch_n_parse`
			None | Some(Some(false)) =&gt; Ok(true),

			// Otherwise, someone already hold the lock (true), we want to skip `fetch_n_parse`.
			// Covering cases: `Some(None)` and `Some(Some(true))`
			_ =&gt; Err(&lt;Error&lt;T&gt;&gt;::AlreadyFetched),
		}
	});
	//...
}
<span class="boring">}
</span></code></pre></pre>
<p>We use the <code>mutate</code> function to get and set the lock value, taking advantages of its compare-and-set access pattern. If the lock is being held by another ocw (with <code>s</code> equals value of <code>Some(Some(true))</code>), we return an error indicating the fetching is done by another ocw.</p>
<p>The return value of the <code>mutate</code> has a type of <code>Result&lt;Result&lt;T, T&gt;, E&gt;</code>, to indicate one of the following cases:</p>
<ul>
<li><code>Ok(Ok(T))</code> - the value has been successfully set in the <code>mutate</code> closure and saved to the storage.</li>
<li><code>Ok(Err(T))</code> - the value has been successfully set in the <code>mutate</code> closure, but failed to save to the storage.</li>
<li><code>Err(_)</code> - the value has <strong>NOT</strong> been set successfully in the <code>mutate</code> closure.</li>
</ul>
<p>Now we check the returned value of the <code>mutate</code> function. If fetching is done by another ocw (returning <code>Err(&lt;Error&lt;T&gt;&gt;)</code>), or cannot acquire the lock (returning <code>Ok(Err(true))</code>), we skip the fetching.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn fetch_if_needed() -&gt; Result&lt;(), Error&lt;T&gt;&gt; {
	// ...
	// Cases of `res` returned result:
	//   `Err(&lt;Error&lt;T&gt;&gt;)` - lock is held, so we want to skip `fetch_n_parse` function.
	//   `Ok(Err(true))` - Another ocw is writing to the storage while we set it,
	//                     we also skip `fetch_n_parse` in this case.
	//   `Ok(Ok(true))` - successfully acquire the lock, so we run `fetch_n_parse`
	if let Ok(Ok(true)) = res {
		match Self::fetch_n_parse() {
			Ok(gh_info) =&gt; {
				// set gh-info into the storage and release the lock
				s_info.set(&amp;gh_info);
				s_lock.set(&amp;false);

				debug::info!(&quot;fetched gh-info: {:?}&quot;, gh_info);
			},
			Err(err) =&gt; {
				// release the lock
				s_lock.set(&amp;false);
				return Err(err);
			}
		}
	}
	Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>Finally, whether the <code>fetch_n_parse()</code> function success or not, we release the lock by setting it to <code>false</code>.</p>
<h2><a class="header" href="#reference" id="reference">Reference</a></h2>
<ul>
<li><a href="https://substrate.dev/rustdocs/master/sp_runtime/offchain/storage/struct.StorageValueRef.html"><code>StorageValueRef</code> API doc</a></li>
<li><a href="https://github.com/paritytech/substrate/tree/master/frame/example-offchain-worker"><code>example-offchain-worker</code> pallet in Substrate repo</a></li>
</ul>
<h1><a class="header" href="#runtime-apis" id="runtime-apis">Runtime APIs</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/sum-storage"><code>pallets/sum-storage</code></a></em>
<em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/runtimes/api-runtime"><code>runtimes/api-runtime</code></a></em></p>
<p>Each Substrate node contains a runtime. The runtime contains the business logic of the chain. It defines what transactions are valid and invalid and determines how the chain's state changes in response to transactions. The runtime is compiled to Wasm to facilitate runtime upgrades. The &quot;outer node&quot;, everything other than the runtime, does not compile to Wasm, only to native. The outer node is responsible for handling peer discovery, transaction pooling, block and transaction gossiping, consensus, and answering RPC calls from the outside world. While performing these tasks, the outer node sometimes needs to query the runtime for information, or provide information to the runtime. A Runtime API facilitates this kind of communication between the outer node and the runtime. In this recipe, we will write our own minimal runtime API.</p>
<h2><a class="header" href="#our-example" id="our-example">Our Example</a></h2>
<p>For this example, we will write a pallet called <code>sum-storage</code> with two storage items, both <code>u32</code>s.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>decl_storage! {
	trait Store for Module&lt;T: Trait&gt; as TemplateModule {
		Thing1 get(fn thing1): Option&lt;u32&gt;;
		Thing2 get(fn thing2): Option&lt;u32&gt;;
	}
}
<span class="boring">}
</span></code></pre></pre>
<p>Substrate already comes with a runtime API for querying storage values, which is why we can easily query our two storage values from a front-end. In this example we imagine that the outer node is interested in knowing the <em>sum</em> of the two values, rather than either individual value. Our runtime API will provide a way for the outer node to query the runtime for this sum. Before we define the actual runtime API, let's write a public helper function in the pallet to do the summing.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl&lt;T: Trait&gt; Module&lt;T&gt; {
	pub fn get_sum() -&gt; u32 {
		Thing1::get() + Thing2::get()
	}
}
<span class="boring">}
</span></code></pre></pre>
<p>So far, nothing we've done is specific to runtime APIs. In the coming sections, we will use this helper function in our runtime API's implementation.</p>
<h2><a class="header" href="#defining-the-api" id="defining-the-api">Defining the API</a></h2>
<p>The first step in adding a runtime API to your runtime is defining its interface using a Rust trait. This is done in the <code>sum-storage/runtime-api/src/lib.rs</code> file. This file can live anywhere you like, but because it defines an API that is closely related to a particular pallet, it makes sense to include the API definition in the pallet's directory.</p>
<p>The code to define the API is quite simple, and looks almost like any old Rust trait. The one addition is that it must be placed in the <a href="https://substrate.dev/rustdocs/master/sp_api/macro.decl_runtime_apis.html"><code>decl_runtime_apis!</code> macro</a>. This macro allows the outer node to query the runtime API at specific blocks. Although this runtime API only provides a single function, you may write as many as you like.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>sp_api::decl_runtime_apis! {
	pub trait SumStorageApi {
		fn get_sum() -&gt; u32;
	}
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#implementing-the-api" id="implementing-the-api">Implementing the API</a></h2>
<p>With our pallet written and our runtime API defined, we may now implement the API for our runtime. This happens in the main runtime aggregation file. In our case we've provided the <code>api-runtime</code> in <code>runtimes/api-runtime/src/lib.rs</code>.</p>
<p>As with defining the API, implementing a runtime API looks similar to implementing any old Rust trait with the exception that the implementation must go inside of the <a href="https://substrate.dev/rustdocs/master/sp_api/macro.impl_runtime_apis.html"><code>impl_runtime_apis!</code> macro</a>. Every runtime must use <code>iml_runtime_apis!</code> because the <a href="https://substrate.dev/rustdocs/master/sp_api/trait.Core.html"><code>Core</code> API</a> is required. We will add an implementation for our own API alongside the others in this macro. Our implementation is straight-forward as it merely calls the pallet's helper function that we wrote previously.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl_runtime_apis! {
  // --snip--

  impl sum_storage_rpc_runtime_api::SumStorageApi&lt;Block&gt; for Runtime {
		fn get_sum() -&gt; u32 {
			SumStorage::get_sum()
		}
	}
}
<span class="boring">}
</span></code></pre></pre>
<p>You may be wondering about the <code>Block</code> type parameter which is present here, but not in our definition. This type parameter is added by the macros along with a few other features. All runtime APIs have this type parameter to facilitate querying the runtime at arbitrary blocks. Read more about this in the docs for <a href="https://substrate.dev/rustdocs/master/sp_api/macro.impl_runtime_apis.html"><code>impl_runtime_apis!</code></a>.</p>
<h2><a class="header" href="#calling-the-runtime-api" id="calling-the-runtime-api">Calling the Runtime API</a></h2>
<p>We've now successfully added a runtime API to our runtime. The outer node can now call this API to query the runtime for the sum of two storage values. Given a reference to a <a href="https://substrate.dev/rustdocs/master/sc_client/struct.Client.html">'client'</a> we can make the call like this.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let sum_at_block_fifty = client.runtime_api().get_sum(&amp;50);
<span class="boring">}
</span></code></pre></pre>
<p>This recipe was about defining and implementing a custom runtime API. To see an example of calling this API in practice, see the recipe on <a href="3-entrees/./custom-rpc.html">custom RPCs</a>, where we connect this runtime API to an RPC that can be called by an end user.</p>
<h1><a class="header" href="#custom-rpcs" id="custom-rpcs">Custom RPCs</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/nodes/rpc-node"><code>nodes/rpc-node</code></a></em>
<em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/runtimes/api-runtime"><code>runtime/api-runtime</code></a></em></p>
<p>Remote Procedure Calls, or RPCs, are a way for an external program (eg. a frontend) to communicate with a Substrate node. They are used for checking storage values, submitting transactions, and querying the current consensus authorities. Substrate comes with several <a href="https://polkadot.js.org/api/substrate/rpc.html">default RPCs</a>. In many cases it is useful to add custom RPCs to your node. In this recipe, we will add two custom RPCs to our node, one of which calls into a <a href="3-entrees/./runtime-api.html">custom runtime API</a>.</p>
<h2><a class="header" href="#defining-an-rpc" id="defining-an-rpc">Defining an RPC</a></h2>
<p>Every RPC that the node will use must be defined in a trait. We'll begin by defining a simple RPC
called &quot;silly rpc&quot; which just returns constant integers. A Hello world of sorts. In the <code>nodes/rpc-node/src/silly_rpc.rs</code> file, we define a basic rpc as</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[rpc]
pub trait SillyRpc {
	#[rpc(name = &quot;silly_seven&quot;)]
	fn silly_7(&amp;self) -&gt; Result&lt;u64&gt;;

	#[rpc(name = &quot;silly_double&quot;)]
	fn silly_double(&amp;self, val: u64) -&gt; Result&lt;u64&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>This definition defines two RPC methods called <code>hello_five</code> and <code>hello_seven</code>. Each RPC method must take a <code>&amp;self</code> reference and must return a <code>Result</code>. Next, we define a struct that implements this trait.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub struct Silly;

impl SillyRpc for Silly {
	fn silly_7(&amp;self) -&gt; Result&lt;u64&gt; {
		Ok(7)
	}

	fn silly_double(&amp;self, val: u64) -&gt; Result&lt;u64&gt; {
		Ok(2 * val)
	}
}
<span class="boring">}
</span></code></pre></pre>
<p>Finally, to make the contents of this new file usable, we need to add a line in our <code>main.rs</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>mod silly_rpc;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#including-the-rpc" id="including-the-rpc">Including the RPC</a></h2>
<p>With our RPC written, we're ready to install it on our node. We begin with a few dependencies in our <code>rpc-node</code>'s <code>Cargo.toml</code>.</p>
<pre><code class="language-toml">jsonrpc-core = &quot;14.0.3&quot;
jsonrpc-core-client = &quot;14.0.3&quot;
jsonrpc-derive = &quot;14.0.3&quot;
sc-rpc = { version = '2.0.0-alpha.7' }
</code></pre>
<p>Next, in our <code>rpc-node</code>'s <code>service.rs</code> file, we extend the service with our RPC. We've chosen to install this RPC for full nodes, so we've included the code in the <code>new_full_start!</code> macro. You could also install the RPC on a light client by making the corresponding changes to <code>new_light</code>.</p>
<p>The first change to this macro is a simple type definition</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>type RpcExtension = jsonrpc_core::IoHandler&lt;sc_rpc::Metadata&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>Then, once you've called the service builder, you can extend it with an RPC by using its <code>with_rpc_extensions</code> method as follows.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>.with_rpc_extensions(|builder| -&gt; Result&lt;RpcExtension, _&gt; {
	// Make an io handler to be extended with individual RPCs
	let mut io = jsonrpc_core::IoHandler::default();

	// Use the fully qualified name starting from `crate` because we're in macro_rules!
	io.extend_with(crate::silly_rpc::SillyRpc::to_delegate(crate::silly_rpc::Silly{}));

	// --snip--

	Ok(io)
})
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#calling-the-rpc" id="calling-the-rpc">Calling the RPC</a></h2>
<p>Once your node is running, you can test the RPC by calling it with any client that speaks json RPC. One widely available option <code>curl</code>.</p>
<pre><code class="language-bash">$ curl http://localhost:9933 -H &quot;Content-Type:application/json;charset=utf-8&quot; -d   '{
     &quot;jsonrpc&quot;:&quot;2.0&quot;,
      &quot;id&quot;:1,
      &quot;method&quot;:&quot;silly_seven&quot;,
      &quot;params&quot;: []
    }'
</code></pre>
<p>To which the RPC responds</p>
<pre><code>{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;:7,&quot;id&quot;:1}
</code></pre>
<p>You may have noticed that our second RPC takes a parameter, the value to double. You can supply this parameter by including its in the  <code>params</code> list. For example:</p>
<pre><code class="language-bash">$ curl http://localhost:9933 -H &quot;Content-Type:application/json;charset=utf-8&quot; -d   '{
     &quot;jsonrpc&quot;:&quot;2.0&quot;,
      &quot;id&quot;:1,
      &quot;method&quot;:&quot;silly_double&quot;,
      &quot;params&quot;: [7]
    }'
</code></pre>
<p>To which the RPC responds with the doubled parameter</p>
<pre><code>{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;:14,&quot;id&quot;:1}
</code></pre>
<h2><a class="header" href="#rpc-to-call-a-runtime-api" id="rpc-to-call-a-runtime-api">RPC to Call a Runtime API</a></h2>
<p>The silly RPC demonstrates the fundamentals of working with RPCs in Substrate. Nonetheless, most RPCs will go beyond what we've learned so far, and actually interact with other parts of the node. In this second example, we will include an RPC that calls into the <code>sum-storage</code> runtime API from the <a href="3-entrees/./runtime-api.html">runtime API recipe</a>. While it isn't strictly necessary to understand what the runtime API does, reading that recipe may provide helpful context.</p>
<p>Because this RPC's behavior is closely related to a specific pallet, we've chosen to define the RPC in the pallet's directory. In this case the RPC is defined in <code>pallets/sum-storage/rpc</code>. So rather than using the <code>mod</code> keyword as we did before, we must include this RPC definition in the node's <code>Cargo.toml</code> file.</p>
<pre><code class="language-toml">sum-storage-rpc = { path = &quot;../../pallets/sum-storage/rpc&quot; }
</code></pre>
<p>Defining the RPC interface is similar to before, but there are a few differences worth noting. First, the struct that implements the RPC needs a reference to the <code>client</code>. This is necessary so we can actually call into the runtime. Second the struct is generic over the <code>BlockHash</code> type. This is because it will call a runtime API, and runtime APIs must always be called at a specific block.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[rpc]
pub trait SumStorageApi&lt;BlockHash&gt; {
	#[rpc(name = &quot;sumStorage_getSum&quot;)]
	fn get_sum(
		&amp;self,
		at: Option&lt;BlockHash&gt;
	) -&gt; Result&lt;u32&gt;;
}

/// A struct that implements the `SumStorageApi`.
pub struct SumStorage&lt;C, M&gt; {
	client: Arc&lt;C&gt;,
	_marker: std::marker::PhantomData&lt;M&gt;,
}

impl&lt;C, M&gt; SumStorage&lt;C, M&gt; {
	/// Create new `SumStorage` instance with the given reference to the client.
	pub fn new(client: Arc&lt;C&gt;) -&gt; Self {
		Self { client, _marker: Default::default() }
	}
}
<span class="boring">}
</span></code></pre></pre>
<p>The RPC's implementation is also similar to before. The additional syntax here is related to calling the runtime at a specific block, as well as ensuring that the runtime we're calling actually has the correct runtime API available.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl&lt;C, Block&gt; SumStorageApi&lt;&lt;Block as BlockT&gt;::Hash&gt;
	for SumStorage&lt;C, Block&gt;
where
	Block: BlockT,
	C: Send + Sync + 'static,
	C: ProvideRuntimeApi,
	C: HeaderBackend&lt;Block&gt;,
	C::Api: SumStorageRuntimeApi&lt;Block&gt;,
{
	fn get_sum(
		&amp;self,
		at: Option&lt;&lt;Block as BlockT&gt;::Hash&gt;
	) -&gt; Result&lt;u32&gt; {

		let api = self.client.runtime_api();
		let at = BlockId::hash(at.unwrap_or_else(||
			// If the block hash is not supplied assume the best block.
			self.client.info().best_hash
		));

		let runtime_api_result = api.get_sum(&amp;at);
		runtime_api_result.map_err(|e| RpcError {
			code: ErrorCode::ServerError(9876), // No real reason for this value
			message: &quot;Something wrong&quot;.into(),
			data: Some(format!(&quot;{:?}&quot;, e).into()),
		})
	}
}
<span class="boring">}
</span></code></pre></pre>
<p>Finally, to install this RPC on in our service, we expand the existing <code>with_rpc_extensions</code> call to</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>.with_rpc_extensions(|builder| -&gt; Result&lt;RpcExtension, _&gt; {
	// Make an io handler to be extended with individual RPCs
	let mut io = jsonrpc_core::IoHandler::default();

	// Add the first rpc extension
	io.extend_with(crate::silly_rpc::SillyRpc::to_delegate(crate::silly_rpc::Silly{}));

	// Add the second RPC extension
	// Because this one calls a Runtime API it needs a reference to the client.
	io.extend_with(sum_storage_rpc::SumStorageApi::to_delegate(sum_storage_rpc::SumStorage::new(builder.client().clone())));

	Ok(io)
})?;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#optional-rpc-parameters" id="optional-rpc-parameters">Optional RPC Parameters</a></h2>
<p>This RPC takes a parameter ,<code>at</code>, whose type is <code>Option&lt;_&gt;</code>. We may call this RPC by omitting the optional parameter entirely. In this case the implementation provides a default value of the best block.</p>
<pre><code class="language-bash">$ curl http://localhost:9933 -H &quot;Content-Type:application/json;charset=utf-8&quot; -d   '{
     &quot;jsonrpc&quot;:&quot;2.0&quot;,
      &quot;id&quot;:1,
      &quot;method&quot;:&quot;sumStorage_getSum&quot;,
      &quot;params&quot;: []
    }'
</code></pre>
<p>We may also call the RPC by providing a block hash. One easy way to get a block hash to test this call is by copying it from the logs of a running node.</p>
<pre><code class="language-bash">$ curl http://localhost:9933 -H &quot;Content-Type:application/json;charset=utf-8&quot; -d   '{
     &quot;jsonrpc&quot;:&quot;2.0&quot;,
      &quot;id&quot;:1,
      &quot;method&quot;:&quot;sumStorage_getSum&quot;,
      &quot;params&quot;: [&quot;0x87b2e4b93e74d2f06a0bde8de78c9e2a9823ce559eb5e3c4710de40a1c1071ac&quot;]
    }'
</code></pre>
<p>As an exercise, you should change the storage values, and confirm that the RPC provides the correct updated sum. Then call the RPC at an old block and confirm you get the old sum.</p>
<h2><a class="header" href="#polkadot-js-api" id="polkadot-js-api">Polkadot JS API</a></h2>
<p>Many frontends interact with Substrate nodes through Polkadot JS API. While the recipes does not strive to document that project, we have included a snippet of javascript for interacting with these custom RPCs in the <code>nodes/rpc-node/js</code> directory.</p>
<h1><a class="header" href="#sha3-proof-of-work-algorithms" id="sha3-proof-of-work-algorithms">Sha3 Proof of Work Algorithms</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/consensus/sha3pow"><code>consensus/sha3pow</code></a></em></p>
<p><a href="https://en.wikipedia.org/wiki/Proof_of_work">Proof of Work</a> is not a single consensus algorithm. Rather it is a class of algorithms represented in Substrate by the <a href="https://substrate.dev/rustdocs/master/sc_consensus_pow/trait.PowAlgorithm.html"><code>PowAlgorithm</code> trait</a>. Before we can build a PoW node we must specify a concrete PoW algorithm by implementing this trait. In this recipe we specify two concrete PoW algorithms, both of which are based on the <a href="https://en.wikipedia.org/wiki/SHA-3">sha3 hashing algorithm</a>.</p>
<h2><a class="header" href="#minimal-sha3-pow" id="minimal-sha3-pow">Minimal Sha3 PoW</a></h2>
<p>First we turn our attention to a minimal working implementation. This consensus engine is kept intentionally simple. It omits some features that make Proof of Work practical for real-world use such as difficulty adjustment.</p>
<p>Begin by creating a struct that will implement the <code>PowAlgorithm Trait</code>.</p>
<pre><code class="language-rust ignore">/// A minimal PoW algorithm that uses Sha3 hashing.
/// Difficulty is fixed at 1_000_000
#[derive(Clone)]
pub struct MinimalSha3Algorithm;
</code></pre>
<p>Because this is a <em>minimal</em> PoW algorithm, our struct can also be quite simple. In fact, it is a <a href="https://doc.rust-lang.org/rust-by-example/custom_types/structs.html">unit struct</a>. A more complex PoW algorithm that interfaces with the runtime would need to hold a reference to the client. An example of this (on an older Substrate codebase) can be seen in <a href="https://github.com/kulupu/kulupu/">Kulupu</a>'s <a href="https://github.com/kulupu/kulupu/blob/3500b7f62fdf90be7608b2d813735a063ad1c458/pow/src/lib.rs#L137-L145">RandomXAlgorithm</a>.</p>
<h3><a class="header" href="#difficulty" id="difficulty">Difficulty</a></h3>
<p>The first function we must provide returns the difficulty of the next block to be mined. In our minimal sha3 algorithm, this function is quite simple. The difficulty is fixed. This means that as more mining power joins the network, the block time will become faster.</p>
<pre><code class="language-rust ignore">impl&lt;B: BlockT&lt;Hash=H256&gt;&gt; PowAlgorithm&lt;B&gt; for Sha3Algorithm {
	type Difficulty = U256;

	fn difficulty(&amp;self, _parent: &amp;BlockId&lt;B&gt;) -&gt; Result&lt;Self::Difficulty, Error&lt;B&gt;&gt; {
		// This basic PoW uses a fixed difficulty.
		// Raising this difficulty will make the block time slower.
		Ok(U256::from(1_000_000))
	}

	// --snip--
}
</code></pre>
<h3><a class="header" href="#verification" id="verification">Verification</a></h3>
<p>Our PoW algorithm must also be able to verify blocks provided by other authors. We are first given the pre-hash, which is a hash of the block before the proof of work seal is attached. We are also given the seal, which testifies that the work has been done, and the difficulty that the block author needed to meet. This function first confirms that the provided seal actually meets the target difficulty, then it confirms that the seal is actually valid for the given pre-hash.</p>
<pre><code class="language-rust ignore">fn verify(
	&amp;self,
	_parent: &amp;BlockId&lt;B&gt;,
	pre_hash: &amp;H256,
	seal: &amp;RawSeal,
	difficulty: Self::Difficulty
) -&gt; Result&lt;bool, Error&lt;B&gt;&gt; {
	// Try to construct a seal object by decoding the raw seal given
	let seal = match Seal::decode(&amp;mut &amp;seal[..]) {
		Ok(seal) =&gt; seal,
		Err(_) =&gt; return Ok(false),
	};

	// See whether the hash meets the difficulty requirement. If not, fail fast.
	if !hash_meets_difficulty(&amp;seal.work, difficulty) {
		return Ok(false)
	}

	// Make sure the provided work actually comes from the correct pre_hash
	let compute = Compute {
		difficulty,
		pre_hash: *pre_hash,
		nonce: seal.nonce,
	};

	if compute.compute() != seal {
		return Ok(false)
	}

	Ok(true)
}
</code></pre>
<h3><a class="header" href="#mining" id="mining">Mining</a></h3>
<p>Finally our proof of work algorithm needs to be able to mine blocks of our own.</p>
<pre><code class="language-rust ignore">fn mine(
	&amp;self,
	_parent: &amp;BlockId&lt;B&gt;,
	pre_hash: &amp;H256,
	difficulty: Self::Difficulty,
	round: u32 // The number of nonces to try during this call
) -&gt; Result&lt;Option&lt;RawSeal&gt;, Error&lt;B&gt;&gt; {
	// Get a randomness source from the environment; fail if one isn't available
	let mut rng = SmallRng::from_rng(&amp;mut thread_rng())
		.map_err(|e| Error::Environment(format!(&quot;Initialize RNG failed for mining: {:?}&quot;, e)))?;

	// Loop the specified number of times
	for _ in 0..round {

		// Choose a new nonce
		let nonce = H256::random_using(&amp;mut rng);

		// Calculate the seal
		let compute = Compute {
			difficulty,
			pre_hash: *pre_hash,
			nonce,
		};
		let seal = compute.compute();

		// If we solved the PoW then return, otherwise loop again
		if hash_meets_difficulty(&amp;seal.work, difficulty) {
			return Ok(Some(seal.encode()))
		}
	}

	// Tried the specified number of rounds and never found a solution
	Ok(None)
}
</code></pre>
<p>Notice that this function takes a parameter for the number of rounds of mining it should attempt. If no block has been successfully mined in this time, the method will return. This gives the service a chance to check whether any new blocks have been received from other authors since the mining started. If a valid block has been received, then we will start mining on it. If no such block has been received, we will go in for another try at mining on the same block as before.</p>
<h2><a class="header" href="#realistic-sha3-pow" id="realistic-sha3-pow">Realistic Sha3 PoW</a></h2>
<p>Having understood the fundamentals, we can now build a more realistic sha3 algorithm. The primary difference here is that this algorithm will fetch the difficulty from the runtime via a <a href="3-entrees/./runtime-api.html">runtime api</a>. This change allows the runtime to dynamically adjust the difficulty based on block time. So if more mining power joins the network, the diffculty adjusts, and the blocktime remains constant.</p>
<h3><a class="header" href="#defining-the-sha3algorithm-struct" id="defining-the-sha3algorithm-struct">Defining the <code>Sha3Algorithm</code> Struct</a></h3>
<p>We begin as before by defining a struct that will implement the <code>PowAlgorithm</code> trait. Unlike before, this struct must hold a reference to the <a href="https://substrate.dev/rustdocs/master/sc_client/struct.Client.html"><code>Client</code></a> so it can call the appropriate runtime APIs.</p>
<pre><code class="language-rust ignore">/// A complete PoW Algorithm that uses Sha3 hashing.
/// Needs a reference to the client so it can grab the difficulty from the runtime.
pub struct Sha3Algorithm&lt;C&gt; {
	client: Arc&lt;C&gt;,
}
</code></pre>
<p>Next we provide a <code>new</code> method for conveniently creating instances of our new struct.</p>
<pre><code class="language-rust ignore">impl&lt;C&gt; Sha3Algorithm&lt;C&gt; {
	pub fn new(client: Arc&lt;C&gt;) -&gt; Self {
		Self { client }
	}
}
</code></pre>
<p>And finally we manually implement <code>Clone</code>. We cannot derive clone as we did for the <code>MinimalSha3Algorithm</code>.</p>
<pre><code class="language-rust ignore">// Manually implement clone. Deriving doesn't work because
// it'll derive impl&lt;C: Clone&gt; Clone for Sha3Algorithm&lt;C&gt;. But C in practice isn't Clone.
impl&lt;C&gt; Clone for Sha3Algorithm&lt;C&gt; {
	fn clone(&amp;self) -&gt; Self {
		Self::new(self.client.clone())
	}
}
</code></pre>
<blockquote>
<p>It isn't critical to understand <em>why</em> the manual <code>Clone</code> implementation is necessary, just that it is necessary.</p>
</blockquote>
<h3><a class="header" href="#implementing-the-powalgorithm-trait" id="implementing-the-powalgorithm-trait">Implementing the <code>PowAlgorithm</code> trait</a></h3>
<p>As before we implement the <code>PowAlgorithm</code> trait for out <code>Sha3Algorithm</code>. This time we supply more complex trait bounds to ensure that the client the algorithm holds a reference to actually provides the <a href="https://substrate.dev/rustdocs/master/sp_consensus_pow/trait.DifficultyApi.html"><code>DifficultyAPI</code></a> necessary to fetch the PoW difficulty from the runtime.</p>
<pre><code class="language-rust ignore">// Here we implement the general PowAlgorithm trait for our concrete Sha3Algorithm
impl&lt;B: BlockT&lt;Hash=H256&gt;, C&gt; PowAlgorithm&lt;B&gt; for Sha3Algorithm&lt;C&gt; where
	C: ProvideRuntimeApi&lt;B&gt;,
	C::Api: DifficultyApi&lt;B, U256&gt;,
{
	type Difficulty = U256;

	// --snip
}
</code></pre>
<h3><a class="header" href="#difficulty-1" id="difficulty-1">Difficulty</a></h3>
<p>The implementation of <code>PowAlgorithm</code>'s <code>difficulty</code> function, no longer returns a fxed value, but rather calls into the runtime API which is guaranteed to exist because of the trait bounds. It also maps any errors that may have occurred when using the API.</p>
<pre><code class="language-rust ignore">fn difficulty(&amp;self, parent: B::Hash) -&gt; Result&lt;Self::Difficulty, Error&lt;B&gt;&gt; {
	let parent_id = BlockId::&lt;B&gt;::hash(parent);
	self.client.runtime_api().difficulty(&amp;parent_id)
		.map_err(|e| sc_consensus_pow::Error::Environment(
			format!(&quot;Fetching difficulty from runtime failed: {:?}&quot;, e)
		))
}
</code></pre>
<h3><a class="header" href="#verify-and-mine" id="verify-and-mine">Verify and Mine</a></h3>
<p>The <code>verify</code> and <code>mine</code> functions are unchanged from the <code>MinimalSha3Algorithm</code> implementation.</p>
<h1><a class="header" href="#basic-proof-of-work" id="basic-proof-of-work">Basic Proof of Work</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/nodes/basic-pow"><code>nodes/basic-pow</code></a></em></p>
<p>The <code>basic-pow</code> node demonstrates how wire a custom consensus engine into the Substrate Service. It uses a minimal proof of work consensus engine to reach agreement over the blockchain. It will teach us many useful aspects of dealing with consensus and prepare us to understand more advanced consensus engines in the future. In particular we will learn about:</p>
<ul>
<li>Substrate's <a href="https://substrate.dev/rustdocs/master/sp_consensus/block_import/trait.BlockImport.html"><code>BlockImport</code> trait</a></li>
<li>Substrate's <a href="https://substrate.dev/rustdocs/master/sp_consensus/import_queue/index.html">import pipeline</a></li>
<li>Structure of a typical <a href="https://substrate.dev/rustdocs/master/sc_service/index.html">Substrate Service</a></li>
<li>Configuration of <a href="https://substrate.dev/rustdocs/master/sp_authorship/struct.InherentDataProvider.html"><code>InherentDataProvider</code></a>s</li>
</ul>
<h2><a class="header" href="#the-structure-of-a-node" id="the-structure-of-a-node">The Structure of a Node</a></h2>
<p>You may remember from the <a href="3-entrees/../2-appetizers/1-hello-substrate.html">hello-substrate recipe</a> that a Substrate node has two parts. An outer part that is responsible for gossiping transactions and blocks, handling <a href="3-entrees/./custom-rpc.html">rpc requests</a>, and reaching consensus. And a runtime that is responsible for the business logic of the chain. This architecture diagram illustrates the distinction.</p>
<p><img src="3-entrees/../img/substrate-architecture.png" alt="Substrate Architecture Diagram" /></p>
<p>In principle the consensus engine, part of the outer node, is agnostic over the runtime that is used with it. But in practice, most consensus engines will require the runtime to provide certain <a href="3-entrees/./runtime-api.html">runtime APIs</a> that affect the engine. For example, Aura and Babe query the runtime for the set of validators. A more real-world PoW consensus would query the runtime for the block difficulty. Additionally, some runtimes rely on the consensus engine to provide <a href="https://substrate.dev/rustdocs/master/sp_runtime/generic/enum.DigestItem.html#variant.PreRuntime">pre-runtime digests</a>. For example, runtimes that include the Babe pallet expect a pre-runtime digest containing information about the current babe slot.</p>
<p>In this recipe we will avoid those practical complexities by using the <a href="3-entrees/./sha3-pow-consensus.html">Minimal Sha3 Proof of Work</a> consensus engine, and a dedicated <code>pow-runtime</code> which are truly isolated from each other. The contents of the runtime should be familiar, and will not be discussed here.</p>
<h2><a class="header" href="#the-service-builder" id="the-service-builder">The Service Builder</a></h2>
<p>The <a href="https://substrate.dev/rustdocs/master/sc_service/trait.AbstractService.html">Substrate Service</a> is the main coordinator of the various parts of a Substrate node, including consensus. The service is large and takes many parameters, so it is built with a <a href="https://substrate.dev/rustdocs/master/sc_service/struct.ServiceBuilder.html">ServiceBuilder</a> following <a href="https://doc.rust-lang.org/1.0.0/style/ownership/builders.html">Rust's builder pattern</a>. This code is demonstrated in the nodes <code>src/service.rs</code> file.</p>
<p>The particular builder method that is relevant here is <a href="https://substrate.dev/rustdocs/master/sc_service/struct.ServiceBuilder.html#method.with_import_queue"><code>with_import_queue</code></a>. Here we construct an instance of the <a href="https://substrate.dev/rustdocs/master/sc_consensus_pow/struct.PowBlockImport.html"><code>PowBlockImport</code> struct</a>, providing it with references to our client, our <code>MinimalSha3Algorithm</code>, and some other necessary data.</p>
<pre><code class="language-rust ignore">builder
	.with_import_queue(|_config, client, select_chain, _transaction_pool| {

		let pow_block_import = sc_consensus_pow::PowBlockImport::new(
			client.clone(),
			client.clone(),
			sha3pow::Sha3Algorithm,
			0, // check inherents starting at block 0
			select_chain,
			inherent_data_providers.clone(),
		);

		let import_queue = sc_consensus_pow::import_queue(
			Box::new(pow_block_import.clone()),
			sha3pow::Sha3Algorithm,
			inherent_data_providers.clone(),
		)?;

		import_setup = Some(pow_block_import);

		Ok(import_queue)
	})?;
</code></pre>
<p>Once the <code>PowBlockImport</code> is constructed, we can use it to create an actual import queue that the service will use for importing blocks into the client.</p>
<h3><a class="header" href="#the-block-import-pipeline" id="the-block-import-pipeline">The Block Import Pipeline</a></h3>
<p>You may have noticed that when we created the <code>PowBlockImport</code> we gave it two separate references to the client. The second reference will always be to a client. But the first is interesting. The <a href="https://substrate.dev/rustdocs/master/sc_consensus_pow/struct.PowBlockImport.html#method.new">rustdocs tell us</a> that the first parameter is <code>inner: BlockImport&lt;B, Transaction = TransactionFor&lt;C, B&gt;&gt;</code>. Why would a block import have a reference to another block import? Because the &quot;block import pipeline&quot; is constructed in an onion-like fashion, where one layer of block import wraps the next. In this minimal PoW node, there is only one layer to the onion. But in other nodes, including our own kitchen node, there are two layers: one for babe and one for grandpa.</p>
<h3><a class="header" href="#inherent-data-providers" id="inherent-data-providers">Inherent Data Providers</a></h3>
<p>Both the BlockImport and the <code>import_queue</code> are given an instance called <code>inherent_data_providers</code>. This object is created in a helper function defined at the beginning of <code>service.rs</code></p>
<pre><code class="language-rust ignore">pub fn build_inherent_data_providers() -&gt; Result&lt;InherentDataProviders, ServiceError&gt; {
	let providers = InherentDataProviders::new();

	providers
		.register_provider(sp_timestamp::InherentDataProvider)
		.map_err(Into::into)
		.map_err(sp_consensus::error::Error::InherentData)?;

	Ok(providers)
}
</code></pre>
<p>Anything that implements the <a href="https://substrate.dev/rustdocs/master/sp_inherents/trait.ProvideInherentData.html"><code>ProvideInherentData</code> trait</a> may be used here. The block authoring logic must supply all inherents that the runtime expects. In this case of this basic-pow chain, that is just the <a href="https://substrate.dev/rustdocs/master/sp_timestamp/trait.TimestampInherentData.html"><code>TimestampInherentData</code></a> expected by the <a href="https://substrate.dev/rustdocs/master/pallet_timestamp/index.html">timestamp pallet</a>. In order to register other inherents, you would call <code>register_provider</code> multiple times, and map errors accordingly.</p>
<h2><a class="header" href="#mining-1" id="mining-1">Mining</a></h2>
<p>We've already implemented a mining algorithm as part of our <a href="3-entrees/./sha3-pow-consensus.html"><code>MinimalSha3Algorithm</code></a>, but we haven't yet told our service to actually mine with that algorithm. This is our last task in the <code>new_full</code> function.</p>
<pre><code class="language-rust ignore">if participates_in_consensus {
	let proposer = sc_basic_authorship::ProposerFactory::new(
		service.client(),
		service.transaction_pool()
	);

	// The number of rounds of mining to try in a single call
	let rounds = 500;

	let client = service.client();
	let select_chain = service.select_chain()
		.ok_or(ServiceError::SelectChainRequired)?;

	let can_author_with =
		sp_consensus::CanAuthorWithNativeVersion::new(service.client().executor().clone());

	sc_consensus_pow::start_mine(
		Box::new(block_import),
		client,
		MinimalSha3Algorithm,
		proposer,
		None, // No preruntime digests
		rounds,
		service.network(),
		std::time::Duration::new(2, 0),
		Some(select_chain),
		inherent_data_providers.clone(),
		can_author_with,
	);
}
</code></pre>
<p>We begin by testing whether this node participates in consensus, which is to say we check whether the user wants the node to act as a miner. If this node is to be a miner, we gather references to various parts of the node that the <a href="https://substrate.dev/rustdocs/master/sc_consensus_pow/fn.start_mine.html"><code>start_mine</code> function</a> requires, and define that we will attempt 500 rounds of mining for each block before pausing. Finally we call <code>start_mine</code>.</p>
<h2><a class="header" href="#the-light-client" id="the-light-client">The Light Client</a></h2>
<p>The last thing in the <code>service.rs</code> file is constructing the <a href="https://www.parity.io/what-is-a-light-client/">light client</a>'s service. This code is quite similar to the construction of the full service.</p>
<p>Instead of using the <code>with_import_queue</code> function we used previously, we use the <code>with_import_queue_and_fprb</code> function. FPRB stand for <a href="https://substrate.dev/rustdocs/master/sc_network/config/trait.FinalityProofRequestBuilder.html"><code>FinalityProofRequestBuilder</code></a>. In chains with deterministic finality, light clients must request proofs of finality from full nodes. But in our chain, we do not have deterministic finality, so we can use the <a href="https://substrate.dev/rustdocs/master/sc_network/config/struct.DummyFinalityProofRequestBuilder.html"><code>DummyFinalityProofRequestBuilder</code></a> which does nothing except satisfying Rust's type checker.</p>
<p>Once the dummy request builder is configured, the <code>BlockImport</code> and import queue are configured exactly as they were in the full node.</p>
<h2><a class="header" href="#note-of-finality" id="note-of-finality">Note of Finality</a></h2>
<p>If we run the <code>basic-pow</code> node now, we see in console logs, that the finalized block always remains at 0.</p>
<pre><code>...
2020-03-22 12:50:09 Starting consensus session on top of parent 0x85811577d1033e918b425380222fd8c5aef980f81fa843d064d80fe027c79f5a
2020-03-22 12:50:09 Imported #189 (0x8581‚Ä¶9f5a)
2020-03-22 12:50:09 Prepared block for proposing at 190 [hash: 0xdd83ba96582acbed59aacd5304a9258962d1d4c2180acb8b77f725bd81461c4f; parent_hash: 0x8581‚Ä¶9f5a; extrinsics (1): [0x77a5‚Ä¶f7ad]]
2020-03-22 12:50:10 Idle (1 peers), best: #189 (0x8581‚Ä¶9f5a), finalized #0 (0xff0d‚Ä¶5cb9), ‚¨á 0.2kiB/s ‚¨Ü 0.4kiB/s
2020-03-22 12:50:15 Idle (1 peers), best: #189 (0x8581‚Ä¶9f5a), finalized #0 (0xff0d‚Ä¶5cb9), ‚¨á 0 ‚¨Ü 0
</code></pre>
<p>This is expected because Proof of Work is a consensus mechanism with probabilistic finality. This means a block is never truly finalized and can always be reverted. The further behind the blockchain head a block is, the less likely it is going to be reverted.</p>
<p>#Hybrid Consensus
<em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/nodes/hybrid-consensus"><code>nodes/hybrid-consensus</code></a></em></p>
<p>This recipe demonstrates a Substrate-based node that employs hybrid consensus. Specifically, it uses <a href="3-entrees/./sha3-pow-consensus.html">Sha3 Proof of Work</a> to dictate block authoring, and the <a href="https://substrate.dev/rustdocs/master/sc_finality_grandpa/index.html">Grandpa</a> finality gadget to provide <a href="https://www.substrate.io/kb/advanced/consensus#finality">deterministic finality</a>. The minimal proof of work consensus lives entirely outside of the runtime while the grandpa finality obtains its authorities from the runtime via the <a href="https://substrate.dev/rustdocs/master/sp_finality_grandpa/trait.GrandpaApi.html">GrandpaAPI</a></p>
<h2><a class="header" href="#the-block-import-pipeline-1" id="the-block-import-pipeline-1">The Block Import Pipeline</a></h2>
<p>Substrate's block import pipeline is structured like an onion in the sense that it is layered. A Substrate node can compose pieces of block import logic by wrapping block imports in other block imports. In this node we need to ensure that blocks are valid according to both Pow <em>and</em> grandpa. So we will construct a block import for each of them and wrap one with the other. The end of the block import pipeline is always the client, which contains the underlying datbase of imported blocks.</p>
<p>We begin by creating the block import for grandpa. In addition to the block import itself, we get back a <code>grandpa_link</code>. This link is a channel over which the block import can communicate with the background task that actually casts grandpa votes. The <a href="https://research.web3.foundation/en/latest/polkadot/GRANDPA.html">details of the grandpa protocol</a> are beyond the scope of this recipe.</p>
<pre><code class="language-rust ignore">let (grandpa_block_import, grandpa_link) =
	sc_finality_grandpa::block_import(
		client.clone(), &amp;(client.clone() as std::sync::Arc&lt;_&gt;), select_chain
	)?;
</code></pre>
<p>This same block import will be used as a justification import, so we clone it right after constructing it.</p>
<pre><code class="language-rust ignore">let justification_import = grandpa_block_import.clone();
</code></pre>
<p>With the grandpa block import created, we can now create the PoW block import. The Pow block import is the outer-most layer of the block import onion and it wraps the grandpa block import.</p>
<pre><code class="language-rust ignore">let pow_block_import = sc_consensus_pow::PowBlockImport::new(
	grandpa_block_import,
	client.clone(),
	sha3pow::MinimalSha3Algorithm,
	0, // check inherents starting at block 0
	Some(select_chain),
	inherent_data_providers.clone(),
);
</code></pre>
<h2><a class="header" href="#the-import-queue" id="the-import-queue">The Import Queue</a></h2>
<p>With the block imports setup, we can proceed to creating the import queue. We make it using PoW's <code>import_queue</code> helper function. Notice that it requires the entire block import pipeline which we refer to as <code>pow_block_import</code> because PoW is the outermost layer.</p>
<pre><code class="language-rust ignore">let import_queue = sc_consensus_pow::import_queue(
	Box::new(pow_block_import),
	Some(Box::new(justification_import)),
	None,
	sha3pow::MinimalSha3Algorithm,
	inherent_data_providers.clone(),
	spawn_task_handle,
)?;
</code></pre>
<h2><a class="header" href="#the-finality-proof-provider" id="the-finality-proof-provider">The Finality Proof Provider</a></h2>
<p>Occasionally in the operation of a blockchain, other nodes will contact our node asking for proof that a particular block is finalized. To respond to these requests, we include a finality proof provider.</p>
<pre><code class="language-rust ignore">.with_finality_proof_provider(|client, backend| {
	let provider = client as Arc&lt;dyn StorageAndProofProvider&lt;_, _&gt;&gt;;
	Ok(Arc::new(GrandpaFinalityProofProvider::new(backend, provider)) as _)
})?
</code></pre>
<h2><a class="header" href="#spawning-the-pow-authorship-task" id="spawning-the-pow-authorship-task">Spawning the PoW Authorship Task</a></h2>
<p>Any node that is acting as an authority, typically called &quot;miners&quot; in the PoW context, must run a mining task in another thread.</p>
<pre><code class="language-rust ignore">sc_consensus_pow::start_mine(
	Box::new(block_import),
	client,
	MinimalSha3Algorithm,
	proposer,
	None, // TODO Do I need some grandpa preruntime digests?
	500, // Rounds
	service.network(),
	std::time::Duration::new(2, 0),
	Some(select_chain),
	inherent_data_providers.clone(),
	can_author_with,
);
</code></pre>
<p>The use of a separate thread for block authorship is unlike other Substrate-based authorship tasks which are typically run as <code>async</code> futures. Because mining is a CPU intensive process, it is necessary to provide a separate thread or else the mining task would run continually and other tasks such as transaction processing, gossiping, and peer discovery would be starved for CPU.</p>
<h2><a class="header" href="#spawning-the-grandpa-task" id="spawning-the-grandpa-task">Spawning the Grandpa Task</a></h2>
<p>Grandpa is <em>not</em> CPU intensive, so we will use a standard <code>async</code> worker to listen to and cast grandpa votes. We begin by creating a grandpa <a href="https://substrate.dev/rustdocs/master/sc_finality_grandpa/struct.Config.html"><code>Config</code></a>.</p>
<pre><code class="language-rust ignore">let grandpa_config = sc_finality_grandpa::Config {
	gossip_duration: Duration::from_millis(333),
	justification_period: 512,
	name: Some(name),
	observer_enabled: false,
	keystore,
	is_authority: role.is_network_authority(),
};
</code></pre>
<p>We can then use this config to create an instance of <a href="https://substrate.dev/rustdocs/master/sc_finality_grandpa/struct.GrandpaParams.html"><code>GrandpaParams</code></a>.</p>
<pre><code class="language-rust ignore">let grandpa_config = sc_finality_grandpa::GrandpaParams {
	config: grandpa_config,
	link: grandpa_link,
	network: service.network(),
	inherent_data_providers: inherent_data_providers.clone(),
	telemetry_on_connect: Some(service.telemetry_on_connect_stream()),
	voting_rule: sc_finality_grandpa::VotingRulesBuilder::default().build(),
	prometheus_registry: service.prometheus_registry(),
};
</code></pre>
<p>With the parameters established, we can now create and spawn the authorship future.</p>
<pre><code class="language-rust ignore">service.spawn_essential_task(
	&quot;grandpa-voter&quot;,
	sc_finality_grandpa::run_grandpa_voter(grandpa_config)?
);
</code></pre>
<h3><a class="header" href="#disabled-grandpa" id="disabled-grandpa">Disabled Grandpa</a></h3>
<p>Proof of Authority networks generally contain many full nodes that are not authorities. When Grandpa is present in the network, we still need to tell the node how to interpret grandpa-related messages it may receive (just ignore them).</p>
<pre><code class="language-rust ignore">sc_finality_grandpa::setup_disabled_grandpa(
	service.client(),
	&amp;inherent_data_providers,
	service.network(),
)?;
</code></pre>
<h2><a class="header" href="#constraints-on-the-runtime" id="constraints-on-the-runtime">Constraints on the Runtime</a></h2>
<h3><a class="header" href="#runtime-apis-1" id="runtime-apis-1">Runtime APIs</a></h3>
<p>Grandpa relies on getting its authority sets from the runtime via the <a href="https://substrate.dev/rustdocs/master/sp_finality_grandpa/trait.GrandpaApi.html">GrandpaAPI</a>. So trying to build this node with a runtime that does not provide this API will fail to compile. For that reason, we have included the dedicated <code>minimal-grandpa-runtime</code>.</p>
<p>The opposite is not true, however. A node that does <em>not</em> require grandpa may use the <code>minimal-grandpa-runtime</code> successfully. The unused <code>GrandpaAPI</code> will remain as a harmless vestige in the runtime.</p>
<h1><a class="header" href="#manual-seal" id="manual-seal">Manual Seal</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/nodes/manual-seal"><code>nodes/manual-seal</code></a></em></p>
<p>This recipe demonstrates a Substrate node using the <a href="https://substrate.dev/rustdocs/master/sc_consensus_manual_seal/index.html">Manual Seal consensus</a>. Unlike the other consensus engines included with Substrate, manual seal does not create blocks on a regular basis. Rather, it waits for an RPC call telling to create a block.</p>
<h2><a class="header" href="#using-manual-seal" id="using-manual-seal">Using Manual Seal</a></h2>
<p>Before we explore the code, let's begin by seeing how to use the manual-seal node. Build and start the node in the usual way.</p>
<pre><code class="language-bash">cargo build --release -p manual-seal
./target/release/manual-seal
</code></pre>
<h2><a class="header" href="#manually-sealing-blocks" id="manually-sealing-blocks">Manually Sealing Blocks</a></h2>
<p>Once your node is running, you will see that it just sits there idly. It will accept transactions to the pool, but it will not author blocks on its own. In manual seal, the node does not author a block until we explicitly tell it to. We can tell it to author a block by calling the <code>engine_createBlock</code> RPC.</p>
<pre><code class="language-bash">$ curl http://localhost:9933 -H &quot;Content-Type:application/json;charset=utf-8&quot; -d   '{
     &quot;jsonrpc&quot;:&quot;2.0&quot;,
      &quot;id&quot;:1,
      &quot;method&quot;:&quot;engine_createBlock&quot;,
      &quot;params&quot;: [true, false, null]
    }'
</code></pre>
<p>This call takes three parameters, each of which are worth exploring.</p>
<h3><a class="header" href="#create-empty" id="create-empty">Create Empty</a></h3>
<p><code>create_empty</code> is a Boolean value indicating whether empty blocks may be created. Setting <code>create-empty</code> to true does not mean that an empty block will necessarily be created. Rather it means that the engine should go ahead creating a block even if no transaction are present. If transactions are present in the queue, they will be included regardless of <code>create_empty</code>'s value.'</p>
<h3><a class="header" href="#finalize" id="finalize">Finalize</a></h3>
<p><code>finalize</code> is a Boolean indicating whether the block (and its ancestors, recursively) should be finalized after creation. Manually controlling finality is interesting, but also dangerous. If you attempt to author and finalize a block that does not build on the best finalized chain, the block will not be imported. If you finalize one block in one node, and a conflicting block in another node, you will cause a safety violation when the nodes synchronize.</p>
<h3><a class="header" href="#parent-hash" id="parent-hash">Parent Hash</a></h3>
<p><code>parent_hash</code> is an optional hash of a block to use as a parent. To set the parent, use the format <code>&quot;0x0e0626477621754200486f323e3858cd5f28fcbe52c69b2581aecb622e384764&quot;</code>. To omit the parent, use <code>null</code>. When the parent is omitted the block is built on the current best block. Manually specifying the parent is useful for constructing fork scenarios and demonstrating chain reorganizations.</p>
<h2><a class="header" href="#manually-finalizing-blocks" id="manually-finalizing-blocks">Manually Finalizing Blocks</a></h2>
<p>In addition to finalizing blocks while creating them, they can be finalized later by using the second provided RPC call, <code>engine_finalizeBlock</code>.</p>
<pre><code class="language-bash">$ curl http://localhost:9933 -H &quot;Content-Type:application/json;charset=utf-8&quot; -d   '{
     &quot;jsonrpc&quot;:&quot;2.0&quot;,
      &quot;id&quot;:1,
      &quot;method&quot;:&quot;engine_finalizeBlock&quot;,
      &quot;params&quot;: [&quot;0x0e0626477621754200486f323e3858cd5f28fcbe52c69b2581aecb622e384764&quot;, null]
    }'
</code></pre>
<p>The two parameters are:</p>
<ul>
<li>The hash of the block to finalize.</li>
<li>A Justification. TODO what is the justification and why might I want to use it?</li>
</ul>
<h2><a class="header" href="#building-the-service" id="building-the-service">Building the Service</a></h2>
<p>So far we've learned how to use the manual seal node and why it might be useful. Let's now turn our attention to how the service is built in the nodes <code>src/service.rs</code> file.</p>
<h3><a class="header" href="#the-import-queue-1" id="the-import-queue-1">The Import Queue</a></h3>
<p>We begin by creating a manual-seal import queue. This process is identical to creating the import queue used in the <a href="3-entrees/./kitchen-node.html">Kitchen Node</a>. It is also similar to, but simpler than, the <a href="3-entrees/./basic-pow.html">basic-pow</a> import queue.</p>
<pre><code class="language-rust ignore">.with_import_queue(|_config, client, _select_chain, _transaction_pool| {
	Ok(sc_consensus_manual_seal::import_queue::&lt;_, sc_client_db::Backend&lt;_&gt;&gt;(Box::new(client)))
})?;
</code></pre>
<h3><a class="header" href="#what-about-the-light-client" id="what-about-the-light-client">What about the Light Client?</a></h3>
<p>The light client is not yet supported in this node, but it likely will be in the future (See <a href="https://github.com/substrate-developer-hub/recipes/pull/238">issue #238</a>.) Because it will typically be used for learning, experimenting, and testing in a single-node environment this restriction should not cause many problems.. Instead we mark it as <code>unimplemented!</code>.</p>
<pre><code class="language-rust ignore">/// Builds a new service for a light client.
pub fn new_light(_config: Configuration) -&gt; Result&lt;impl AbstractService, ServiceError&gt;
{
	unimplemented!(&quot;No light client for manual seal&quot;);

	// This needs to be here or it won't compile.
	#[allow(unreachable_code)]
	new_full(_config, false)
}
</code></pre>
<p>Because the return type of this function contains <code>impl AbstractService</code>, Rust's typechecker is unable to infer the concrete type. We give it a hand by calling <code>new_full</code> at the end, but don't worry, this code will never actually be executed. <code>unimplemented!</code> will panic first.</p>
<h3><a class="header" href="#the-manual-seal-rpc" id="the-manual-seal-rpc">The Manual Seal RPC</a></h3>
<p>Because the node runs in manual seal mode, we need to wire up the RPC commands that we explored earlier. This process is nearly identical to those described in the <a href="3-entrees/./custom-rpc.html">custom rpc recipe</a>.</p>
<p>As prep work, we make a type alias,</p>
<pre><code class="language-rust ignore">type RpcExtension = jsonrpc_core::IoHandler&lt;sc_rpc::Metadata&gt;;
</code></pre>
<p>Next we create a channel over which the rpc handler and the authorship task can communicate with one another. The RPC handler will send messages asking to create or finalize a block and the import queue will receive the message and do so.</p>
<pre><code class="language-rust ignore">// channel for the rpc handler to communicate with the authorship task.
let (command_sink, commands_stream) = futures::channel::mpsc::channel(1000);
</code></pre>
<pre><code class="language-rust ignore">let service = builder
	// manual-seal relies on receiving sealing requests aka EngineCommands over rpc.
	.with_rpc_extensions(|_| -&gt; Result&lt;RpcExtension, _&gt; {
		let mut io = jsonrpc_core::IoHandler::default();
		io.extend_with(
			// We provide the rpc handler with the sending end of the channel to allow the rpc
			// send EngineCommands to the background block authorship task.
			rpc::ManualSealApi::to_delegate(rpc::ManualSeal::new(command_sink)),
		);
		Ok(io)
	})?
	.build()?;
</code></pre>
<h3><a class="header" href="#the-authorship-task" id="the-authorship-task">The Authorship Task</a></h3>
<p>As with every authoring engine, manual seal needs to be run as an <code>async</code> authoring tasks. Here we provide the receiving end of the channel we created earlier.</p>
<pre><code class="language-rust ignore">// Background authorship future.
let authorship_future = manual_seal::run_manual_seal(
		Box::new(service.client()),
		proposer,
		service.client().clone(),
		service.transaction_pool().pool().clone(),
		commands_stream,
		service.select_chain().unwrap(),
		inherent_data_providers
	);
</code></pre>
<p>With the future created, we can now kick it off using the service's <a href="https://substrate.dev/rustdocs/master/sc_service/struct.Service.html#method.spawn_essential_task"><code>spawn_essential_task</code> method</a>.</p>
<pre><code class="language-rust ignore">// we spawn the future on a background thread managed by service.
service.spawn_essential_task(&quot;manual-seal&quot;, authorship_future);
</code></pre>
<h1><a class="header" href="#manual-seal-1" id="manual-seal-1">Manual Seal</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/nodes/kitchen-node"><code>nodes/kitchen-node</code></a></em></p>
<p>This recipe demonstrates a general purpose Substrate node that supports most of the recipes' runtimes, and uses <a href="https://substrate.dev/rustdocs/master/sc_consensus_manual_seal/index.html">Instant Seal consensus</a>.</p>
<p>The kitchen node serves as the first point of entry for most aspiring chefs when they first encounter the recipes. By default it builds with the super-runtime, but it can be used with most of the runtimes in the recipes. Changing the runtime is described below. It features the instant seal consensus which is perfect for testing and iterating on a runtime.</p>
<h2><a class="header" href="#installing-a-runtime" id="installing-a-runtime">Installing a Runtime</a></h2>
<h3><a class="header" href="#cargo-dependency" id="cargo-dependency">Cargo Dependency</a></h3>
<p>The <code>Cargo.toml</code> file specifies the runtime as a dependency. The file imports the super-runtime, and has dependencies on other runtimes commented out.</p>
<pre><code class="language-toml"># Common runtime configured with most Recipes pallets.
runtime = { package = &quot;super-runtime&quot;, path = &quot;../../runtimes/super-runtime&quot; }

# Runtime with custom weight and fee calculation.
# runtime = { package = &quot;weight-fee-runtime&quot;, path = &quot;../../runtimes/weight-fee-runtime&quot;}

# Runtime with off-chain worker enabled.
# To use this runtime, compile the node with `ocw` feature enabled,
#   `cargo build --release --features ocw`.
# runtime = { package = &quot;ocw-runtime&quot;, path = &quot;../../runtimes/ocw-runtime&quot; }

# Runtime with custom runtime-api (custom API only used in rpc-node)
#runtime = { package = &quot;api-runtime&quot;, path = &quot;../../runtimes/api-runtime&quot; }
</code></pre>
<p>Installing a different runtime in the node is just a matter of commenting out the super-runtime line, and enabling another one. Try the weight-fee runtime for example. Of course cargo will complain if you try to import two crates under the name <code>runtime</code>.</p>
<p>It is worth noting that this node does not work with <em>all</em> of the recipes' runtimes. In particular, it is not compatible with the babe-grandpa runtime. That runtime uses the babe pallet which requires a node that will include a special <a href="https://substrate.dev/rustdocs/master/sp_runtime/enum.DigestItem.html#variant.PreRuntime"><code>PreRuntime</code> <code>DigestItem</code></a>.</p>
<h3><a class="header" href="#building-a-service-with-the-runtime" id="building-a-service-with-the-runtime">Building a Service with the Runtime</a></h3>
<p>With a runtime of our choosing listed among our dependencies, we can provide the runtime to the <a href="https://substrate.dev/rustdocs/master/sc_service/struct.ServiceBuilder.html"><code>ServiceBuilder</code></a>. The <code>ServiceBuilder</code> is responsible for assembling all of the necessary pieces that a node will need, and creating a <a href="https://substrate.dev/rustdocs/master/sc_service/struct.Service.html"><code>Substrate Service</code></a> which will manage the communication between them.</p>
<p>We begin by invoking the <a href="https://substrate.dev/rustdocs/master/sc_executor/macro.native_executor_instance.html"><code>native_executor_instance!</code> macro</a>. This creates an executor which is responsible for executing transactions in  the runtime and determining whether to run the native of wasm version of the runtime.</p>
<pre><code class="language-rust_ignore">native_executor_instance!(
	pub Executor,
	runtime::api::dispatch,
	runtime::native_version,
);
</code></pre>
<p>Finally, we create a new <code>ServiceBuilder</code> for a full node. (The <code>$</code> in the syntax is because we are in a <a href="https://doc.rust-lang.org/book/ch19-06-macros.html">macro definition</a>.</p>
<pre><code class="language-rust ignore">let builder = sc_service::ServiceBuilder::new_full::&lt;
	runtime::opaque::Block, runtime::RuntimeApi, crate::service::Executor
&gt;($config)?
// --snip--
</code></pre>
<h2><a class="header" href="#instant-seal-consensus" id="instant-seal-consensus">Instant Seal Consensus</a></h2>
<p>The instant seal consensus engine, and its cousin the manual seal consensus engine, are both included in the same <a href="https://substrate.dev/rustdocs/master/sc_consensus_manual_seal/index.html"><code>sc-consensus-manual-seal</code> crate</a>. The recipes has a recipe dedicated to using <a href="3-entrees/./manual-seal.html">manual seal</a>. Instant seal is a very convenient tool for when you are developing or experimenting with a runtime. The consensus engine simply authors a new block whenever a new transaction is available in the queue. This is similar to <a href="https://www.trufflesuite.com/ganache">Truffle Suite's Ganache</a> in the Ethereum ecosystem, but without the UI.</p>
<h3><a class="header" href="#the-cargo-dependencies" id="the-cargo-dependencies">The Cargo Dependencies</a></h3>
<p>Installing the instant seal engine has two dependencies whereas the runtime had only one.</p>
<pre><code class="language-toml">sp-consensus = '0.8.0-alpha.7'
sc-consensus-manual-seal = '0.8.0-alpha.7'
</code></pre>
<p>The dependency on <code>sc-client-db</code> will become unnecessary once <a href="https://github.com/substrate-developer-hub/recipes/pull/238">issue #238</a> is merged.</p>
<h3><a class="header" href="#the-proposer" id="the-proposer">The Proposer</a></h3>
<p>We begin by creating a <a href="https://substrate.dev/rustdocs/master/sc_basic_authorship/struct.Proposer.html"><code>Proposer</code></a> which will be responsible for creating proposing blocks in the chain.</p>
<pre><code class="language-rust ignore">let proposer = sc_basic_authorship::ProposerFactory::new(
	service.client().clone(),
	service.transaction_pool(),
);
</code></pre>
<h3><a class="header" href="#the-import-queue-2" id="the-import-queue-2">The Import Queue</a></h3>
<p>Next we make a manual-seal import queue. This process is identical to creating the import queue used in the <a href="3-entrees/./manual-seal.html">Manual Seal Node</a>. It is also similar to, but simpler than, the <a href="3-entrees/./basic-pow.html">basic-pow</a> import queue.</p>
<pre><code class="language-rust ignore">.with_import_queue(|_config, client, _select_chain, _transaction_pool| {
	Ok(sc_consensus_manual_seal::import_queue::&lt;_, sc_client_db::Backend&lt;_&gt;&gt;(Box::new(client)))
})?;
</code></pre>
<h3><a class="header" href="#the-authorship-task-1" id="the-authorship-task-1">The Authorship Task</a></h3>
<p>As with every authoring engine, instant seal needs to be run as an <code>async</code> authoring task.</p>
<pre><code class="language-rust ignore">let authorship_future = sc_consensus_manual_seal::run_instant_seal(
	Box::new(service.client()),
	proposer,
	service.client().clone(),
	service.transaction_pool().pool().clone(),
	service.select_chain().ok_or(ServiceError::SelectChainRequired)?,
	inherent_data_providers
);
</code></pre>
<p>With the future created, we can now kick it off using the service's <a href="https://substrate.dev/rustdocs/master/sc_service/struct.Service.html#method.spawn_essential_task"><code>spawn_essential_task</code> method</a>.</p>
<pre><code class="language-rust ignore">service.spawn_essential_task(&quot;instant-seal&quot;, authorship_future);
</code></pre>
<h3><a class="header" href="#what-about-the-light-client-1" id="what-about-the-light-client-1">What about the Light Client?</a></h3>
<p>The light client is not yet supported in this node, but it likely will be in the future (See <a href="https://github.com/substrate-developer-hub/recipes/pull/238">issue #238</a>.) Because it will typically be used for learning, experimenting, and testing in a single-node environment this restriction should not cause many problems.. Instead we mark it as <code>unimplemented!</code>.</p>
<pre><code class="language-rust ignore">/// Builds a new service for a light client.
pub fn new_light(_config: Configuration) -&gt; Result&lt;impl AbstractService, ServiceError&gt;
{
	unimplemented!(&quot;No light client for manual seal&quot;);

	// This needs to be here or it won't compile.
	#[allow(unreachable_code)]
	new_full(_config, false)
}
</code></pre>
<h1><a class="header" href="#currency-types" id="currency-types">Currency Types</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/lockable-currency"><code>pallets/lockable-currency</code></a>, <a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/reservable-currency"><code>pallets/reservable-currency</code></a>, <a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/currency-imbalances"><code>pallets/currency-imbalances</code></a></em></p>
<h2><a class="header" href="#just-plain-currency" id="just-plain-currency">Just Plain Currency</a></h2>
<p>To use a balances type in the runtime, import the <a href="https://substrate.dev/rustdocs/master/frame_support/traits/trait.Currency.html"><code>Currency</code></a> trait from <code>frame_support</code>.</p>
<pre><code class="language-rust ignore">use support::traits::Currency;
</code></pre>
<p>The <code>Currency</code> trait provides an abstraction over a fungible assets system. To use such a fuingible asset from your pallet, include an associated type with the <code>Currency</code> trait bound in your pallet's configuration trait.</p>
<pre><code class="language-rust ignore">pub trait Trait: system::Trait {
	type Currency: Currency&lt;Self::AccountId&gt;;
}
</code></pre>
<p>Defining an associated type with this trait bound allows this pallet to access the provided methods of <a href="https://substrate.dev/rustdocs/master/frame_support/traits/trait.Currency.html"><code>Currency</code></a>. For example, it is straightforward to check the total issuance of the system:</p>
<pre><code class="language-rust ignore">// in decl_module block
T::Currency::total_issuance();
</code></pre>
<p>As promised, it is also possible to type alias a balances type for use in the runtime:</p>
<pre><code class="language-rust ignore">type BalanceOf&lt;T&gt; = &lt;&lt;T as Trait&gt;::Currency as Currency&lt;&lt;T as system::Trait&gt;::AccountId&gt;&gt;::Balance;
</code></pre>
<p>This new <code>BalanceOf&lt;T&gt;</code> type satisfies the type constraints of <code>Self::Balance</code> for the provided methods of <code>Currency</code>. This means that this type can be used for <a href="https://substrate.dev/rustdocs/master/frame_support/traits/trait.Currency.html#tymethod.transfer">transfer</a>, <a href="https://substrate.dev/rustdocs/master/frame_support/traits/trait.Currency.html#tymethod.deposit_into_existing">minting</a>, and much more.</p>
<h2><a class="header" href="#reservable-currency" id="reservable-currency">Reservable Currency</a></h2>
<p>Substrate's <a href="https://substrate.dev/rustdocs/master/pallet_treasury/index.html">Treasury pallet</a> uses the <code>Currency</code> type for bonding spending proposals. To reserve and unreserve balances for bonding, <code>treasury</code> uses the <a href="https://substrate.dev/rustdocs/master/frame_support/traits/trait.ReservableCurrency.html"><code>ReservableCurrency</code></a> trait. The import and associated type declaration follow convention</p>
<pre><code class="language-rust ignore">use frame_support::traits::{Currency, ReservableCurrency};

pub trait Trait: system::Trait {
	type Currency: Currency&lt;Self::AccountId&gt; + ReservableCurrency&lt;Self::AccountId&gt;;
}
</code></pre>
<p>To lock or unlock some quantity of funds, it is sufficient to invoke <code>reserve</code> and <code>unreserve</code> respectively</p>
<pre><code class="language-rust ignore">pub fn reserve_funds(origin, amount: BalanceOf&lt;T&gt;) -&gt; DispatchResult {
	let locker = ensure_signed(origin)?;

	T::Currency::reserve(&amp;locker, amount)
			.map_err(|_| &quot;locker can't afford to lock the amount requested&quot;)?;

	let now = &lt;system::Module&lt;T&gt;&gt;::block_number();

	Self::deposit_event(RawEvent::LockFunds(locker, amount, now));
	Ok(())
}
</code></pre>
<pre><code class="language-rust ignore">pub fn unreserve_funds(origin, amount: BalanceOf&lt;T&gt;) -&gt; DispatchResult {
	let unlocker = ensure_signed(origin)?;

	T::Currency::unreserve(&amp;unlocker, amount);
	// ReservableCurrency::unreserve does not fail (it will lock up as much as amount)

	let now = &lt;system::Module&lt;T&gt;&gt;::block_number();

	Self::deposit_event(RawEvent::UnlockFunds(unlocker, amount, now));
	Ok(())
}
</code></pre>
<h2><a class="header" href="#lockable-currency" id="lockable-currency">Lockable Currency</a></h2>
<p>Substrate's <a href="https://substrate.dev/rustdocs/master/pallet_staking/index.html">Staking pallet</a> similarly uses <a href="https://substrate.dev/rustdocs/master/frame_support/traits/trait.LockableCurrency.html"><code>LockableCurrency</code></a> trait for more nuanced handling of capital locking based on time increments. This type can be very useful in the context of economic systems that enforce accountability by collateralizing fungible resources. Import this trait in the usual way</p>
<pre><code class="language-rust ignore">use frame_support::traits::{LockIdentifier, LockableCurrency}
</code></pre>
<p>To use <code>LockableCurrency</code>, it is necessary to define a <a href="https://substrate.dev/rustdocs/master/frame_support/traits/type.LockIdentifier.html"><code>LockIdentifier</code></a>.</p>
<pre><code class="language-rust ignore">const EXAMPLE_ID: LockIdentifier = *b&quot;example &quot;;
</code></pre>
<p>By using this <code>EXAMPLE_ID</code>, it is straightforward to define logic within the runtime to schedule locking, unlocking, and extending existing locks.</p>
<pre><code class="language-rust ignore">fn lock_capital(origin, amount: BalanceOf&lt;T&gt;) -&gt; DispatchResult {
	let user = ensure_signed(origin)?;

	T::Currency::set_lock(
		EXAMPLE_ID,
		&amp;user,
		amount,
		WithdrawReasons::except(WithdrawReason::TransactionPayment),
	);

	Self::deposit_event(RawEvent::Locked(user, amount));
	Ok(())
}
</code></pre>
<h2><a class="header" href="#imbalances-1" id="imbalances-1">Imbalances</a></h2>
<p>Functions that alter balances return an object of the <a href="https://substrate.dev/rustdocs/master/frame_support/traits/trait.Imbalance.html"><code>Imbalance</code></a> type to express how much account balances have been altered in aggregate. This is useful in the context of state transitions that adjust the total supply of the <code>Currency</code> type in question.</p>
<p>To manage this supply adjustment, the <a href="https://substrate.dev/rustdocs/master/frame_support/traits/trait.OnUnbalanced.html"><code>OnUnbalanced</code></a> handler is often used. An example might look something like</p>
<pre><code class="language-rust ignore">pub fn reward_funds(origin, to_reward: T::AccountId, reward: BalanceOf&lt;T&gt;) {
	let _ = ensure_signed(origin)?;

	let mut total_imbalance = &lt;PositiveImbalanceOf&lt;T&gt;&gt;::zero();

	let r = T::Currency::deposit_into_existing(&amp;to_reward, reward).ok();
	total_imbalance.maybe_subsume(r);
	T::Reward::on_unbalanced(total_imbalance);

	let now = &lt;system::Module&lt;T&gt;&gt;::block_number();
	Self::deposit_event(RawEvent::RewardFunds(to_reward, reward, now));
}
</code></pre>
<h2><a class="header" href="#takeaway" id="takeaway">takeaway</a></h2>
<p>The way we represent value in the runtime dictates both the security and flexibility of the underlying transactional system. Likewise, it is convenient to be able to take advantage of Rust's <a href="https://blog.rust-lang.org/2015/05/11/traits.html">flexible trait system</a> when building systems intended to rethink how we exchange information and value üöÄ</p>
<h1><a class="header" href="#generating-randomness" id="generating-randomness">Generating Randomness</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/randomness/">pallets/randomness</a></em></p>
<p>Randomness is useful in computer programs for everything from gambling, to generating DNA for digital kitties, to selecting block authors. Randomness is hard to come by in deterministic computers as explained at <a href="https://www.random.org/randomness/">random.org</a>. This is particularly true in the context of a blockchain when all the nodes in the network must agree on the state of the chain. Some techniques have been developed to address this problem including <a href="https://github.com/randao/randao">RanDAO</a> and <a href="https://en.wikipedia.org/wiki/Verifiable_random_function">Verifiable Random Functions</a>. Substrate abstracts the implementation of a randomness source using the <a href="https://substrate.dev/rustdocs/master/frame_support/traits/trait.Randomness.html"><code>Randomness</code> trait</a>, and provides a few implementations. This recipe will demonstrate using the <code>Randomness</code> trait and two concrete implementations.</p>
<h2><a class="header" href="#disclaimer" id="disclaimer">Disclaimer</a></h2>
<p>All of the randomness sources described here have limitations on their usefulness and security. This recipe shows how to use these randomness sources and makes an effort to explain their trade-offs. However, the author of this recipe is a blockchain chef, <strong>not a trained cryptographer</strong>. It is your responsibility to understand the security implications of using any of the techniques described in this recipe, before putting them to use. When in doubt, consult a trustworthy cryptographer.</p>
<p>The resources linked at the end of this recipe may be helpful in assessing the security and limitations of these randomness sources.</p>
<h2><a class="header" href="#randomness-trait" id="randomness-trait">Randomness Trait</a></h2>
<p>The randomness trait provides two methods, <code>random_seed</code>, and <code>random</code>, both of which provide a pesudo-random value of the type specified in the traits type parameter.</p>
<h3><a class="header" href="#random_seed" id="random_seed"><code>random_seed</code></a></h3>
<p>The <code>random_seed</code> method takes no parameters and returns a random seed which changes once per block. If you call this method twice in the same block you will get the same result. This method is typically not as useful as its counterpart.</p>
<h3><a class="header" href="#random" id="random"><code>random</code></a></h3>
<p>The <code>random</code> method takes a byte array, <code>&amp;[u8]</code>, known as the subject, and uses the subject's bytes along with the random seed described in the previous section to calculate a final random value. Using a subject in this way allows pallet (or multiple pallets) to seek randomness in the same block and get different results. The subject does not add entropy or security to the generation process, it merely prevents each call from returning identical values.</p>
<p>Common values to use for a subject include:</p>
<ul>
<li>The block number</li>
<li>The caller's accountId</li>
<li>A Nonce</li>
<li>A pallet-specific identifier</li>
<li>A tuple containing several of the above</li>
</ul>
<p>To bring a randomness source into scope, we include it in our configuration trait with the appropriate trait bound. This pallet, being a demo, will use two different sources. Using multiple sources is not necessary in practice.</p>
<pre><code class="language-rust ignore">pub trait Trait: system::Trait {
	type Event: From&lt;Event&gt; + Into&lt;&lt;Self as system::Trait&gt;::Event&gt;;

	type CollectiveFlipRandomnessSource: Randomness&lt;H256&gt;;

	type BabeRandomnessSource: Randomness&lt;H256&gt;;
}
</code></pre>
<p>We've provided the <code>Output</code> type as <a href="https://substrate.dev/rustdocs/master/sp_core/struct.H256.html"><code>H256</code></a>.</p>
<h2><a class="header" href="#collective-coin-flipping" id="collective-coin-flipping">Collective Coin Flipping</a></h2>
<p>Substrate's <a href="https://substrate.dev/rustdocs/master/pallet_randomness_collective_flip/index.html">Randomness Collective Flip pallet</a> uses a safe mixing algorithm to generate randomness using the entropy of previous block hashes. Because it is dependent on previous blocks, it can take many blocks for the seed to change.</p>
<p>A naive randomness source based on block hashes would take the hash of the previous block and use it as a random seed. Such a technique has the significant disadvantage that the block author can preview the random seed, and choose to discard the block choosing a slightly modified block with a more desirable hash. This pallet is subject to similar manipulation by the previous 81 block authors rather than just the previous 1.</p>
<p>Calling the randomness source from rust code is straightforward.</p>
<pre><code class="language-rust ignore">let random_seed = T::CollectiveFlipRandomnessSource::random_seed();
let random_result = T::CollectiveFlipRandomnessSource::random(&amp;subject);
</code></pre>
<p>Although it may <em>seem</em> harmless, <strong>you should not hash the result</strong> of the randomness provided by the collective flip pallet. Secure hash functions satisfy the <a href="https://en.wikipedia.org/wiki/Avalanche_effect">Avalance effect</a> which means that each bit of input is equally likely to affect a given bit of the output. Hashing will negate the low-influence property provided by the pallet.</p>
<h2><a class="header" href="#babe-vrf-output" id="babe-vrf-output">Babe VRF Output</a></h2>
<p>Substrate's <a href="https://substrate.dev/rustdocs/master/pallet_babe/index.html">Babe pallet</a> which is primarily responsible for managing validator rotation in Babe consensus, also collects the VRF outputs that Babe validators publish to demonstrate that they are permitted to author a block. These VRF outputs can be used to provide a random seed.</p>
<p>Because we are accessing the randomness via the <code>Randomness</code> trait, the calls look the same as before.</p>
<pre><code class="language-rust ignore">let random_seed = T::BabeRandomnessSource::random_seed();
let random_result = T::BabeRandomnessSource::random(&amp;subject);
</code></pre>
<p>In production networks, Babe VRF output is preferable to Collective Flip. Collective Flip provides essentially no real security.</p>
<h2><a class="header" href="#down-the-rabbit-hole" id="down-the-rabbit-hole">Down the Rabbit Hole</a></h2>
<p>As mentioned previously, there are many tradeoffs and security concerns to be aware of when using these randomness sources. If you'd like to get into the research, here are some jumping off points.</p>
<ul>
<li><a href="https://github.com/paritytech/ink/issues/57">https://github.com/paritytech/ink/issues/57</a></li>
<li><a href="https://wiki.polkadot.network/docs/en/learn-randomness">https://wiki.polkadot.network/docs/en/learn-randomness</a></li>
<li><a href="http://www.cse.huji.ac.il/%7Enati/PAPERS/coll_coin_fl.pdf">http://www.cse.huji.ac.il/~nati/PAPERS/coll_coin_fl.pdf</a></li>
<li><a href="https://eccc.weizmann.ac.il/report/2018/140/">https://eccc.weizmann.ac.il/report/2018/140/</a></li>
</ul>
<h1><a class="header" href="#execution-schedule" id="execution-schedule">Execution Schedule</a></h1>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/execution-schedule"><code>pallets/execution-schedule</code></a></em></p>
<!-- TODO This content may need updated to match the actual pallet -->
<p>Blockchain-native mechanisms may use the block number as a proxy for time to schedule task execution. Although scheduled task execution through council governance is minimal in this example, it is not too hard to imagine tasks taking the form of subscription payments, grant payouts, or any other scheduled <em>task</em> execution.</p>
<p>This pallet demonstrates a permissioned task scheduler, in which members of a <code>council: Vec&lt;AccountId&gt;</code> can schedule tasks, which are stored in a vector in the runtime storage (<code>decl_storage</code>).</p>
<p>Members of the <code>council</code> vote on the tasks with <code>SignalQuota</code> voting power which is doled out equally to every member every <code>ExecutionFrequency</code> number of blocks.</p>
<p>Tasks with support are prioritized during execution every <code>ExecutionFrequency</code> number of blocks. More specifically, every <code>ExecutionFrequency</code> number of blocks, a maximum of <code>TaskLimit</code> number of tasks are executed. The priority of tasks is decided by the signalling of the council members.</p>
<p>The module's <code>Trait</code>:</p>
<pre><code class="language-rust ignore">// other type aliases
pub type PriorityScore = u32;

pub trait Trait: system::Trait {
    /// Overarching event type
    type Event: From&lt;Event&lt;Self&gt;&gt; + Into&lt;&lt;Self as system::Trait&gt;::Event&gt;;

    /// Quota for members to signal task priority every ExecutionFrequency
    type SignalQuota: Get&lt;PriorityScore&gt;;

    /// The frequency of batch executions for tasks (in `on_finalize`)
    type ExecutionFrequency: Get&lt;Self::BlockNumber&gt;;

    /// The maximum number of tasks that can be approved in an `ExecutionFrequency` period
    type TaskLimit: Get&lt;PriorityScore&gt;;
}
</code></pre>
<p>The task object is a struct,</p>
<pre><code class="language-rust ignore">pub type TaskId = Vec&lt;u8&gt;;
pub type PriorityScore = u32;

pub struct Task&lt;BlockNumber&gt; {
    id: TaskId,
    score: PriorityScore,
    proposed_at: BlockNumber,
}
</code></pre>
<p>The runtime method for proposing a task emits an event with the expected execution time. The calculation of the expected execution time was first naively to basically iterate the block number from the current block number until it was divisible by <code>T::ExecutionFrequency::get()</code>. While this is correct, it is clearly not the most efficient way to find the next block in which tasks are executed.</p>
<blockquote>
<p>A more complex engine for predicting task execution time may run off-chain instead of in a runtime method.</p>
</blockquote>
<p>Before adding a runtime method to estimate the <code>execution_time</code>, implement a naive implementation that iterates the global <code>BlockNumber</code> until it is divisible by <code>ExecutionFrequency</code> (which implies execution in <code>on_finalize</code> in this block).</p>
<pre><code class="language-rust ignore">fn naive_execution_estimate(now: T::BlockNumber) -&gt; T::BlockNumber {
    // the frequency with which tasks are batch executed
    let batch_frequency = T::ExecutionFrequency::get();
    let mut expected_execution_time = now;
    loop {
        // the expected execution time is the next block number divisible by `ExecutionFrequency`
        if (expected_execution_time % batch_frequency).is_zero() {
            break;
        } else {
            expected_execution_time += 1.into();
        }
    }
    expected_execution_time
}
</code></pre>
<p>This naive implementation unsurprisingly worked...</p>
<pre><code class="language-rust ignore">#[test]
fn naive_estimator_works() {
    // should use quickcheck to cover entire range of checks
    ExtBuilder::default()
        .execution_frequency(8)
        .build()
        .execute_with(|| {
            let current_block = 5u64;
            assert_eq!(
                ExecutionSchedule::naive_execution_estimate(current_block.into()),
                8u64.into()
            );
            let next_block = 67u64;
            assert_eq!(
                ExecutionSchedule::naive_execution_estimate(next_block.into()),
                72u64.into()
            );
        })
}
</code></pre>
<p>...but it is obvious that there is a better way. If execution is scheduled every constant <code>ExecutionFrequency</code> number of blocks, then it should be straightforward to calculate the next execution block without this slow iterate and check modulus method. My first attempt at a better implementation of <code>execution_estimate(n: T::BlockNumber) -&gt; T::BlockNumber</code> was</p>
<pre><code class="language-rust ignore">fn execution_estimate(n: T::BlockNumber) -&gt; T::BlockNumber {
        let batch_frequency = T::ExecutionFrequency::get();
        let miss = n % batch_frequency;
        (n + miss) - batch_frequency
    }
</code></pre>
<p>The above code failed the <code>estimator_works</code> unit test</p>
<pre><code class="language-rust ignore">#[test]
fn estimator_works() {
    ExtBuilder::default()
        .execution_frequency(8)
        .build()
        .execute_with(|| {
            assert_eq!(
                ExecutionSchedule::execution_estimate(current_block.into()),
                8u64.into()
            );
            assert_eq!(
                ExecutionSchedule::execution_estimate(next_block.into()),
                72u64.into()
            );
        })
}
</code></pre>
<p>The error helped me catch the logic mistake and change it to</p>
<pre><code class="language-rust ignore">fn execution_estimate(n: T::BlockNumber) -&gt; T::BlockNumber {
    let batch_frequency = T::ExecutionFrequency::get();
    let miss = n % batch_frequency;
    n + (batch_frequency - miss)
}
</code></pre>
<p>This makes more sense. Current block number <code>% T::ExecutionFrequency::get()</code> is, by definition of modulus, the number of blocks that the current block is past when tasks were last executed. To return the next block at which task execution is scheduled, the estimator adds the difference between <code>T::ExecutionFrequency::get()</code> and the modulus. This makes sense AND passes the <code>estimators_work()</code> test.</p>
<h2><a class="header" href="#on_initialize-updates-vote-data-and-round-information" id="on_initialize-updates-vote-data-and-round-information">on_initialize updates vote data and round information</a></h2>
<p>Each period of task proposals and voting is considered a round, expressed as <code>RoundIndex: u32</code> such that the global round is stored in the runtime storage as <code>Era</code>.</p>
<pre><code class="language-rust ignore">pub type RoundIndex = u32;

decl_storage! {
    trait Store for Module&lt;T: Trait&gt; as ExecutionSchedule {
        Era get(fn era): RoundIndex;
    }
}
</code></pre>
<p>This storage value acts as a global counter of the round, which is also used as the <code>prefix_key</code> of a <code>double_map</code> that tracks the member's remaining voting power in the <code>SignalBank</code> runtime storage item. This map and the round counter are updated in the <code>on_initialize</code> hook.</p>
<pre><code class="language-rust ignore">// in on_initialize
let last_era = &lt;Era&gt;::get();
&lt;SignalBank&lt;T&gt;&gt;::remove_prefix(&amp;last_era);
let next_era: RoundIndex = last_era + 1;
&lt;Era&gt;::put(next_era);
// see next code back
</code></pre>
<p>The <code>SignalBank</code> tracks the signalling power of each member of the <code>council</code>. By using a <code>double-map</code> with the prefix as the round number, it is straightforward to perform batch removal of state related to signalling in the previous round.</p>
<pre><code class="language-rust ignore">&lt;SignalBank&lt;T&gt;&gt;::remove_prefix(&amp;last_era);
</code></pre>
<p>In practice, this organization of logic uses something like a ring buffer; the <code>on_initialize</code> both batch deletes all signalling records from the previous round while, in the same code block, doling out an equal amount of voting power to all members for the next round.</p>
<pre><code class="language-rust ignore">// ...continuation of last code block
let signal_quota = T::SignalQuota::get();
&lt;Council&lt;T&gt;&gt;::get().into_iter().for_each(|member| {
    &lt;SignalBank&lt;T&gt;&gt;::insert(next_era, &amp;member, signal_quota);
});
</code></pre>
<p>The aforementioned ring buffer is maintained in the <code>on_initialize</code> block. The maintenance code is kept in an if statement that limits its invocation to blocks <code>x</code> that follow blocks <code>y</code> for which <code>y % ExecutionFrequency == 0</code>.</p>
<p>This is a common way of only exercising expensive batch execution functions every periodic number of blocks. Still, the second to last statement is confusing. The first time I encountered the problem, I placed the following in the <code>on_initialize</code> if statement that controls the maintenance of the <code>SignalBank</code> and <code>Era</code> storage values,</p>
<pre><code class="language-rust ignore">// in on_initialize(n: T::BlockNumber)
if (n % (T::ExecutionFrequency + 1.into())).is_zero() {
    //changing and repopulating of `Era` and `SignalBank`
}
</code></pre>
<p>I only noticed this mistake while testing whether eras progress as expected. Specifically, the following test failed</p>
<pre><code class="language-rust ignore">#[test]
    fn eras_change_correctly() {
    ExtBuilder::default()
        .execution_frequency(2)
        .build()
        .execute_with(|| {
            System::set_block_number(1);
            run_to_block(13);
            assert_eq!(ExecutionSchedule::era(), 6);
            run_to_block(32);
            assert_eq!(ExecutionSchedule::era(), 16);
        })
}
</code></pre>
<p>The test failed with an error message claiming that the first <code>assert_eq!</code> left side was 4 which does not equal 6. This error message caused me to inspect the if condition, which I realized should be changed to (the current implementation),</p>
<pre><code class="language-rust ignore">// in on_initialize(n: T::BlockNumber)
if ((n - 1.into()) % T::ExecutionFrequency).is_zero() {
    //changing and repopulating of `Era` and `SignalBank`
}
</code></pre>
<p>With this change, the <code>eras_change_correctly</code> test passes.</p>
<h2><a class="header" href="#on_finalize-execution-priority-a-name--prioritya" id="on_finalize-execution-priority-a-name--prioritya">on_finalize execution priority <a name = "priority"></a></a></h2>
<ul>
<li>
<p>this pattern of sorting the tasks in <code>on_finalize</code> is inspired by the <code>scored-pool</code> pallet which should be referenced</p>
</li>
<li>
<p>when we schedule and reprioritize elements in this way, order of execution becomes extremely important</p>
</li>
<li>
<p>we execute tasks in <code>on_finalize</code> when <code>n % T::ExecutionFrequency == 0</code>. I should ensure that n != 0 as well, but I assume this is the case. The limit is maximum <code>TaskLimit</code>.</p>
</li>
<li>
<p>An improvement would be to also ensure that their is some minimum amount of <code>score</code>. It would be nice to write abstractions that have a more native sense of the collective voting power of all members</p>
</li>
<li>
<p>this lends itself to a follow up off-chain workers example for how it fits between <code>on_finalize</code> of the last block and <code>on_initialize</code> of the next block <code>=&gt;</code> there is this whole <code>execution-schedule</code> :p</p>
</li>
</ul>
<h2><a class="header" href="#permissioned-methods" id="permissioned-methods">Permissioned Methods</a></h2>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/check-membership">pallets/check-membership</a></em></p>
<p>It is often useful to designate some functions as permissioned and, therefore, accessible only to a defined group. In this case, we check that the transaction that invokes the runtime function is signed before verifying that the signature corresponds to a member of the permissioned set.</p>
<p>To manage the set of members allowed to access the methods in question, we may store a vector in runtime storage. Without access to the standard library, it is necessary to use the <a href="https://substrate.dev/rustdocs/master/sp_std/vec/struct.Vec.html"><code>Vec</code> struct</a> from the <code>sp-std</code> crate.</p>
<pre><code class="language-rust ignore">use sp_std::vec::Vec;
</code></pre>
<p>In the runtime, the membership set can be stored as</p>
<pre><code class="language-rust ignore">decl_storage! {
	trait Store for Module&lt;T: Trait&gt; as PGeneric {
		Members get(fn members): Vec&lt;&amp;T::AccountId&gt;;
	}
}
</code></pre>
<h2><a class="header" href="#permissionless-membership" id="permissionless-membership">Permissionless Membership</a></h2>
<p>If the membership is permissionless such anyone can join, an <code>add_member</code> function could be expressed as follows</p>
<pre><code class="language-rust ignore">fn add_member(origin) -&gt; DispatchResult {
	let new_member = ensure_signed(origin)?;

	// Ensure that the caller is not already a member
	ensure!(!Self::is_member(&amp;new_member), &quot;already a member&quot;);

	&lt;Members&lt;T&gt;&gt;::append(&amp;new_member);
	Self::deposit_event(RawEvent::AddMember(new_member));
	Ok(())
}
</code></pre>
<p>Here we've used the <a href="https://substrate.dev/rustdocs/master/frame_support/storage/trait.StorageValue.html#tymethod.append"><code>append</code> method</a> to add the new member to the list. This allows a quick way to add data to the end of the vector without decoding the entire vector.</p>
<p>To increase the readability of the code, the membership check is extracted into its own auxiliary runtime method.</p>
<pre><code class="language-rust ignore">impl&lt;T: Trait&gt; Module&lt;T&gt; {
	pub fn is_member(who: &amp;T::AccountId) -&gt; bool {
		Self::members().contains(who)
	}
}
</code></pre>
<h1><a class="header" href="#testing-1" id="testing-1">Testing</a></h1>
<p>Although the Rust compiler ensures safe memory management, it cannot formally verify the correctness of a program's logic. Fortunately, Rust also comes with great libraries and documentation for writing unit and integration tests. When you initiate code with Cargo, test scaffolding is automatically generated to simplify the developer experience. Basic testing concepts and syntax are covered in depth in <a href="https://doc.rust-lang.org/book/ch11-00-testing.html">Chapter 11 of the Rust Book</a>.</p>
<ul>
<li><a href="3-entrees/testing/./mock.html">Basic Test Environments</a></li>
<li><a href="3-entrees/testing/./common.html">Common Tests</a></li>
<li><a href="3-entrees/testing/./off-chain-workers.html">Off-chain Worker Test Environment</a></li>
<li><a href="3-entrees/testing/./externalities.html">Custom Test Environment</a></li>
</ul>
<p>There's also more rigorous testing systems ranging from mocking and fuzzing to formal verification. See <a href="https://docs.rs/quickcheck/0.9.0/quickcheck/">quickcheck</a> for an example of a property-based testing framework ported from Haskell to Rust.</p>
<h2><a class="header" href="#kitchen-pallets-with-unit-tests" id="kitchen-pallets-with-unit-tests">Kitchen Pallets with Unit Tests</a></h2>
<p>The following modules in the kitchen have partial unit test coverage</p>
<ul>
<li><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/adding-machine"><code>adding-machine</code></a></li>
<li><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/constant-config"><code>constant-config</code></a></li>
<li><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/double-map"><code>double-map</code></a></li>
<li><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/generic-event"><code>generic-event</code></a></li>
<li><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/offchain-demo">`offchain-demo</a></li>
<li><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/simple-event"><code>simple-event</code></a></li>
<li><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/simple-map"><code>simple-map</code></a></li>
<li><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/single-value"><code>single-value</code></a></li>
<li><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/storage-cache"><code>storage-cache</code></a></li>
<li><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/struct-storage"><code>struct-storage</code></a></li>
<li><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/vec-set"><code>vec-set</code></a></li>
</ul>
<h3><a class="header" href="#cooking-in-the-kitchen-running-tests" id="cooking-in-the-kitchen-running-tests">Cooking in the Kitchen (Running Tests)</a></h3>
<p>To run the tests, clone the repo</p>
<pre><code class="language-bash">$ git clone https://github.com/substrate-developer-hub/recipes
</code></pre>
<p>Enter the path to the pallet to be tested</p>
<pre><code class="language-bash">$ cd pallets/&lt;some-module&gt;
</code></pre>
<p>For example, to test <code>constant-config</code>, used in <a href="https://substrate.dev/recipes/3-entrees/constants.html">Configurable Constants</a>,</p>
<pre><code class="language-bash">$ cd pallets/constant-config/
$ cargo test
</code></pre>
<p>Writing unit tests is one of the best ways to understand the code. Although unit tests are not comprehensive, they provide a first check to verify that the programmer's basic invariants are not violated in the presence of obvious, expected state changes.</p>
<h1><a class="header" href="#mock-runtime-for-unit-testing" id="mock-runtime-for-unit-testing">Mock Runtime for Unit Testing</a></h1>
<p><em>See <a href="3-entrees/testing/./index.html">Testing</a> page for list of kitchen pallets with unit test coverage.</em></p>
<p>There are two main patterns on writing tests for pallets. We can put the tests:</p>
<ol>
<li>
<p>At the bottom of the pallet, place unit tests in a separate Rust module with a special compilation flag</p>
<pre><code class="language-rust ignore">#[cfg(test)]
mod tests {
	// -- snip --
}
</code></pre>
</li>
<li>
<p>In a separate file called <code>tests.rs</code> inside <code>src</code> folder, and conditionally include tests inside the main <code>lib.rs</code>. At the top of the <code>lib.rs</code></p>
<pre><code class="language-rust ignore">#[cfg(test)]
mod tests;
</code></pre>
</li>
</ol>
<p>Now, to use the logic from the pallet under test, bring <code>Module</code> and <code>Trait</code> into scope.</p>
<pre><code class="language-rust ignore">use crate::{Module, Trait};
</code></pre>
<h2><a class="header" href="#create-the-outer-environment-for-mock-runtime" id="create-the-outer-environment-for-mock-runtime">Create the Outer Environment for Mock Runtime</a></h2>
<p>Before we create the mock runtime that take our pallet to run tests, we first need to create the
outer environment for the runtime as follows:</p>
<pre><code class="language-rust ignore">use support::{impl_outer_event, impl_outer_origin, parameter_types};
use runtime_primitives::{Perbill, traits::{IdentityLookup, BlakeTwo256}, testing::Header};
use runtime_io;
use primitives::{H256};

// We define the outer `Origin` enum and `Event` enum.
// You may not be aware that these enums are created when writing the runtime/pallet;
//   it is because they are created through the `construct_runtime!` macro.
// Also, these are not standard Rust but the syntax expected when parsed inside
//   these macros.
impl_outer_origin! {
	pub enum Origin for TestRuntime {}
}

// -- If you want to test events, add the following. Otherwise, please ignore --
mod test_events {
	pub use crate::Event;
}

impl_outer_event! {
	pub enum TestEvent for TestRuntime {
		test_events,
		system&lt;T&gt;,
	}
}
// -- End: Code setup for testing events --
</code></pre>
<h2><a class="header" href="#define-mock-runtime-and-implement-necessary-pallet-traits" id="define-mock-runtime-and-implement-necessary-pallet-traits">Define Mock Runtime and Implement Necessary Pallet Traits</a></h2>
<p>Now, declare the mock runtime as a unit structure</p>
<pre><code class="language-rust ignore">#[derive(Clone, PartialEq, Eq, Debug)]
pub struct TestRuntime;
</code></pre>
<p>The <code>derive</code> macro attribute provides implementations of the <code>Clone + PartialEq + Eq + Debug</code> traits for the <code>TestRuntime</code> struct.</p>
<p>The mock runtime also needs to implement the tested pallet's <code>Trait</code>. If it is unnecessary to test the pallet's <code>Event</code> type, the type can be set to <code>()</code>. See further below to test the pallet's <code>Event</code> enum.</p>
<pre><code class="language-rust ignore">impl Trait for TestRuntime {
	type Event = ();
}
</code></pre>
<p>Next, we create a new type that wraps the mock <code>TestRuntime</code> in the pallet's <code>Module</code>.</p>
<pre><code class="language-rust ignore">pub type TestPallet = Module&lt;TestRuntime&gt;;
</code></pre>
<p>It may be helpful to read this as type aliasing our configured mock runtime to work with the pallet's <code>Module</code>, which is what is ultimately being tested.</p>
<p>In many cases, the pallet's <code>Trait</code> is further bound by <code>system::Trait</code> like:</p>
<pre><code class="language-rust ignore">pub trait Trait: system::Trait {
	type Event: From&lt;Event&lt;Self&gt;&gt; + Into&lt;&lt;Self as system::Trait&gt;::Event&gt;;
}
</code></pre>
<p>The mock runtime must inherit and define the <code>system::Trait</code> associated types. To do so, <code>impl</code> the <code>system::Trait</code>
for <code>TestRuntime</code> with types created previously and imported from other crates.</p>
<pre><code class="language-rust ignore">#[derive(Clone, PartialEq, Eq, Debug)]
pub struct TestRuntime;

parameter_types! {
	pub const BlockHashCount: u64 = 250;
	pub const MaximumBlockWeight: u32 = 1024;
	pub const MaximumBlockLength: u32 = 2 * 1024;
	pub const AvailableBlockRatio: Perbill = Perbill::one();
}

// First, implement the system pallet's configuration trait for `TestRuntime`
impl system::Trait for TestRuntime {
	type Origin = Origin;
	type Index = u64;
	type Call = ();
	type BlockNumber = u64;
	type Hash = H256;
	type Hashing = BlakeTwo256;
	type AccountId = u64;
	type Lookup = IdentityLookup&lt;Self::AccountId&gt;;
	type Header = Header;
	// To test events, use `TestEvent`. Otherwise, use the commented line
	type Event = TestEvent;
	// type Event = ();
	type BlockHashCount = BlockHashCount;
	type MaximumBlockWeight = MaximumBlockWeight;
	type MaximumBlockLength = MaximumBlockLength;
	type AvailableBlockRatio = AvailableBlockRatio;
	type Version = ();
	type ModuleToIndex = ();
	type AccountData = ();
	type OnNewAccount = ();
	type OnKilledAccount = ();
}

// Then implement our own pallet's configuration trait for `TestRuntime`
impl Trait for TestRuntime {
	type Event = TestEvent;
}

// Assign back to type variables so we can make dispatched calls of these modules later.
pub type System = system::Module&lt;TestRuntime&gt;;
pub type TestPallet = Module&lt;TestRuntime&gt;;
</code></pre>
<p>With this, it is possible to use this type in the unit tests. For example, the block number can be set with <a href="https://substrate.dev/rustdocs/master/frame_system/struct.Module.html#method.set_block_number"><code>set_block_number</code></a></p>
<pre><code class="language-rust ignore">#[test]
fn add_emits_correct_event() {
	// ExtBuilder syntax is explained further below
	ExtBuilder::build().execute_with(|| {
		System::set_block_number(2);
		// some assert statements and HelloSubstrate calls
	}
}
</code></pre>
<h2><a class="header" href="#basic-test-environments" id="basic-test-environments">Basic Test Environments</a></h2>
<p>To build the test runtime environment, import <code>runtime_io</code></p>
<pre><code class="language-rust ignore">use runtime_io;
</code></pre>
<p>In the <code>Cargo.toml</code>, this only needs to be imported under <code>dev-dependencies</code> since it is only used in the <code>tests</code> module. It also doesn't need to be feature gated in the <code>std</code> feature.</p>
<pre><code>[dev-dependencies.sp-io]
default-features = false

version = '2.0.0-alpha.7'
</code></pre>
<p>There is more than one pattern for building a mock runtime environment for testing pallet logic. Two patterns are presented below. The latter is generally favored for reasons discussed in <a href="3-entrees/testing/./externalities.html">custom test environment</a></p>
<ul>
<li><a href="3-entrees/testing/mock.html#newext"><code>new_test_ext</code></a> -  consolidates all the logic for building the environment to a single public method, but isn't relatively configurable (i.e. uses one set of pallet constants)</li>
<li><a href="3-entrees/testing/mock.html#extbuilder"><code>ExtBuilder</code></a> - define methods on the unit struct <code>ExtBuilder</code> to facilitate a flexible environment for tests (i.e. can reconfigure pallet constants in every test if necessary)</li>
</ul>
<h2><a class="header" href="#new_test_ext-a-name--newexta" id="new_test_ext-a-name--newexta">new_test_ext <a name = "newext"><a/></a></h2>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/charity"><code>pallets/smpl-treasury</code></a></em></p>
<p>In <a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/charity"><code>smpl-treasury</code></a>, use the <code>balances::GenesisConfig</code> and the pallet's <code>Genesis::&lt;TestRuntime&gt;</code> to set the balances of the test accounts and establish council membership in the returned test environment.</p>
<pre><code class="language-rust ignore">pub fn new_test_ext() -&gt; runtime_io::TestExternalities {
	let mut t = system::GenesisConfig::default().build_storage::&lt;TestRuntime&gt;().unwrap();
	balances::GenesisConfig::&lt;TestRuntime&gt; {
		balances: vec![
			// members of council (can also be users)
			(1, 13),
			(2, 11),
			(3, 1),
			(4, 3),
			(5, 19),
			(6, 23),
			(7, 17),
			// users, not members of council
			(8, 1),
			(9, 22),
			(10, 46),
		],
		vesting: vec![],
	}.assimilate_storage(&amp;mut t).unwrap();
	GenesisConfig::&lt;TestRuntime&gt;{
		council: vec![
			1,
			2,
			3,
			4,
			5,
			6,
			7,
		]
	}.assimilate_storage(&amp;mut t).unwrap();
	t.into()
}
</code></pre>
<p>More specifically, this sets the <code>AccountId</code>s in the range of <code>[1, 7]</code> inclusive as the members of the <code>council</code>. This is expressed in the <code>decl_module</code> block with the addition of an <code>add_extra_genesis</code> block,</p>
<pre><code class="language-rust ignore">add_extra_genesis {
	build(|config| {
		// ..other stuff..
		&lt;Council&lt;T&gt;&gt;::put(&amp;config.council);
	});
}
</code></pre>
<p>To use <code>new_test_ext</code> in a runtime test, we call the method and call <a href="https://substrate.dev/rustdocs/master/sp_state_machine/struct.TestExternalities.html#method.execute_with"><code>execute_with</code></a> on the returned <code>runtime_io::TestExternalities</code></p>
<pre><code class="language-rust ignore">#[test]
fn fake_test() {
	new_test_ext().execute_with(|| {
		// test logic
	})
}
</code></pre>
<p><code>execute_with</code> executes all logic expressed in the closure within the configured runtime test environment specified in <code>new_test_ext</code></p>
<h2><a class="header" href="#extbuilder-a-name--extbuildera" id="extbuilder-a-name--extbuildera">ExtBuilder <a name = "extbuilder"></a></a></h2>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/struct-storage"><code>pallets/struct-storage</code></a></em></p>
<p>Another approach for a more flexible runtime test environment instantiates a unit struct <code>ExtBuilder</code>,</p>
<pre><code class="language-rust ignore">pub struct ExtBuilder;
</code></pre>
<p>The behavior for constructing the test environment is contained the methods on the <code>ExtBuilder</code> unit structure. This fosters multiple levels of configuration depending on if the test requires a common default instance of the environment or a more specific edge case configuration. The latter is explored in more detail in <a href="3-entrees/testing/./externalities.html">Custom Test Environment</a>.</p>
<p>Like <code>new_test_ext</code>, the <code>build()</code> method on the <code>ExtBuilder</code> object returns an instance of <a href="https://substrate.dev/rustdocs/master/sp_state_machine/struct.TestExternalities.html"><code>TestExternalities</code></a>. <a href="https://substrate.dev/rustdocs/master/sp_externalities/index.html">Externalities</a> are an abstraction that allows the runtime to access features of the outer node such as storage or offchain workers.</p>
<p>In this case, create a mock storage from the default genesis configuration.</p>
<pre><code class="language-rust ignore">impl ExtBuilder {
	pub fn build() -&gt; runtime_io::TestExternalities {
		let mut storage = system::GenesisConfig::default().build_storage::&lt;TestRuntime&gt;().unwrap();
		runtime_io::TestExternalities::from(storage)
	}
}
</code></pre>
<p>which calls some methods to create a test environment,</p>
<pre><code class="language-rust ignore">#[test]
fn fake_test_example() {
	ExtBuilder::build().execute_with(|| {
		// ...test conditions...
	})
}
</code></pre>
<p>While testing in this environment, runtimes that require signed extrinsics (aka take <code>origin</code> as a parameter) will require transactions coming from an <code>Origin</code>. This requires importing the <a href="https://substrate.dev/rustdocs/master/frame_support/macro.impl_outer_origin.html"><code>impl_outer_origin</code></a> macro from <code>support</code></p>
<pre><code class="language-rust ignore">use support::{impl_outer_origin};

impl_outer_origin!{
	pub enum Origin for TestRuntime {}
}
</code></pre>
<p>It is possible to placed signed transactions as parameters in runtime methods that require the <code>origin</code> input. See the <a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/hello-substrate">full code in the kitchen</a>, but this looks like</p>
<pre><code class="language-rust ignore">#[test]
fn last_value_updates() {
	ExtBuilder::build().execute_with(|| {
		HelloSubstrate::set_value(Origin::signed(1), 10u64);
		// some assert statements
	})
}
</code></pre>
<p>Run these tests with <code>cargo test</code>, an optional parameter is the test's name to only run that test and not all tests.</p>
<p>Note that the input to <code>Origin::signed</code> is the <code>system::Trait</code>'s <code>AccountId</code> type which was set to <code>u64</code> for the <code>TestRuntime</code> implementation. In theory, this could be set to some other type as long as it conforms to the <a href="https://substrate.dev/rustdocs/master/frame_system/trait.Trait.html#associatedtype.AccountId">trait bound</a>,</p>
<pre><code class="language-rust ignore">pub trait Trait: 'static + Eq + Clone {
	//...
	type AccountId: Parameter + Member + MaybeSerializeDeserialize + Debug + MaybeDisplay + Ord + Default;
	//...
}
</code></pre>
<h3><a class="header" href="#setting-for-testing-event-emittances" id="setting-for-testing-event-emittances">Setting for Testing Event Emittances</a></h3>
<p>Events are not emitted on block 0. So when testing for whether events are emitted, we manually
set the block number in the test environment from 0 to 1 as the following:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl ExtBuilder {
	pub fn build() -&gt; TestExternalities {
		let storage = system::GenesisConfig::default().build_storage::&lt;TestRuntime&gt;().unwrap();
		let mut ext = TestExternalities::from(storage);
		ext.execute_with(|| System::set_block_number(1));
		ext
	}
}
<span class="boring">}
</span></code></pre></pre>
<!-- add link to testing in devhub docs after it is added -->
<h1><a class="header" href="#common-tests" id="common-tests">Common Tests</a></h1>
<p>To verify that our pallet code behaves as expected, it is necessary to check a few conditions with unit tests. Intuitively, the order of the testing may resemble the structure of runtime method development.</p>
<ol>
<li>Within each runtime method, declarative checks are made prior to any state change. These checks ensure that any required conditions are met before all changes occur; need to ensure that <a href="3-entrees/testing/common.html#panicspanic">panics panic</a>.</li>
<li>Next, verify that the <a href="3-entrees/testing/common.html#storage">expected storage changes occurred</a>.</li>
<li>Finally, check that the <a href="3-entrees/testing/common.html#events">expected events were emitted</a> with correct values.</li>
</ol>
<h3><a class="header" href="#checks-before-changes-are-enforced-ie-panics-panic-a-name--panicspanica" id="checks-before-changes-are-enforced-ie-panics-panic-a-name--panicspanica">Checks before Changes are Enforced (i.e. Panics Panic) <a name = "panicspanic"></a></a></h3>
<p>The <code>Verify First, Write Last</code> paradigm encourages verifying certain conditions before changing storage values. In tests, it might be desirable to verify that invalid inputs return the expected error message.</p>
<p>In <a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/adding-machine"><code>pallets/adding-machine</code></a>, the runtime method <code>add</code> checks for overflow</p>
<pre><code class="language-rust ignore">decl_module! {
    pub struct Module&lt;T: Trait&gt; for enum Call where origin: T::Origin {
        fn deposit_event() = default;

        fn add(origin, val1: u32, val2: u32) -&gt; Result {
            let _ = ensure_signed(origin)?;
            // checks for overflow
            let result = match val1.checked_add(val2) {
                Some(r) =&gt; r,
                None =&gt; return Err(&quot;Addition overflowed&quot;),
            };
            Self::deposit_event(Event::Added(val1, val2, result));
            Ok(())
        }
    }
}
</code></pre>
<p>The test below verifies that the expected error is thrown for a specific case of overflow.</p>
<pre><code class="language-rust ignore">#[test]
fn overflow_fails() {
	ExtBuilder::build().execute_with(|| {
		assert_err!(
			AddingMachine::add(Origin::signed(3), u32::max_value(), 1),
			&quot;Addition overflowed&quot;
		);
	})
}
</code></pre>
<p>This requires importing the <code>assert_err</code> macro from <code>support</code>. With all the previous imported objects,</p>
<pre><code class="language-rust ignore">#[cfg(test)]
mod tests {
	use support::{assert_err, impl_outer_event, impl_outer_origin, parameter_types};
	// more imports and tests
}
</code></pre>
<p>For more examples, see <a href="https://github.com/paritytech/substrate/tree/master/frame">Substrate's own pallets</a> -- <code>mock.rs</code> for mock runtime scaffolding and <code>test.rs</code> for unit tests.</p>
<h3><a class="header" href="#expected-changes-to-storage-are-triggered-a-name--storagea" id="expected-changes-to-storage-are-triggered-a-name--storagea">Expected Changes to Storage are Triggered <a name = "storage"></a></a></h3>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/single-value">pallets/single-value</a></em></p>
<p>Changes to storage can be checked by direct calls to the storage values. The syntax is the same as it would be in the pallet's runtime methods.</p>
<pre><code class="language-rust ignore">use crate::*;

#[test]
fn set_value_works() {
  ExtBuilder::build().execute_with(|| {
    assert_ok!(SingleValue::set_value(Origin::signed(1), 10));
    assert_eq!(SingleValue::stored_value(), 10);
    // Another way of accessing the storage. This pattern is needed if it is a more complexed data
    //   type, e.g. StorageMap, StorageLinkedMap
    assert_eq!(&lt;StoredValue&gt;::get(), 10);
  })
}
</code></pre>
<p>For context, the tested pallets's <code>decl_storage</code> block looks like</p>
<pre><code class="language-rust ignore">decl_storage! {
  trait Store for Module&lt;T: Trait&gt; as SingleValue {
    StoredValue get(fn stored_value): u32;
    StoredAccount get(fn stored_account): T::AccountId;
  }
}
</code></pre>
<h3><a class="header" href="#expected-events-are-emitted-a-name--eventsa" id="expected-events-are-emitted-a-name--eventsa">Expected Events are Emitted <a name = "events"></a></a></h3>
<p>The common way of testing expected event emission behavior requires importing <code>support</code>'s <a href="https://substrate.dev/rustdocs/master/frame_support/macro.impl_outer_event.html"><code>impl_outer_event!</code></a> macro</p>
<pre><code class="language-rust ignore">use support::impl_outer_event;
</code></pre>
<p>The <code>TestEvent</code> enum imports and uses the pallet's <code>Event</code> enum. The new local pallet, <code>hello_substrate</code>, re-exports the contents of the root to give a name for the current crate to <code>impl_outer_event!</code>.</p>
<pre><code class="language-rust ignore">mod hello_substrate {
	pub use crate::Event;
}

impl_outer_event! {
	pub enum TestEvent for TestRuntime {
		hello_substrate&lt;T&gt;,
	}
}

impl Trait for TestRuntime {
	type Event = TestEvent;
}
</code></pre>
<p>Testing the correct emission of events compares constructions of expected events with the entries in the <a href="https://substrate.dev/rustdocs/master/frame_system/struct.Module.html#method.events"><code>System::events</code></a> vector of <code>EventRecord</code>s. In <a href="https://github.com/substrate-developer-hub/recipes/tree/master//pallets/adding-machine"><code>pallets/adding-machine</code></a>,</p>
<pre><code class="language-rust ignore">#[test]
fn add_emits_correct_event() {
	ExtBuilder::build().execute_with(|| {
		AddingMachine::add(Origin::signed(1), 6, 9);

		assert_eq!(
			System::events(),
			vec![
				EventRecord {
					phase: Phase::Initialization,
					event: TestEvent::added(crate::Event::Added(6, 9, 15)),
					topics: vec![],
				},
			]
		);
	})
}
</code></pre>
<p>This check requires importing from <code>system</code></p>
<pre><code class="language-rust ignore">use system::{EventRecord, Phase};
</code></pre>
<p>A more ergonomic way of testing whether a specific event was emitted might use the <code>System::events().iter()</code>. This pattern doesn't require the previous imports, but it does require importing <code>RawEvent</code> (or <code>Event</code>) from the pallet and <code>ensure_signed</code> from <code>system</code> to convert signed extrinsics to the underlying <code>AccountId</code>,</p>
<pre><code class="language-rust ignore">#[cfg(test)]
mod tests {
	// other imports
	use system::ensure_signed;
	use super::RawEvent; // if no RawEvent, then `use super::Event;`
	// tests
}
</code></pre>
<p>In <a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/hello-substrate"><code>pallets/hello-substrate</code></a>,</p>
<pre><code class="language-rust ignore">#[test]
fn last_value_updates() {
	ExtBuilder::build().execute_with(|| {
		HelloSubstrate::set_value(Origin::signed(1), 10u64);
		// some assert checks

		let id_1 = ensure_signed(Origin::signed(1)).unwrap();
		let expected_event1 = TestEvent::hello_substrate(
			RawEvent::ValueSet(id_1, 10),
		);
		assert!(System::events().iter().any(|a| a.event == expected_event1));
	})
}
</code></pre>
<p>This test constructs an <code>expected_event1</code> based on the event that the developer expects will be emitted upon the successful execution of logic in <code>HelloSubstrate::set_value</code>. The <code>assert!()</code> statement checks if the <code>expected_event1</code> matches the <code>.event</code> field for any <code>EventRecord</code> in the <code>System::events()</code> vector.</p>
<h1><a class="header" href="#off-chain-worker-test-environment" id="off-chain-worker-test-environment">Off-chain Worker Test Environment</a></h1>
<p>Learn more about how to set up and use offchain-workers in the <a href="3-entrees/testing//3-entrees/off-chain-workers/index.html">offchain-demo entree</a>.</p>
<h2><a class="header" href="#mock-runtime-setup" id="mock-runtime-setup">Mock Runtime Setup</a></h2>
<p>In addition to everything we need to set up in <a href="3-entrees/testing/./mock.html">Basic Test Environment</a>, we also need to set up the mock for <code>SubmitTransaction</code>, and implement the <code>CreateTransaction</code> trait for the runtime.</p>
<p>src: <a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/offchain-demo/src/tests.rs"><code>pallets/offchain-demo/src/tests.rs</code></a></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>type TestExtrinsic = TestXt&lt;Call&lt;TestRuntime&gt;, ()&gt;;
type SubmitTransaction = system::offchain::TransactionSubmitter&lt;
	crypto::Public,
	TestRuntime,
	TestExtrinsic
&gt;;

impl Trait for TestRuntime {
	// ...snip
	// For signed transaction
	type SubmitSignedTransaction = SubmitTransaction;
	// For unsigned transaction
	type SubmitUnsignedTransaction = SubmitTransaction;
}

impl system::offchain::CreateTransaction&lt;TestRuntime, TestExtrinsic&gt; for TestRuntime {
	type Public = sr25519::Public;
	type Signature = sr25519::Signature;

	fn create_transaction&lt;TSigner: system::offchain::Signer&lt;Self::Public, Self::Signature&gt;&gt; (
		call: Call&lt;TestRuntime&gt;,
		public: Self::Public,
		_account: &lt;TestRuntime as system::Trait&gt;::AccountId,
		index: &lt;TestRuntime as system::Trait&gt;::Index,
	) -&gt; Option&lt;(Call&lt;TestRuntime&gt;, &lt;TestExtrinsic as sp_runtime::traits::Extrinsic&gt;::SignaturePayload)&gt; {
		// This is the simplest setup we can do
		Some((call, (index, ())))
	}
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#getting-the-transaction-pool-and-off-chain-state" id="getting-the-transaction-pool-and-off-chain-state">Getting the Transaction Pool and Off-chain State</a></h2>
<p>When writing test cases for off-chain workers, we need to look into the transaction pool and current off-chain state to ensure a certain transaction has made its way, and was passed with the right parameters and signature. So in addition to the regular test environment <code>TestExternalities</code>, we also need to return references to the transaction pool state and off-chain state for future inspection.</p>
<p>src: <a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/offchain-demo/src/tests.rs"><code>pallets/offchain-demo/src/tests.rs</code></a></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub struct ExtBuilder;

impl ExtBuilder {
	pub fn build() -&gt; (TestExternalities, Arc&lt;RwLock&lt;PoolState&gt;&gt;, Arc&lt;RwLock&lt;OffchainState&gt;&gt;) {
		const PHRASE: &amp;str = &quot;expire stage crawl shell boss any story swamp skull yellow bamboo copy&quot;;

		// Getting the transaction pool and off-chain state. Return them for future inspection.
		let (offchain, offchain_state) = testing::TestOffchainExt::new();
		let (pool, pool_state) = testing::TestTransactionPoolExt::new();

		// Initialize the keystore with a default key
		let keystore = KeyStore::new();
		keystore.write().sr25519_generate_new(
			KEY_TYPE,
			Some(&amp;format!(&quot;{}/hunter1&quot;, PHRASE))
		).unwrap();

		// Initialize our genesis config
		let storage = system::GenesisConfig::default()
			.build_storage::&lt;TestRuntime&gt;()
			.unwrap();

		// Get the TestExternalities, register additional extension we just set up
		let mut t = TestExternalities::from(storage);
		t.register_extension(OffchainExt::new(offchain));
		t.register_extension(TransactionPoolExt::new(pool));
		t.register_extension(KeystoreExt(keystore));

		// Return the externalities and two necessary states
		(t, pool_state, offchain_state)
	}
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#testing-off-chain-worker" id="testing-off-chain-worker">Testing Off-chain Worker</a></h2>
<p>When we write tests for off-chain workers, we should test only what our off-chain workers do. For example, when our off-chain workers will eventually make a signed transaction to dispatch function A, which does B, C, and D, we write our test for the off-chain worker to test only if function A is dispatched. But whether function A actually does B, C, and D should be tested separately in another test case. This way we keep our tests more robust.</p>
<p>This is how we write our test cases.</p>
<p>src: <a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/offchain-demo/src/tests.rs"><code>pallets/offchain-demo/src/tests.rs</code></a></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[test]
fn offchain_send_signed_tx() {
	let (mut t, pool_state, offchain_state) = ExtBuilder::build();

	t.execute_with(|| {
		// when
		let num = 32;
		OffchainDemo::send_signed(num).unwrap();
		// then

		// Test only one transaction is in the pool.
		let tx = pool_state.write().transactions.pop().unwrap();
		assert!(pool_state.read().transactions.is_empty());

		let tx = TestExtrinsic::decode(&amp;mut &amp;*tx).unwrap();
		// Test the transaction is signed
		assert_eq!(tx.signature.unwrap().0, 0);
		// Test the transaction is calling the expected extrinsics with expected parameters
		assert_eq!(tx.call, Call::submit_number_signed(num));
	});
}
<span class="boring">}
</span></code></pre></pre>
<p>We test that when <code>OffchainDemo::send_signed(num)</code> function is being called,</p>
<ul>
<li>There is only one transaction made to the transaction pool.</li>
<li>The transaction is signed.</li>
<li>The transaction is calling the <code>Call::submit_number_signed</code> on-chain function with the parameter <code>num</code>.</li>
</ul>
<p>What's performed by the <code>Call::submit_number_signed</code> on-chain function is tested in another test case, which would be similar to how you <a href="3-entrees/testing/./common.html">test for dispatched extrinsic calls</a>.</p>
<h1><a class="header" href="#custom-test-environment" id="custom-test-environment">Custom Test Environment</a></h1>
<p><a href="3-entrees/testing/../execution-schedule.html"><code>execution-schedule</code></a>'s configuration trait has three <a href="3-entrees/testing/../constants.html">configurable constants</a>. For this mock runtime, the <code>ExtBuilder</code> defines setters to enable the <code>TestExternalities</code> instance for each unit test to configure the local test runtime environment with different value assignments. For context, the <code>Trait</code> for <code>execution-schedule</code>,</p>
<pre><code class="language-rust ignore">// other type aliases
pub type PriorityScore = u32;

pub trait Trait: system::Trait {
    /// Overarching event type
    type Event: From&lt;Event&lt;Self&gt;&gt; + Into&lt;&lt;Self as system::Trait&gt;::Event&gt;;

    /// Quota for members to signal task priority every ExecutionFrequency
    type SignalQuota: Get&lt;PriorityScore&gt;;

    /// The frequency of batch executions for tasks (in `on_finalize`)
    type ExecutionFrequency: Get&lt;Self::BlockNumber&gt;;

    /// The maximum number of tasks that can be approved in an `ExecutionFrequency` period
    type TaskLimit: Get&lt;PriorityScore&gt;;
}
</code></pre>
<p>The mock runtime environment extends the <a href="3-entrees/testing/./mock.html">previously discussed</a> <code>ExtBuilder</code> pattern with fields for each configurable constant and a default implementation.</p>
<blockquote>
<p>This completes the <a href="https://youtu.be/geovSK3wMB8?t=729">builder</a> pattern by defining a default configuraton to be used in a plurality of test cases while also providing setter methods to overwrite the values for each field.</p>
</blockquote>
<pre><code class="language-rust ignore">pub struct ExtBuilder {
    signal_quota: u32,
    execution_frequency: u64,
    task_limit: u32,
}
impl Default for ExtBuilder {
    fn default() -&gt; Self {
        Self {
            signal_quota: 100u32,
            execution_frequency: 5u64,
            task_limit: 10u32,
        }
    }
}
</code></pre>
<p>The setter methods for each configurable constant are defined in the <code>ExtBuilder</code> methods. This allows each instance of <code>ExtBuilder</code> to set the constant parameters for the unit test in question.</p>
<pre><code class="language-rust ignore">impl ExtBuilder {
    pub fn signal_quota(mut self, signal_quota: u32) -&gt; Self {
        self.signal_quota = signal_quota;
        self
    }
    pub fn execution_frequency(mut self, execution_frequency: u64) -&gt; Self {
        self.execution_frequency = execution_frequency;
        self
    }
    pub fn task_limit(mut self, task_limit: u32) -&gt; Self {
        self.task_limit = task_limit;
        self
    }
    // more methods e.g. build()
}
</code></pre>
<p>To allow for separate copies of the constant objects to be used in each thread, the variables assigned as constants are declared as <a href="https://substrate.dev/rustdocs/master/thread_local/index.html"><code>thread_local!</code></a>,</p>
<pre><code class="language-rust ignore">thread_local! {
    static SIGNAL_QUOTA: RefCell&lt;u32&gt; = RefCell::new(0);
    static EXECUTION_FREQUENCY: RefCell&lt;u64&gt; = RefCell::new(0);
    static TASK_LIMIT: RefCell&lt;u32&gt; = RefCell::new(0);
}
</code></pre>
<p>Each configurable constant type also maintains unit structs with implementation of <code>Get&lt;T&gt;</code> from the type <code>T</code> assigned to the pallet constant in the mock runtime implementation.</p>
<pre><code class="language-rust ignore">pub struct SignalQuota;
impl Get&lt;u32&gt; for SignalQuota {
    fn get() -&gt; u32 {
        SIGNAL_QUOTA.with(|v| *v.borrow())
    }
}

pub struct ExecutionFrequency;
impl Get&lt;u64&gt; for ExecutionFrequency {
    fn get() -&gt; u64 {
        EXECUTION_FREQUENCY.with(|v| *v.borrow())
    }
}

pub struct TaskLimit;
impl Get&lt;u32&gt; for TaskLimit {
    fn get() -&gt; u32 {
        TASK_LIMIT.with(|v| *v.borrow())
    }
}
</code></pre>
<p>The build method on <code>ExtBuilder</code> sets the associated constants before building the default storage configuration.</p>
<pre><code class="language-rust ignore">impl ExtBuilder {
    // setters
    pub fn set_associated_consts(&amp;self) {
        SIGNAL_QUOTA.with(|v| *v.borrow_mut() = self.signal_quota);
        EXECUTION_FREQUENCY.with(|v| *v.borrow_mut() = self.execution_frequency);
        TASK_LIMIT.with(|v| *v.borrow_mut() = self.task_limit);
    }
    // build()
}
</code></pre>
<p>To build the default test environment, the syntax looks like</p>
<pre><code class="language-rust ignore">#[test]
fn fake_test() {
    ExtBuilder::default()
        .build()
        .execute_with(|| {
            // testing logic and checks
        })
}
</code></pre>
<p>To configure a test environment in which the <code>execution_frequency</code> is set to <code>2</code>, the <code>eras_change_correctly</code> test invokes the <code>execution_frequency</code> setter declared in as a method on <code>ExtBuilder</code>,</p>
<pre><code class="language-rust ignore">#[test]
fn fake_test2() {
    ExtBuilder::default()
        .execution_frequency(2)
        .build()
        .execute_with(|| {
            // testing logic and checks
        })
}
</code></pre>
<p>The test environment mocked above is actually used for the cursory and incomplete test <code>eras_change_correctly</code>. This test guided the structure of the if condition in <code>on_initialize</code> to periodically reset the <code>SignalBank</code> and increment the <code>Era</code>.</p>
<p>For more examples of the mock runtime scaffolding pattern used in <a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/execution-schedule"><code>execution-schedule</code></a>, see <code>balances/mock.rs</code> and <code>contract/tests.rs</code>.</p>
<h1><a class="header" href="#safe-math" id="safe-math">Safe Math</a></h1>
<p>We can use the <code>checked</code> traits in <a href="https://substrate.dev/rustdocs/master/sp_runtime/traits/index.html">substrate-primitives</a> to protect against <a href="https://medium.com/@taabishm2/integer-overflow-underflow-and-floating-point-imprecision-6ba869a99033">overflow/underflow</a> when incrementing/decrementing objects in our runtime. To follow the <a href="https://shawntabrizi.com/substrate-collectables-workshop/#/2/tracking-all-kitties?id=checking-for-overflowunderflow">Substrat collectable tutorial example</a>, use <a href="https://substrate.dev/rustdocs/master/sp_runtime/traits/trait.CheckedAdd.html"><code>checked_add()</code></a> to safely handle the possibility of overflow when incremementing a global counter. <em>Note that this check is similar to <a href="https://ethereumdev.io/safemath-protect-overflows/"><code>SafeMath</code></a> in Solidity</em>. </p>
<pre><code class="language-rust ignore">use runtime_primitives::traits::CheckedAdd;

let all_people_count = Self::num_of_people();

let new_all_people_count = all_people_count.checked_add(1).ok_or(&quot;Overflow adding a new person&quot;)?;
</code></pre>
<p><a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.ok_or"><code>ok_or()</code></a> transforms an <code>Option</code> from <code>Some(value)</code> to <code>Ok(value)</code> or <code>None</code> to <code>Err(error)</code>. The <a href="https://doc.rust-lang.org/nightly/edition-guide/rust-2018/error-handling-and-panics/the-question-mark-operator-for-easier-error-handling.html"><code>?</code> operator</a> facilitates error propagation. In this case, using <code>ok_or()</code> is the same as writing</p>
<pre><code class="language-rust ignore">let new_all_people_count = match all_people_count.checked_add(1) {
    Some (c) =&gt; c,
    None =&gt; return Err(&quot;Overflow adding a new person&quot;),
};
</code></pre>
<h2><a class="header" href="#todo" id="todo">todo</a></h2>
<ul>
<li><code>?</code> for error propagation</li>
<li>Permill, Perbill, Fixed64 types for large arithmetic</li>
<li><code>quantization</code> benchmarks in the <code>treasury</code> tests to verify that large arithmetic stays in a comfortable error bound</li>
<li>ADD BACK IN NEW RECIPE: <code>collide</code> and the question of whether maps prevent key collisions? could discuss <code>sort</code>, <code>sort_unstable</code>, and the ordering traits here...</li>
</ul>
<h1><a class="header" href="#more-resources" id="more-resources">More Resources</a></h1>
<h2><a class="header" href="#substrate" id="substrate">Substrate</a></h2>
<p>Learn more about Substrate from these resources:</p>
<ul>
<li><a href="https://substrate.dev">Substrate Developer Hub Home</a> - Landing page of the official Substrate documentation.</li>
<li><a href="https://substrate.dev/docs">Conceptual Docs</a> - Explanation of Substrate's architecture at a high level of abstraction.</li>
<li><a href="https://substrate.dev/rustdocs">Reference Docs</a> - Documentaiton on specific Substrate APIs with little abstraction.</li>
<li><a href="https://substrate.dev/tutorials">Substrate Tutorials</a> - Step by step guides to accomplish specific tasks with Substrate.</li>
</ul>
<!-- Reminder: There is a _lot_ more potential content for this section in drafts/dessert.md -->
<h2><a class="header" href="#rust" id="rust">Rust</a></h2>
<p>Once you've got the fundamentals of Substrate, it can only help to know more rust. Here is a collection of helpful docs
and blog posts to take you down the rabbit hole.</p>
<h3><a class="header" href="#api-design" id="api-design">API Design</a></h3>
<p>To become more familiar with commmon design patterns in Rust, the following links might be helpful:</p>
<ul>
<li><a href="https://rust-lang.github.io/api-guidelines/about.html">Official Rust API Guidelines</a></li>
<li><a href="https://github.com/rust-unofficial/patterns">Rust Unofficial Design Patterns</a></li>
<li><a href="https://deterministic.space/elegant-apis-in-rust.html">Elegant Library API Guidelines</a></li>
</ul>
<h3><a class="header" href="#optimizations" id="optimizations">Optimizations</a></h3>
<p>To optimize runtime performance, Substrate developers should make use of iterators, traits, and Rust's other &quot;<em>zero cost</em> abstractions&quot;:</p>
<ul>
<li><a href="https://blog.rust-lang.org/2015/05/11/traits.html">Abstraction without overhead: traits in Rust</a>, <a href="https://www.youtube.com/watch?v=Sn3JklPAVLk">related conference talk</a></li>
<li><a href="https://hermanradtke.com/2015/06/22/effectively-using-iterators-in-rust.html">Effectively Using Iterators in Rust</a></li>
<li><a href="http://troubles.md/posts/rust-optimization/">Achieving Warp Speed with Rust</a></li>
</ul>
<h3><a class="header" href="#concurrency" id="concurrency">Concurrency</a></h3>
<ul>
<li><strong><a href="https://stjepang.github.io/2019/01/29/lock-free-rust-crossbeam-in-2019.html">Lock-free Rust: Crossbeam in 2019</a></strong> a high-level overview of concurrency in Rust.</li>
<li><strong><a href="https://github.com/rayon-rs/rayon">Rayon</a></strong> splits your data into distinct pieces, gives each piece to a thread to do some kind of computation on it, and finally aggregates results. Its goal is to distribute CPU-intensive tasks onto a thread pool.</li>
<li><strong><a href="https://github.com/tokio-rs/tokio">Tokio</a></strong> runs tasks which sometimes need to be paused in order to wait for asynchronous events. Handling tons of such tasks is no problem. Its goal is to distribute IO-intensive tasks onto a thread pool.</li>
<li><strong><a href="https://github.com/crossbeam-rs/crossbeam">Crossbeam</a></strong> is all about low-level concurrency: atomics, concurrent data structures, synchronization primitives. Same idea as the <code>std::sync</code> module, but bigger. Its goal is to provide tools on top of which libraries like Rayon and Tokio can be built.</li>
</ul>
<h3><a class="header" href="#asynchrony" id="asynchrony">Asynchrony</a></h3>
<p><a href="https://areweasyncyet.rs/">Are we <code>async</code> yet?</a></p>
<p><strong>Conceptual</strong></p>
<ul>
<li><a href="https://boats.gitlab.io/blog/post/wakers-i/">Introduction to Async/Await Programming (withoutboats/wakers-i)</a></li>
<li><a href="https://aturon.github.io/tech/2016/08/11/futures/">Futures (by Aaron Turon)</a></li>
<li><a href="https://www.youtube.com/watch?v=skos4B5x7qE">RustLatam 2019 - Without Boats: Zero-Cost Async IO</a></li>
</ul>
<p><strong>Projects</strong></p>
<ul>
<li><a href="https://github.com/rustasync">Rust Asynchronous Ecosystem Working Group</a></li>
<li><a href="https://github.com/withoutboats/romio">romio</a></li>
<li><a href="https://tokio.rs/docs/overview/">Tokio Docs</a></li>
</ul>
<h3><a class="header" href="#concurrency-1" id="concurrency-1">Concurrency</a></h3>
<p><strong>Conceptual</strong></p>
<ul>
<li><a href="https://stjepang.github.io/2019/01/29/lock-free-rust-crossbeam-in-2019.html">Lock-free Rust: Crossbeam in 2019</a></li>
<li><a href="https://github.com/crossbeam-rs/rfcs/wiki">Crossbeam Research Meta-link</a></li>
<li><a href="https://www.youtube.com/watch?v=Dbytx0ivH7Q">Rust Concurrency Explained</a></li>
</ul>
<p><strong>Projects</strong></p>
<ul>
<li><a href="https://github.com/spacejam/sled">sled</a></li>
<li><a href="https://github.com/servo/servo">servo</a></li>
<li><a href="https://github.com/tikv/tikv">TiKV</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src=".analytics/load.js"></script>
        
        <script type="text/javascript" src=".analytics/config.js"></script>
        
        <script type="text/javascript" src=".analytics/klaro.min.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
