<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Substrate Recipes</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A Hands-On Cookbook for Aspiring Blockchain Chefs">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="pallets-intro.html"><strong aria-hidden="true">1.</strong> Pallets</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="runtime-printing.html"><strong aria-hidden="true">1.1.</strong> Printing to the Node Log</a></li><li class="chapter-item expanded "><a href="events.html"><strong aria-hidden="true">1.2.</strong> Emitting Events</a></li><li class="chapter-item expanded "><a href="storage-maps.html"><strong aria-hidden="true">1.3.</strong> Storage Maps</a></li><li class="chapter-item expanded "><a href="cache.html"><strong aria-hidden="true">1.4.</strong> Cache Locally &gt; Storage Calls</a></li><li class="chapter-item expanded "><a href="vec-set.html"><strong aria-hidden="true">1.5.</strong> Using Vectors as Sets</a></li><li class="chapter-item expanded "><a href="map-set.html"><strong aria-hidden="true">1.6.</strong> Using Maps as Sets</a></li><li class="chapter-item expanded "><a href="double.html"><strong aria-hidden="true">1.7.</strong> Subgroup Removal by Subkey: Double Maps</a></li><li class="chapter-item expanded "><a href="structs.html"><strong aria-hidden="true">1.8.</strong> Storing custom structs</a></li><li class="chapter-item expanded "><a href="ringbuffer.html"><strong aria-hidden="true">1.9.</strong> Ringbuffer Queue</a></li><li class="chapter-item expanded "><a href="basic-token.html"><strong aria-hidden="true">1.10.</strong> Basic Token</a></li><li class="chapter-item expanded "><a href="constants.html"><strong aria-hidden="true">1.11.</strong> Configurable Constants</a></li><li class="chapter-item expanded "><a href="crowdfund.html"><strong aria-hidden="true">1.12.</strong> Simple Crowdfund</a></li><li class="chapter-item expanded "><a href="instantiable.html"><strong aria-hidden="true">1.13.</strong> Instantiable Pallets</a></li><li class="chapter-item expanded "><a href="weights.html"><strong aria-hidden="true">1.14.</strong> Weights for Resource Accounting</a></li><li class="chapter-item expanded "><a href="charity.html"><strong aria-hidden="true">1.15.</strong> Charity and Imbalances</a></li><li class="chapter-item expanded "><a href="fixed-point.html"><strong aria-hidden="true">1.16.</strong> Fixed Point Arithmetic</a></li><li class="chapter-item expanded "><a href="off-chain-workers/index.html"><strong aria-hidden="true">1.17.</strong> Off-chain Workers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="off-chain-workers/transactions.html"><strong aria-hidden="true">1.17.1.</strong> Transactions</a></li><li class="chapter-item expanded "><a href="off-chain-workers/http-json.html"><strong aria-hidden="true">1.17.2.</strong> HTTP Fetching &amp; JSON Parsing</a></li><li class="chapter-item expanded "><a href="off-chain-workers/storage.html"><strong aria-hidden="true">1.17.3.</strong> Local Storage</a></li></ol></li><li class="chapter-item expanded "><a href="currency.html"><strong aria-hidden="true">1.18.</strong> Currency Types</a></li><li class="chapter-item expanded "><a href="currency-imbalances.html"><strong aria-hidden="true">1.19.</strong> Currency and Imbalances</a></li><li class="chapter-item expanded "><a href="randomness.html"><strong aria-hidden="true">1.20.</strong> Generating Randomness</a></li><li class="chapter-item expanded "><a href="pallet-coupling.html"><strong aria-hidden="true">1.21.</strong> Tightly- and Loosely-Coupled Pallets</a></li></ol></li><li class="chapter-item expanded "><a href="runtimes-intro.html"><strong aria-hidden="true">2.</strong> Runtimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="runtime-api.html"><strong aria-hidden="true">2.1.</strong> Runtime APIs</a></li><li class="chapter-item expanded "><a href="fees.html"><strong aria-hidden="true">2.2.</strong> Transaction Fees for Economic Security</a></li></ol></li><li class="chapter-item expanded "><a href="consensus-intro.html"><strong aria-hidden="true">3.</strong> Consensus</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="sha3-pow-consensus.html"><strong aria-hidden="true">3.1.</strong> Sha3 Pow Consensus Algorithms</a></li></ol></li><li class="chapter-item expanded "><a href="nodes-intro.html"><strong aria-hidden="true">4.</strong> Nodes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="kitchen-node.html"><strong aria-hidden="true">4.1.</strong> Kitchen Node - An reusable instant seal node</a></li><li class="chapter-item expanded "><a href="custom-rpc.html"><strong aria-hidden="true">4.2.</strong> Custom RPCs</a></li><li class="chapter-item expanded "><a href="basic-pow.html"><strong aria-hidden="true">4.3.</strong> Basic Proof of Work Node</a></li><li class="chapter-item expanded "><a href="hybrid-consensus.html"><strong aria-hidden="true">4.4.</strong> Hybrid PoW/PoS Consensus Node</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Substrate Recipes</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#substrate-recipes-" id="substrate-recipes-">Substrate Recipes üç¥üòãüç¥</a></h1>
<p><em>A Hands-On Cookbook for Aspiring Blockchain Chefs</em></p>
<p>Substrate Recipes is a cookbook of working examples that demonstrate best practices when building
blockchains with <strong><a href="https://substrate.dev">Substrate</a></strong>. Each recipe contains
complete working code as well as a detailed writeup explaining the code.</p>
<h2><a class="header" href="#how-to-use-this-book" id="how-to-use-this-book">How to Use This Book</a></h2>
<p>You can read this book in any particular order. If you have a certain topic you want to dive into, or
know the subject/keyword to look for, please use the search button (the small magnifier on top
left) to search for the subject. The list is organized roughly in order of increasing complexity.</p>
<p>You can't learn to build blockchains by reading alone. As you work through the recipes, practice compiling, testing, and hacking on each Recipes. Play with
the code, extract patterns, and apply them to a problem that you want to solve!</p>
<p>If you haven't already, you should probably clone this repository right now.</p>
<pre><code class="language-bash">git clone git@github.com:substrate-developer-hub/recipes.git
</code></pre>
<h2><a class="header" href="#getting-help" id="getting-help">Getting Help</a></h2>
<p>When learning any new skill, you will inevitably get stuck at some point. When you do get stuck you
can seek help in several ways:</p>
<ul>
<li>Ask a question on <a href="https://stackoverflow.com/questions/tagged/substrate">Stack Overflow</a></li>
<li>Ask a question in the
<a href="https://app.element.io/#/room/!HzySYSaIhtyWrwiwEV:matrix.org">Substrate Technical Element channel</a></li>
<li>Open a <a href="https://github.com/substrate-developer-hub/recipes/issues/new">new issue</a> against this
repository</li>
</ul>
<h2><a class="header" href="#prerequisites" id="prerequisites">Prerequisites</a></h2>
<p>Each recipe targets a specific aspect of Substrate development and explains the details of that aspect. In all recipes some basic familiarity with Substrate development and a working Rust environment are assumed. Generally speaking you should meet the following prerequisites:</p>
<ul>
<li>Have a working Substrate development environment. There are excellent docs on <a href="https://substrate.dev/docs/en/knowledgebase/getting-started/">setting up a Substrate development environment</a>.</li>
<li>Understand the first ten chapters of <a href="https://doc.rust-lang.org/book/index.html">The Rust Book</a>. Rather than learning Rust <em>before</em> you learn Substrate, consider learning Rust <em>as</em>
you learn Substrate.</li>
<li>Complete the first few <a href="https://substrate.dev/en/tutorials">Official Substrate Tutorials</a>.</li>
</ul>
<h2><a class="header" href="#structure-of-a-substrate-node" id="structure-of-a-substrate-node">Structure of a Substrate Node</a></h2>
<p>It is useful to recognize that
<a href="https://youtu.be/05H4YsyPA-U?t=1789">coding is all about abstraction</a>.</p>
<p>To understand how the code in this repository is organized, let's first take a look at how a
Substrate node is constructed. Each node has many components that manage things like the transaction
queue, communicating over a P2P network, reaching consensus on the state of the blockchain, and the
chain's actual runtime logic. Each aspect of the node is interesting in its own right, and the
runtime is particularly interesting because it contains the business logic (aka &quot;state transition
function&quot;) that codifies the chain's functionality.</p>
<p>Much, but not all, of the Recipes focuses on writing runtimes with FRAME, Parity's Framework for
composing runtimes from individual building blocks called Pallets. Runtimes built with FRAME
typically contain several such pallets. The kitchen node you built previously follows this paradigm.</p>
<p><img src="img/substrate-architecture.png" alt="Substrate Architecture Diagram" /></p>
<h2><a class="header" href="#the-directories-in-our-kitchen" id="the-directories-in-our-kitchen">The Directories in our Kitchen</a></h2>
<p>If you haven't already, you should clone it now. There are five primary directories in this repository.</p>
<ul>
<li><strong>Consensus</strong>: Consensus engines for use in Substrate nodes.</li>
<li><strong>Nodes</strong>: Complete Substrate nodes ready to run.</li>
<li><strong>Pallets</strong>: Pallets for use in FRAME-based runtimes.</li>
<li><strong>Runtimes</strong>: Runtimes for use in Substrate nodes.</li>
<li><strong>Text</strong>: Source of <a href="https://substrate.dev/recipes">the book</a> written in markdown. This is what
you're reading right now.</li>
</ul>
<p>Exploring those directories reveals a tree that looks like this</p>
<pre><code>recipes
|
+-- consensus
  |
  +-- manual-seal
  |
  +-- sha3pow
|
+-- nodes
	|
	+-- basic-pow
	|
	+-- ...
	|
	+-- rpc-node
|
+-- pallets
	|
	+-- basic-token
	|
	+ ...
	|
	+-- weights
|
+-- runtimes
	|
	+-- api-runtime
	|
	+ ...
	|
	+-- weight-fee-runtime
|
+-- text
</code></pre>
<h2><a class="header" href="#inside-the-kitchen-node" id="inside-the-kitchen-node">Inside the Kitchen Node</a></h2>
<p>Let us take a deeper look at the
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/nodes/kitchen-node">Kitchen Node</a>.</p>
<p>Looking inside the Kitchen Node's <code>Cargo.toml</code> file we see that it has many dependencies. Most of
them come from Substrate itself. Indeed most parts of this Kitchen Node are not unique or
specialized, and Substrate offers robust implementations that we can use. The runtime does not come
from Substrate. Rather, we use our super-runtime which is in the <code>runtimes</code> folder.</p>
<p><strong><code>nodes/kitchen-node/Cargo.toml</code></strong></p>
<pre><code class="language-TOML"># This node is compatible with any of the runtimes below
# ---
# Common runtime configured with most Recipes pallets.
runtime = { package = &quot;super-runtime&quot;, path = &quot;../../runtimes/super-runtime&quot; }

# Runtime with custom weight and fee calculation.
# runtime = { package = &quot;weight-fee-runtime&quot;, path = &quot;../../runtimes/weight-fee-runtime&quot;}

# Runtime with off-chain worker enabled.
# To use this runtime, compile the node with `ocw` feature enabled,
#   `cargo build --release --features ocw`.
# runtime = { package = &quot;ocw-runtime&quot;, path = &quot;../../runtimes/ocw-runtime&quot; }

# Runtime with custom runtime-api (custom API only used in rpc-node)
# runtime = { package = &quot;api-runtime&quot;, path = &quot;../../runtimes/api-runtime&quot; }
# ---
</code></pre>
<p>The commented lines, quoted above, show that the Super Runtime is not the only runtime we could have
chosen. We could also use the Weight-Fee runtime, and I encourage you to try that experiment
(remember, instructions to re-compile the node are in the previous section).</p>
<p>Every node must have a runtime. You may confirm that by looking at the <code>Cago.toml</code> files of the
other nodes included in our kitchen.</p>
<h2><a class="header" href="#inside-the-super-runtime" id="inside-the-super-runtime">Inside the Super Runtime</a></h2>
<p>Having seen that the Kitchen Node depends on a runtime, let us now look deeper at the
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/runtimes/super-runtime">Super Runtime</a>.</p>
<p><strong><code>runtimes/super-runtime/Cargo.toml</code></strong></p>
<pre><code class="language-TOML"># -- snip --

# Substrate Pallets
balances = { package = 'pallet-balances', , ... }
transaction-payment = { package = 'pallet-transaction-payment', ,... }
# Recipe Pallets
adding-machine = { path = &quot;../../pallets/adding-machine&quot;, default-features = false }
basic-token = { path = &quot;../../pallets/basic-token&quot;, default-features = false }
</code></pre>
<p>Here we see that the runtime depends on many pallets. Some of these pallets come from Substrate
itself. Indeed, Substrate offers a rich collection of commonly used pallets which you may use in
your own runtimes. This runtime also contains several custom pallets that are written right here in
our Kitchen.</p>
<h2><a class="header" href="#common-patterns" id="common-patterns">Common Patterns</a></h2>
<p>We've just observed the general pattern used throughout the recipes. From the inside out, we see a
piece of pallet code stored in <code>pallets/&lt;pallet-name&gt;/src/lib.rs</code>. The pallet is then included into
a runtime by adding its name and relative path in <code>runtimes/&lt;runtime-name&gt;/Cargo.toml</code>. That runtime
is then installed in a node by adding its name and relative path in <code>nodes/&lt;node-name&gt;/Cargo.toml</code>.</p>
<p>Some recipes explore aspects of Blockchain development that are outside of the runtime. Looking back
to our node architecture at the beginning of this section, you can imagine that changing a node's
RPC or Consensus would be conceptually similar to changing its runtime.</p>
<h1><a class="header" href="#pallets" id="pallets">Pallets</a></h1>
<p>Pallets are individual pieces of runtime logic for use in FRAME runtimes. Learn about them in this section of the cookbook.</p>
<h1><a class="header" href="#hello-substrate" id="hello-substrate">Hello Substrate</a></h1>
<p><code>pallets/hello-substrate</code>
<a href="https://playground-staging.substrate.dev/?deploy=recipes&amp;files=%2Fhome%2Fsubstrate%2Fworkspace%2Fpallets%2Fhello-substrate%2Fsrc%2Flib.rs">
<img src="https://img.shields.io/badge/Playground-Try%20it!-brightgreen?logo=Parity%20Substrate" alt="Try on playground" />
</a>
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/hello-substrate/src/lib.rs">
<img src="https://img.shields.io/badge/Github-View%20Code-brightgreen?logo=github" alt="View on GitHub" />
</a></p>
<p>This pallet has one
dispatchable call that prints a message to the node's output. Printing to the node log is not common for runtimes, but can be quite useful when debugging and as a &quot;hello world&quot; example. Because this is the first pallet in the recipes, we'll also take a look at the general structure of a pallet.</p>
<h2><a class="header" href="#no-std" id="no-std">No Std</a></h2>
<p>The very first line of code tells the rust compiler that this crate should not use rust's standard
library except when explicitly told to. This is useful because Substrate runtimes compile to Web
Assembly where the standard library is not available.</p>
<pre><code class="language-rust ignore">#![cfg_attr(not(feature = &quot;std&quot;), no_std)]
</code></pre>
<h2><a class="header" href="#imports" id="imports">Imports</a></h2>
<p>Next, you'll find imports that come from various parts of the Substrate framework. All pallets will
import from a few common crates including
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/frame_support/index.html"><code>frame-support</code></a>, and
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/frame_system/index.html"><code>frame-system</code></a>. Complex pallets will have many
imports. The <code>hello-substrate</code> pallet uses these imports.</p>
<pre><code class="language-rust ignore">use frame_support::{ decl_module, dispatch::DispatchResult, debug };
use frame_system::{ self as system, ensure_signed };
use sp_runtime::print;
</code></pre>
<h2><a class="header" href="#tests" id="tests">Tests</a></h2>
<p>Next we see a reference to the tests module. This pallet, as with most recipes pallets, has tests written in a separate file called
<code>tests.rs</code>.</p>
<h2><a class="header" href="#configuration-trait" id="configuration-trait">Configuration Trait</a></h2>
<p>Next, each pallet has a configuration trait which is called <code>Trait</code>. The configuration trait can be
used to access features from other pallets, or <a href="./constants.html">constants</a> that affect
the pallet's behavior. This pallet is simple enough that our configuration trait can remain empty,
although it must still exist.</p>
<pre><code class="language-rust ignore">pub trait Trait: system::Trait {}
</code></pre>
<h2><a class="header" href="#dispatchable-calls" id="dispatchable-calls">Dispatchable Calls</a></h2>
<p>A Dispatchable call is a function that a blockchain user can call as part of an Extrinsic.
&quot;Extrinsic&quot; is Substrate jargon meaning a call from outside of the chain. Most of the time they are
transactions, and for now it is fine to think of them as transactions. Dispatchable calls are
defined in the
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/frame_support/macro.decl_module.html"><code>decl_module!</code> macro</a>.</p>
<pre><code class="language-rust ignore">decl_module! {
	pub struct Module&lt;T: Trait&gt; for enum Call where origin: T::Origin {

		/// A function that says hello to the user by printing messages to the node log
		#[weight = 10_000]
		pub fn say_hello(origin) -&gt; DispatchResult {
			// --snip--
		}

		// More dispatchable calls could go here
	}
}
</code></pre>
<p>As you can see, our <code>hello-substrate</code> pallet has a dispatchable call that takes a single argument,
called <code>origin</code>. The call returns a
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/frame_support/dispatch/type.DispatchResult.html"><code>DispatchResult</code></a> which
can be either <code>Ok(())</code> indicating that the call succeeded, or an <code>Err</code> which is demonstrated in most other recipes pallets.</p>
<h3><a class="header" href="#weight-annotations" id="weight-annotations">Weight Annotations</a></h3>
<p>Right before the <code>hello-substrate</code> function, we see the line <code>#[weight = 10_000]</code>. This line
attaches a default weight to the call. Ultimately weights affect the fees a user will have to pay to
call the function. Weights are a very interesting aspect of developing with Substrate, but they too
shall be covered later in the section on <a href="./weights.html">Weights</a>. For now, and for many of
the recipes pallets, we will simply use the default weight as we have done here.</p>
<h2><a class="header" href="#inside-a-dispatchable-call" id="inside-a-dispatchable-call">Inside a Dispatchable Call</a></h2>
<p>Let's take a closer look at our dispatchable call.</p>
<pre><code class="language-rust ignore">pub fn say_hello(origin) -&gt; DispatchResult {
	// Ensure that the caller is a regular keypair account
	let caller = ensure_signed(origin)?;

	// Print a message
	print(&quot;Hello World&quot;);
	// Inspecting variables
	debug::info!(&quot;Request sent by: {:?}&quot;, caller);

	// Indicate that this call succeeded
	Ok(())
}
</code></pre>
<p>This function essentially does three things. First, it uses the
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/frame_system/fn.ensure_signed.html"><code>ensure_signed</code> function</a> to ensure
that the caller of the function was a regular user who owns a private key. This function also
returns who that caller was. We store the caller's identity in the <code>caller</code> variable.</p>
<p>Second, it prints a message and logs the caller. Notice that we aren't using Rust's normal
<code>println!</code> macro, but rather a special
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sp_runtime/fn.print.html"><code>print</code> function</a> and
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/frame_support/debug/macro.info.html"><code>debug::info!</code> macro</a>. The reason for
this is explained in the next section.</p>
<p>Finally, the call returns <code>Ok(())</code> to indicate that the call has succeeded. At a glance it seems
that there is no way for this call to fail, but this is not quite true. The <code>ensure_signed</code>
function, used at the beginning, can return an error if the call was not from a signed origin. This
is the first time we're seeing the important paradigm &quot;<strong>Verify first, write last</strong>&quot;. In Substrate
development, it is important that you always ensure preconditions are met and return errors at the
beginning. After these checks have completed, then you may begin the function's computation.</p>
<h2><a class="header" href="#printing-from-the-runtime" id="printing-from-the-runtime">Printing from the Runtime</a></h2>
<p>Printing to the terminal from a Rust program is typically very simple using the <code>println!</code> macro.
However, Substrate runtimes are compiled to both Web Assembly and a regular native binary, and do
not have access to rust's standard library. That means we cannot use the regular <code>println!</code>. I
encourage you to modify the code to try using <code>println!</code> and confirm that it will not compile.
Nonetheless, printing a message from the runtime is useful both for logging information, and also
for debugging.</p>
<p><img src="./img/substrate-architecture.png" alt="Substrate Architecture Diagram" /></p>
<p>At the top of our pallet, we imported <code>sp_runtime</code>'s
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sp_runtime/fn.print.html"><code>print</code> function</a>. This special function allows
the runtime to pass a message for printing to the outer part of the node which is not compiled to
Wasm and does have access to the standard library and can perform regular IO. This function is only
able to print items that implement the
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sp_runtime/traits/trait.Printable.html"><code>Printable</code> trait</a>. Luckily all
the primitive types already implement this trait, and you can implement the trait for your own
datatypes too.</p>
<p><strong>Print function note:</strong> To actually see the printed messages, we need to use the flag
<code>-lruntime=debug</code> when running the kitchen node. So, for the kitchen node, the command would become
<code>./target/release/kitchen-node --dev -lruntime=debug</code>.</p>
<p>The next line demonstrates using <code>debug::info!</code> macro to log to the screen and also inspecting the
variable's content. The syntax inside the macro is very similar to what regular rust macro
<code>println!</code> takes.</p>
<p><strong>Runtime logger note:</strong> When we execute the runtime in native, <code>debug::info!</code> messages are printed.
However, if we execute the runtime in Wasm, then an additional step to initialise
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/frame_support/debug/struct.RuntimeLogger.html">RuntimeLogger</a> is required.</p>
<h1><a class="header" href="#using-events" id="using-events">Using Events</a></h1>
<p><code>pallets/simple-event</code>
<a href="https://playground-staging.substrate.dev/?deploy=recipes&amp;files=%2Fhome%2Fsubstrate%2Fworkspace%2Fpallets%2Fsimple-event%2Fsrc%2Flib.rs">
<img src="https://img.shields.io/badge/Playground-Try%20it!-brightgreen?logo=Parity%20Substrate" alt="Try on playground" />
</a>
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/simple-event/src/lib.rs">
<img src="https://img.shields.io/badge/Github-View%20Code-brightgreen?logo=github" alt="View on GitHub" />
</a></p>
<p><code>pallets/generic-event</code>
<a href="https://playground-staging.substrate.dev/?deploy=recipes&amp;files=%2Fhome%2Fsubstrate%2Fworkspace%2Fpallets%2Fgeneric-event%2Fsrc%2Flib.rs">
<img src="https://img.shields.io/badge/Playground-Try%20it!-brightgreen?logo=Parity%20Substrate" alt="Try on playground" />
</a>
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/generic-event/src/lib.rs">
<img src="https://img.shields.io/badge/Github-View%20Code-brightgreen?logo=github" alt="View on GitHub" />
</a></p>
<p>Having a <a href="https://substrate.dev/docs/en/knowledgebase/getting-started/glossary#transaction">transaction</a> included in a
block does not guarantee that the function executed successfully. To verify that
functions have executed successfully, emit an
<a href="https://substrate.dev/docs/en/knowledgebase/getting-started/glossary#events">event</a> at the bottom of the function body.</p>
<p>Events notify the off-chain world of successful state transitions.</p>
<h2><a class="header" href="#some-prerequisites" id="some-prerequisites">Some Prerequisites</a></h2>
<p>When using events, we have to include the <code>Event</code> type in our configuration trait. Although the
syntax is a bit complex, it is the same every time. If you are a skilled Rust programmer you will
recognize this as a series of <a href="https://doc.rust-lang.org/book/ch10-02-traits.html">trait bounds</a>. If
you don't recognize this feature of Rust yet, don't worry; it is the same every time, so you can
just copy it and move on.</p>
<pre><code class="language-rust ignore">pub trait Trait: system::Trait {
	type Event: From&lt;Event&gt; + Into&lt;&lt;Self as system::Trait&gt;::Event&gt;;
}
</code></pre>
<p>Next we have to add a line inside of the <code>decl_module!</code> macro which generates the <code>deposit_event</code>
function we'll use later when emitting our events. Even experienced Rust programmers will not
recognize this syntax because it is unique to this macro. Just copy it each time.</p>
<pre><code class="language-rust ignore">decl_module! {
	pub struct Module&lt;T: Trait&gt; for enum Call where origin: T::Origin {

		// This line is new
		fn deposit_event() = default;

		// --snip--
	}
}
</code></pre>
<h2><a class="header" href="#declaring-events" id="declaring-events">Declaring Events</a></h2>
<p>To declare an event, use the
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/frame_support/macro.decl_event.html"><code>decl_event!</code> macro</a>. Like any rust
enum, Events have names and can optionally carry data with them. The syntax is slightly different
depending on whether the events carry data of primitive types, or generic types from the pallet's
configuration trait. These two techniques are demonstrated in the <code>simple-event</code> and <code>generic-event</code>
pallets respectively.</p>
<h3><a class="header" href="#simple-events" id="simple-events">Simple Events</a></h3>
<p>The simplest example of an event uses the following syntax</p>
<pre><code class="language-rust ignore">decl_event!(
	pub enum Event {
		EmitInput(u32),
	}
);
</code></pre>
<h3><a class="header" href="#events-with-generic-types" id="events-with-generic-types">Events with Generic Types</a></h3>
<p>Sometimes, events might contain types from the pallet's Configuration Trait. In this case, it is necessary to
specify additional syntax</p>
<pre><code class="language-rust ignore">decl_event!(
	pub enum Event&lt;T&gt; where AccountId = &lt;T as system::Trait&gt;::AccountId {
		EmitInput(AccountId, u32),
	}
);
</code></pre>
<p>This example also demonstrates how the <code>where</code> clause can be used to specify type aliasing for more
readable code.</p>
<h2><a class="header" href="#emitting-events" id="emitting-events">Emitting Events</a></h2>
<p>Events are emitted from dispatchable calls using the <code>deposit_event</code> method.</p>
<blockquote>
<p>Events are not emitted on block 0. So any dispatchable calls made during genesis block formation
will have no events emitted.</p>
</blockquote>
<h3><a class="header" href="#simple-events-1" id="simple-events-1">Simple Events</a></h3>
<p>The event is emitted at the bottom of the <code>do_something</code> function body.</p>
<pre><code class="language-rust ignore">Self::deposit_event(Event::EmitInput(new_number));
</code></pre>
<h3><a class="header" href="#events-with-generic-types-1" id="events-with-generic-types-1">Events with Generic Types</a></h3>
<p>The syntax for <code>deposit_event</code> now takes the <code>RawEvent</code> type because it is generic over the pallet's
configuration trait.</p>
<pre><code class="language-rust ignore">Self::deposit_event(RawEvent::EmitInput(user, new_number));
</code></pre>
<h2><a class="header" href="#constructing-the-runtime" id="constructing-the-runtime">Constructing the Runtime</a></h2>
<p>For the first time in the recipes, our pallet has an associated type in its configuration trait. We
must specify this type when implementing its trait. In the case of the <code>Event</code> type, this is
entirely straight forward, and looks the same for both simple events and generic events.</p>
<pre><code class="language-rust ignore">impl simple_event::Trait for Runtime {
	type Event = Event;
}
</code></pre>
<p>Events, like dispatchable calls and storage items, requires a slight change to the line in
<code>construct_runtime!</code>. Notice that the <code>&lt;T&gt;</code> is necessary for generic events.</p>
<pre><code class="language-rust ignore">construct_runtime!(
	pub enum Runtime where
		Block = Block,
		NodeBlock = opaque::Block,
		UncheckedExtrinsic = UncheckedExtrinsic
	{
		// --snip--
		GenericEvent: generic_event::{Module, Call, Event&lt;T&gt;},
		SimpleEvent: simple_event::{Module, Call, Event},
	}
);
</code></pre>
<h1><a class="header" href="#storage-maps" id="storage-maps">Storage Maps</a></h1>
<p><code>pallets/simple-map</code>
<a href="https://playground-staging.substrate.dev/?deploy=recipes&amp;files=%2Fhome%2Fsubstrate%2Fworkspace%2Fpallets%2Fsimple-map%2Fsrc%2Flib.rs">
<img src="https://img.shields.io/badge/Playground-Try%20it!-brightgreen?logo=Parity%20Substrate" alt="Try on playground" />
</a>
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/simple-map/src/lib.rs">
<img src="https://img.shields.io/badge/Github-View%20Code-brightgreen?logo=github" alt="View on GitHub" />
</a></p>
<p>In this recipe, we will see how
to store a mapping from keys to values, similar to Rust's own
<a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a>.</p>
<h2><a class="header" href="#declaring-a-storagemap" id="declaring-a-storagemap">Declaring a <code>StorageMap</code></a></h2>
<p>We declare a single storage map with the following syntax.</p>
<pre><code class="language-rust ignore">decl_storage! {
	trait Store for Module&lt;T: Trait&gt; as SimpleMap {
		SimpleMap get(fn simple_map): map hasher(blake2_128_concat) T::AccountId =&gt; u32;
	}
}
</code></pre>
<p>Much of this should look familiar to you from storage values. Reading the line from left to right we
have:</p>
<ul>
<li><code>SimpleMap</code> - the name of the storage map</li>
<li><code>get(fn simple_map)</code> - the name of a getter function that will return values from the map.</li>
<li><code>: map hasher(blake2_128_concat)</code> - beginning of the type declaration. This is a map and it will
use the
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/frame_support/trait.Hashable.html#tymethod.blake2_128_concat"><code>blake2_128_concat</code></a>
hasher. More on this below.</li>
<li><code>T::AccountId =&gt; u32</code> - The specific key and value tyes of the map. This is a map from
<code>AccountId</code>s to <code>u32</code>s.</li>
</ul>
<h2><a class="header" href="#choosing-a-hasher" id="choosing-a-hasher">Choosing a Hasher</a></h2>
<p>Although the syntax above is complex, most of it should be straightforward if you've understood the
recipe on storage values. The last unfamiliar piece of writing a storage map is choosing which
hasher to use. In general you should choose one of the three following hashers. The choice of hasher
will affect the performance and security of your chain. If you don't want to think much about this,
just choose <code>blake2_128_concat</code> and skip to the next section.</p>
<h3><a class="header" href="#blake2_128_concat" id="blake2_128_concat"><code>blake2_128_concat</code></a></h3>
<p>This is a cryptographically secure hash function, and is always safe to use. It is reasonably
efficient, and will keep your storage tree balanced. You <em>must</em> choose this hasher if users of your
chain have the ability to affect the storage keys. In this pallet, the keys are <code>AccountId</code>s. At
first it may <em>seem</em> that the user doesn't affect the <code>AccountId</code>, but in reality a malicious user
can generate thousands of accounts and use the one that will affect the chain's storage tree in the
way the attacker likes. For this reason, we have chosen to use the <code>blake2_128_concat</code> hasher.</p>
<h3><a class="header" href="#twox_64_concat" id="twox_64_concat"><code>twox_64_concat</code></a></h3>
<p>This hasher is <em>not</em> cryptographically secure, but is more efficient than blake2. Thus it represents
trading security for performance. You should <em>not</em> use this hasher if chain users can affect the
storage keys. However, it is perfectly safe to use this hasher to gain performance in scenarios
where the users do not control the keys. For example, if the keys in your map are sequentially
increasing indices and users cannot cause the indices to rapidly increase, then this is a perfectly
reasonable choice.</p>
<h3><a class="header" href="#identity" id="identity"><code>identity</code></a></h3>
<p>The <code>identity</code> &quot;hasher&quot; is really not a hasher at all, but merely an
<a href="https://en.wikipedia.org/wiki/Identity_function">identity function</a> that returns the same value it
receives. This hasher is only an option when the key type in your storage map is <em>already</em> a hash,
and is not controllable by the user. If you're in doubt whether the user can influence the key just
use blake2.</p>
<h2><a class="header" href="#the-storage-map-api" id="the-storage-map-api">The Storage Map API</a></h2>
<p>This pallet demonstrated some of the most common methods available in a storage map including
<code>insert</code>, <code>get</code>, <code>take</code>, and <code>contains_key</code>.</p>
<pre><code class="language-rust ignore">// Insert
&lt;SimpleMap&lt;T&gt;&gt;::insert(&amp;user, entry);

// Get
let entry = &lt;SimpleMap&lt;T&gt;&gt;::get(account);

// Take
let entry = &lt;SimpleMap&lt;T&gt;&gt;::take(&amp;user);

// Contains Key
&lt;SimpleMap&lt;T&gt;&gt;::contains_key(&amp;user)
</code></pre>
<p>The rest of the API is documented in the rustdocs on the
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/frame_support/storage/trait.StorageMap.html"><code>StorageMap</code> trait</a>. You do
not need to explicitly <code>use</code> this trait because the <code>decl_storage!</code> macro will do it for you if you
use a storage map.</p>
<h1><a class="header" href="#cache-multiple-calls" id="cache-multiple-calls">Cache Multiple Calls</a></h1>
<p><code>pallets/storage-cache</code>
<a href="https://playground-staging.substrate.dev/?deploy=recipes&amp;files=%2Fhome%2Fsubstrate%2Fworkspace%2Fpallets%2Fstorage-cache%2Fsrc%2Flib.rs">
<img src="https://img.shields.io/badge/Playground-Try%20it!-brightgreen?logo=Parity%20Substrate" alt="Try on playground" />
</a>
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/storage-cache/src/lib.rs">
<img src="https://img.shields.io/badge/Github-View%20Code-brightgreen?logo=github" alt="View on GitHub" />
</a></p>
<p>Calls to runtime storage have an associated cost and developers should strive to minimize the number
of calls.</p>
<pre><code class="language-rust ignore">decl_storage! {
	trait Store for Module&lt;T: Trait&gt; as StorageCache {
		// copy type
		SomeCopyValue get(fn some_copy_value): u32;

		// clone type
		KingMember get(fn king_member): T::AccountId;
		GroupMembers get(fn group_members): Vec&lt;T::AccountId&gt;;
	}
}
</code></pre>
<h2><a class="header" href="#copy-types" id="copy-types">Copy Types</a></h2>
<p>For <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a> types, it is easy to reuse
previous storage calls by simply reusing the value, which is automatically cloned upon reuse. In the
code below, the second call is unnecessary:</p>
<pre><code class="language-rust ignore">fn increase_value_no_cache(origin, some_val: u32) -&gt; DispatchResult {
	let _ = ensure_signed(origin)?;
	let original_call = &lt;SomeCopyValue&gt;::get();
	let some_calculation = original_call.checked_add(some_val).ok_or(&quot;addition overflowed1&quot;)?;
	// this next storage call is unnecessary and is wasteful
	let unnecessary_call = &lt;SomeCopyValue&gt;::get();
	// should've just used `original_call` here because u32 is copy
	let another_calculation = some_calculation.checked_add(unnecessary_call).ok_or(&quot;addition overflowed2&quot;)?;
	&lt;SomeCopyValue&gt;::put(another_calculation);
	let now = &lt;system::Module&lt;T&gt;&gt;::block_number();
	Self::deposit_event(RawEvent::InefficientValueChange(another_calculation, now));
	Ok(())
}
</code></pre>
<p>Instead, the initial call value should be reused. In this example, the <code>SomeCopyValue</code> value is
<a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a> so we should prefer the following
code without the unnecessary second call to storage:</p>
<pre><code class="language-rust ignore">fn increase_value_w_copy(origin, some_val: u32) -&gt; DispatchResult {
	let _ = ensure_signed(origin)?;
	let original_call = &lt;SomeCopyValue&gt;::get();
	let some_calculation = original_call.checked_add(some_val).ok_or(&quot;addition overflowed1&quot;)?;
	// uses the original_call because u32 is copy
	let another_calculation = some_calculation.checked_add(original_call).ok_or(&quot;addition overflowed2&quot;)?;
	&lt;SomeCopyValue&gt;::put(another_calculation);
	let now = &lt;system::Module&lt;T&gt;&gt;::block_number();
	Self::deposit_event(RawEvent::BetterValueChange(another_calculation, now));
	Ok(())
}
</code></pre>
<h2><a class="header" href="#clone-types" id="clone-types">Clone Types</a></h2>
<p>If the type was not <code>Copy</code>, but was <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a>,
then it is still better to clone the value in the method than to make another call to runtime
storage.</p>
<p>The runtime methods enable the calling account to swap the <code>T::AccountId</code> value in storage if</p>
<ol>
<li>the existing storage value is not in <code>GroupMembers</code> AND</li>
<li>the calling account is in <code>GroupMembers</code></li>
</ol>
<p>The first implementation makes a second unnecessary call to runtime storage instead of cloning the
call for <code>existing_key</code>:</p>
<pre><code class="language-rust ignore">fn swap_king_no_cache(origin) -&gt; DispatchResult {
	let new_king = ensure_signed(origin)?;
	let existing_king = &lt;KingMember&lt;T&gt;&gt;::get();

	// only places a new account if
	// (1) the existing account is not a member &amp;&amp;
	// (2) the new account is a member
	ensure!(!Self::is_member(&amp;existing_king), &quot;current king is a member so maintains priority&quot;);
	ensure!(Self::is_member(&amp;new_king), &quot;new king is not a member so doesn't get priority&quot;);

	// BAD (unnecessary) storage call
	let old_king = &lt;KingMember&lt;T&gt;&gt;::get();
	// place new king
	&lt;KingMember&lt;T&gt;&gt;::put(new_king.clone());

	Self::deposit_event(RawEvent::InefficientKingSwap(old_king, new_king));
	Ok(())
}
</code></pre>
<p>If the <code>existing_key</code> is used without a <code>clone</code> in the event emission instead of <code>old_king</code>, then
the compiler returns the following error</p>
<pre><code class="language-bash">error[E0382]: use of moved value: `existing_king`
  --&gt; src/lib.rs:93:63
   |
80 |             let existing_king = &lt;KingMember&lt;T&gt;&gt;::get();
   |                 ------------- move occurs because `existing_king` has type `&lt;T as frame_system::Trait&gt;::AccountId`, which does not implement the `Copy` trait
...
85 |             ensure!(!Self::is_member(existing_king), &quot;is a member so maintains priority&quot;);
   |                                      ------------- value moved here
...
93 |             Self::deposit_event(RawEvent::InefficientKingSwap(existing_king, new_king));
   |                                                               ^^^^^^^^^^^^^ value used here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: Could not compile `storage-cache`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Fixing this only requires cloning the original value before it is moved:</p>
<pre><code class="language-rust ignore">fn swap_king_with_cache(origin) -&gt; DispatchResult {
	let new_king = ensure_signed(origin)?;
	let existing_king = &lt;KingMember&lt;T&gt;&gt;::get();
	// prefer to clone previous call rather than repeat call unnecessarily
	let old_king = existing_king.clone();

	// only places a new account if
	// (1) the existing account is not a member &amp;&amp;
	// (2) the new account is a member
	ensure!(!Self::is_member(&amp;existing_king), &quot;current king is a member so maintains priority&quot;);
	ensure!(Self::is_member(&amp;new_king), &quot;new king is not a member so doesn't get priority&quot;);

	// &lt;no (unnecessary) storage call here&gt;
	// place new king
	&lt;KingMember&lt;T&gt;&gt;::put(new_king.clone());

	Self::deposit_event(RawEvent::BetterKingSwap(old_king, new_king));
	Ok(())
}
</code></pre>
<p>Not all types implement <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a> or
<a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a>, so it is important to discern other
patterns that minimize and alleviate the cost of calls to storage.</p>
<h1><a class="header" href="#using-vectors-as-sets" id="using-vectors-as-sets">Using Vectors as Sets</a></h1>
<p><code>pallets/vec-set</code>
<a href="https://playground-staging.substrate.dev/?deploy=recipes&amp;files=%2Fhome%2Fsubstrate%2Fworkspace%2Fpallets%2Fvec-set%2Fsrc%2Flib.rs">
<img src="https://img.shields.io/badge/Playground-Try%20it!-brightgreen?logo=Parity%20Substrate" alt="Try on playground" />
</a>
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/vec-set/src/lib.rs">
<img src="https://img.shields.io/badge/Github-View%20Code-brightgreen?logo=github" alt="View on GitHub" />
</a></p>
<p>A <a href="https://en.wikipedia.org/wiki/Set_(abstract_data_type)">Set</a> is an unordered data structure
that stores entries without duplicates. Substrate's storage API does not provide a way to declare
sets explicitly, but they can be implemented using either vectors or maps.</p>
<p>This recipe demonstrates how to implement a storage set on top of a vector, and explores the
performance of the implementation. When implementing a set in your own runtime, you should compare
this technique to implementing a <a href="./map-set.html"><code>map-set</code></a>.</p>
<p>In this pallet we implement a set of <code>AccountId</code>s. We do not use the set for anything in this
pallet; we simply maintain the set. Using the set is demonstrated in the recipe on
<a href="./pallet-coupling.html">pallet coupling</a>. We provide dispatchable calls to add and remove members,
ensuring that the number of members never exceeds a hard-coded maximum.</p>
<pre><code class="language-rust ignore">/// A maximum number of members. When membership reaches this number, no new members may join.
pub const MAX_MEMBERS: usize = 16;
</code></pre>
<h2><a class="header" href="#storage-item" id="storage-item">Storage Item</a></h2>
<p>We will store the members of our set in a Rust
<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec</code></a>. A <code>Vec</code> is a collection of elements that
is ordered and may contain duplicates. Because the <code>Vec</code> provides more functionality than our set
needs, we are able to build a set from the <code>Vec</code>. We declare our single storage item as so</p>
<pre><code class="language-rust ignore">decl_storage! {
	trait Store for Module&lt;T: Trait&gt; as VecSet {
		// The set of all members. Stored as a single vec
		Members get(fn members): Vec&lt;T::AccountId&gt;;
	}
}
</code></pre>
<p>In order to use the <code>Vec</code> successfully as a set, we will need to manually ensure that no duplicate
entries are added. To ensure reasonable performance, we will enforce that the <code>Vec</code> always remains
sorted. This allows for quickly determining whether an item is present using a
<a href="https://en.wikipedia.org/wiki/Binary_search_algorithm">binary search</a>.</p>
<h2><a class="header" href="#adding-members" id="adding-members">Adding Members</a></h2>
<p>Any user may join the membership set by calling the <code>add_member</code> dispatchable, providing they are
not already a member and the membership limit has not been reached. We check for these two
conditions first, and then insert the new member only after we are sure it is safe to do so. This is
an example of the mnemonic idiom, &quot;<strong>verify first write last</strong>&quot;.</p>
<pre><code class="language-rust ignore">pub fn add_member(origin) -&gt; DispatchResult {
	let new_member = ensure_signed(origin)?;

	let mut members = Members::&lt;T&gt;::get();
	ensure!(members.len() &lt; MAX_MEMBERS, Error::&lt;T&gt;::MembershipLimitReached);

	// We don't want to add duplicate members, so we check whether the potential new
	// member is already present in the list. Because the list is always ordered, we can
	// leverage the binary search which makes this check O(log n).
	match members.binary_search(&amp;new_member) {
		// If the search succeeds, the caller is already a member, so just return
		Ok(_) =&gt; Err(Error::&lt;T&gt;::AlreadyMember.into()),
		// If the search fails, the caller is not a member and we learned the index where
		// they should be inserted
		Err(index) =&gt; {
			members.insert(index, new_member.clone());
			Members::&lt;T&gt;::put(members);
			Self::deposit_event(RawEvent::MemberAdded(new_member));
			Ok(())
		}
	}
}
</code></pre>
<p>If it turns out that the caller is not already a member, the binary search will fail. In this case
it still returns the index into the <code>Vec</code> at which the member would have been stored had they been
present. We then use this information to insert the member at the appropriate location, thus
maintaining a sorted <code>Vec</code>.</p>
<h2><a class="header" href="#removing-a-member" id="removing-a-member">Removing a Member</a></h2>
<p>Removing a member is straightforward. We begin by looking for the caller in the list. If not
present, there is no work to be done. If the caller is present, the search algorithm returns her
index, and she can be removed.</p>
<pre><code class="language-rust ignore">fn remove_member(origin) -&gt; DispatchResult {
	let old_member = ensure_signed(origin)?;

	let mut members = Members::&lt;T&gt;::get();

	// We have to find out where, in the sorted vec the member is, if anywhere.
	match members.binary_search(&amp;old_member) {
		// If the search succeeds, the caller is a member, so remove her
		Ok(index) =&gt; {
			members.remove(index);
			Members::&lt;T&gt;::put(members);
			Self::deposit_event(RawEvent::MemberRemoved(old_member));
			Ok(())
		},
		// If the search fails, the caller is not a member, so just return
		Err(_) =&gt; Err(Error::&lt;T&gt;::NotMember.into()),
	}
}
</code></pre>
<h2><a class="header" href="#performance" id="performance">Performance</a></h2>
<p>Now that we have built our set, let's analyze its performance in some common operations.</p>
<h3><a class="header" href="#membership-check" id="membership-check">Membership Check</a></h3>
<p>In order to check for the presence of an item in a <code>vec-set</code>, we make a single storage read, decode
the entire vector, and perform a binary search.</p>
<p>DB Reads: O(1) Decoding: O(n) Search: O(log n)</p>
<h3><a class="header" href="#updating" id="updating">Updating</a></h3>
<p>Updates to the set, such as adding and removing members as we demonstrated, requires first
performing a membership check. It also requires re-encoding the entire <code>Vec</code> and storing it back in
the database. Finally, it still costs the normal
<a href="https://stackoverflow.com/q/200384/4184410">amortized constant time</a> associated with mutating a
<code>Vec</code>.</p>
<p>DB Writes: O(1) Encoding: O(n)</p>
<h3><a class="header" href="#iteration" id="iteration">Iteration</a></h3>
<p>Iterating over all items in a <code>vec-set</code> is achieved by using the <code>Vec</code>'s own
<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter"><code>iter</code> method</a>. The entire set can
be read from storage in one go, and each item must be decoded. Finally, the actual processing you do
on the items will take some time.</p>
<p>DB Reads: O(1) Decoding: O(n) Processing: O(n)</p>
<p>Because accessing the database is a relatively slow operation, reading the entire list in a single
read is a big win. If you need to iterate over the data frequently, you may want a <code>vec-set</code>.</p>
<h3><a class="header" href="#a-note-on-weights" id="a-note-on-weights">A Note on Weights</a></h3>
<p>It is always important that the weight associated with your dispatchables represent the actual time
it takes to execute them. In this pallet, we have provided an upper bound on the size of the set,
which places an upper bound on the computation - this means we can use constant weight annotations.
Your set operations should either have a maximum size or a <a href="./weights.html">custom weight function</a>
that captures the computation appropriately.</p>
<h1><a class="header" href="#using-maps-as-sets" id="using-maps-as-sets">Using Maps as Sets</a></h1>
<p><code>pallets/map-set</code>
<a href="https://playground-staging.substrate.dev/?deploy=recipes&amp;files=%2Fhome%2Fsubstrate%2Fworkspace%2Fpallets%2Fmap-set%2Fsrc%2Flib.rs">
<img src="https://img.shields.io/badge/Playground-Try%20it!-brightgreen?logo=Parity%20Substrate" alt="Try on playground" />
</a>
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/map-set/src/lib.rs">
<img src="https://img.shields.io/badge/Github-View%20Code-brightgreen?logo=github" alt="View on GitHub" />
</a></p>
<p>A <a href="https://en.wikipedia.org/wiki/Set_(abstract_data_type)">Set</a> is an unordered data structure
that stores entries without duplicates. Substrate's storage API does not provide a way to declare
sets explicitly, but they can be implemented using either vectors or maps.</p>
<p>This recipe shows how to implement a storage set on top of a map, and explores the performance of
the implementation. When implementing a set in your own runtime, you should compare this technique
to implementing a <a href="./vec-set.html"><code>vec-set</code></a>.</p>
<p>In this pallet we implement a set of <code>AccountId</code>s. We do not use the set for anything in this
pallet; we simply maintain its membership. Using the set is demonstrated in the recipe on
<a href="./pallet-coupling.html">pallet coupling</a>. We provide dispatchable calls to add and remove members,
ensuring that the number of members never exceeds a hard-coded maximum.</p>
<pre><code class="language-rust ignore">/// A maximum number of members. When membership reaches this number, no new members may join.
pub const MAX_MEMBERS: u32 = 16;
</code></pre>
<h2><a class="header" href="#storage-item-1" id="storage-item-1">Storage Item</a></h2>
<p>We will store the members of our set as the keys in one of Substrate's
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/frame_support/storage/trait.StorageMap.html"><code>StorageMap</code></a>s. There is also
a recipe specifically about <a href="./storage-maps.html">using storage maps</a>. The storage map itself does not
track its size internally, so we introduce a second storage value for this purpose.</p>
<pre><code class="language-rust ignore">decl_storage! {
	trait Store for Module&lt;T: Trait&gt; as VecMap {
		// The set of all members.
		Members get(fn members): map hasher(blake2_128_concat) T::AccountId =&gt; ();
		// The total number of members stored in the map.
		// Because the map does not store its size, we must store it separately
		MemberCount: u32;
	}
}
</code></pre>
<p>The <em>value</em> stored in the map is <code>()</code> because we only care about the keys.</p>
<h2><a class="header" href="#adding-members-1" id="adding-members-1">Adding Members</a></h2>
<p>Any user may join the membership set by calling the <code>add_member</code> dispatchable, so long as they are
not already a member and the membership limit has not been reached. We check for these two
conditions first, and then insert the new member only after we are sure it is safe to do so.</p>
<pre><code class="language-rust ignore">fn add_member(origin) -&gt; DispatchResult {
	let new_member = ensure_signed(origin)?;

	let member_count = MemberCount::get();
	ensure!(member_count &lt; MAX_MEMBERS, Error::&lt;T&gt;::MembershipLimitReached);

	// We don't want to add duplicate members, so we check whether the potential new
	// member is already present in the list. Because the membership is stored as a hash
	// map this check is constant time O(1)
	ensure!(!Members::&lt;T&gt;::contains_key(&amp;new_member), Error::&lt;T&gt;::AlreadyMember);

	// Insert the new member and emit the event
	Members::&lt;T&gt;::insert(&amp;new_member, ());
	MemberCount::put(member_count + 1); // overflow check not necessary because of maximum
	Self::deposit_event(RawEvent::MemberAdded(new_member));
	Ok(())
}
</code></pre>
<p>When we successfully add a new member, we also manually update the size of the set.</p>
<h2><a class="header" href="#removing-a-member-1" id="removing-a-member-1">Removing a Member</a></h2>
<p>Removing a member is straightforward. We begin by looking for the caller in the list. If not
present, there is no work to be done. If the caller is present, we simply remove them and update the
size of the set.</p>
<pre><code class="language-rust ignore">fn remove_member(origin) -&gt; DispatchResult {
	let old_member = ensure_signed(origin)?;

	ensure!(Members::&lt;T&gt;::contains_key(&amp;old_member), Error::&lt;T&gt;::NotMember);

	Members::&lt;T&gt;::remove(&amp;old_member);
	MemberCount::mutate(|v| *v -= 1);
	Self::deposit_event(RawEvent::MemberRemoved(old_member));
	Ok(())
}
</code></pre>
<h2><a class="header" href="#performance-1" id="performance-1">Performance</a></h2>
<p>Now that we have built our set, let's analyze its performance in some common operations.</p>
<h3><a class="header" href="#membership-check-1" id="membership-check-1">Membership Check</a></h3>
<p>In order to check for the presence of an item in a map set, we make a single storage read. If we
only care about the presence or absence of the item, we don't even need to decode it. This constant
time membership check is the greatest strength of a map set.</p>
<p>DB Reads: O(1)</p>
<h3><a class="header" href="#updating-1" id="updating-1">Updating</a></h3>
<p>Updates to the set, such as adding and removing members as we demonstrated, requires first
performing a membership check. Additions also require encooding the new item.</p>
<p>DB Reads: O(1) Encoding: O(1) DB Writes: O(1)</p>
<p>If your set operations will require a lot of membership checks or mutation of individual items, you
may want a <code>map-set</code>.</p>
<h3><a class="header" href="#iteration-1" id="iteration-1">Iteration</a></h3>
<p>Iterating over all items in a <code>map-set</code> is achieved by using the
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/frame_support/storage/trait.IterableStorageMap.html"><code>IterableStorageMap</code> trait</a>,
which iterates <code>(key, value)</code> pairs (although in this case, we don't care about the values). Because
each map entry is stored as an individual trie node, iterating a map set requires a database read
for each item. Finally, the actual processing of the items will take some time.</p>
<p>DB Reads: O(n) Decoding: O(n) Processing: O(n)</p>
<p>Because accessing the database is a relatively slow operation, returning to the database for each
item is quite expensive. If your set operations will require frequent iterating, you will probably
prefer a <a href="./vec-set.html"><code>vec-set</code></a>.</p>
<h3><a class="header" href="#a-note-on-weights-1" id="a-note-on-weights-1">A Note on Weights</a></h3>
<p>It is always important that the weight associated with your dispatchables represent the actual time
it takes to execute them. In this pallet, we have provided an upper bound on the size of the set,
which places an upper bound on the computation - this means we can use constant weight annotations.
Your set operations should either have a maximum size or a <a href="./weights.html">custom weight function</a>
that captures the computation appropriately.</p>
<h1><a class="header" href="#efficent-subgroup-removal-by-subkey-double-maps" id="efficent-subgroup-removal-by-subkey-double-maps">Efficent Subgroup Removal by Subkey: Double Maps</a></h1>
<p><code>pallets/double-map</code>
<a href="https://playground-staging.substrate.dev/?deploy=recipes&amp;files=%2Fhome%2Fsubstrate%2Fworkspace%2Fpallets%2Fdouble-map%2Fsrc%2Flib.rs">
<img src="https://img.shields.io/badge/Playground-Try%20it!-brightgreen?logo=Parity%20Substrate" alt="Try on playground" />
</a>
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/double-map/src/lib.rs">
<img src="https://img.shields.io/badge/Github-View%20Code-brightgreen?logo=github" alt="View on GitHub" />
</a></p>
<p>For some runtimes, it may be necessary to remove a subset of values in a key-value mapping. If the
subset maintain an associated identifier type, this can be done in a clean way with the
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/frame_support/storage/trait.StorageDoubleMap.html"><code>double_map</code></a> via the
<code>remove_prefix</code> api.</p>
<pre><code class="language-rust ignore">pub type GroupIndex = u32; // this is Encode (which is necessary for double_map)

decl_storage! {
	trait Store for Module&lt;T: Trait&gt; as Dmap {
		/// Member score (double map)
		MemberScore get(fn member_score):
			double_map hasher(blake2_128_concat) GroupIndex, hasher(blake2_128_concat) T::AccountId =&gt; u32;
		/// Get group ID for member
		GroupMembership get(fn group_membership): map hasher(blake2_128_concat) T::AccountId =&gt; GroupIndex;
		/// For fast membership checks, see check-membership recipe for more details
		AllMembers get(fn all_members): Vec&lt;T::AccountId&gt;;
	}
}
</code></pre>
<p>For the purposes of this example, store the scores of each member in a map that associates this
<code>u32</code> value with two keys: (1) a <code>GroupIndex</code> identifier, and (2) the member's <code>AccountId</code>. This
allows for efficient removal of all values associated with a specific <code>GroupIndex</code> identifier.</p>
<pre><code class="language-rust ignore">fn remove_group_score(origin, group: GroupIndex) -&gt; DispatchResult {
	let member = ensure_signed(origin)?;

	let group_id = &lt;GroupMembership&lt;T&gt;&gt;::get(member);
	// check that the member is in the group
	ensure!(group_id == group, &quot;member isn't in the group, can't remove it&quot;);

	// remove all group members from MemberScore at once
	&lt;MemberScore&lt;T&gt;&gt;::remove_prefix(&amp;group_id);

	Self::deposit_event(RawEvent::RemoveGroup(group_id));
	Ok(())
}
</code></pre>
<h1><a class="header" href="#using-and-storing-structs" id="using-and-storing-structs">Using and Storing Structs</a></h1>
<p><code>pallets/struct-storage</code>
<a href="https://playground-staging.substrate.dev/?deploy=recipes&amp;files=%2Fhome%2Fsubstrate%2Fworkspace%2Fpallets%2Fstruct-storage%2Fsrc%2Flib.rs">
<img src="https://img.shields.io/badge/Playground-Try%20it!-brightgreen?logo=Parity%20Substrate" alt="Try on playground" />
</a>
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/struct-storage/src/lib.rs">
<img src="https://img.shields.io/badge/Github-View%20Code-brightgreen?logo=github" alt="View on GitHub" />
</a></p>
<p>In Rust, a <code>struct</code>, or structure, is a custom data type that lets you name and package together
multiple related values that make up a meaningful group. If you‚Äôre familiar with an object-oriented
language, a <code>struct</code> is like an object‚Äôs data attributes (read more in
<a href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html">The Rust Book</a>).</p>
<h2><a class="header" href="#defining-a-struct" id="defining-a-struct">Defining a Struct</a></h2>
<p>To define a <em>simple</em> custom struct for the runtime, the following syntax may be used:</p>
<pre><code class="language-rust ignore">#[derive(Encode, Decode, Default, Clone, PartialEq)]
pub struct MyStruct {
    some_number: u32,
    optional_number: Option&lt;u32&gt;,
}
</code></pre>
<p>In the code snippet above, the
<a href="https://doc.rust-lang.org/rust-by-example/trait/derive.html">derive macro</a> is declared to ensure
<code>MyStruct</code> conforms to shared behavior according to the specified
<a href="https://doc.rust-lang.org/book/ch10-02-traits.html">traits</a>:
<code>Encode, Decode, Default, Clone, PartialEq</code>. If you wish the store this struct in blockchain
storage, you will need to derive (or manually ipmlement) each of these traits.</p>
<p>To use the <code>Encode</code> and <code>Decode</code> traits, it is necessary to import them.</p>
<pre><code class="language-rust ignore">use frame_support::codec::{Encode, Decode};
</code></pre>
<h2><a class="header" href="#structs-with-generic-fields" id="structs-with-generic-fields">Structs with Generic Fields</a></h2>
<p>The simple struct shown earlier only uses Rust primitive types for its fields. In the common case
where you want to store types that come from your pallet's configuration trait (or the configuration
trait of another pallet in your runtime), you must use generic type parameters in your struct's
definition.</p>
<pre><code class="language-rust ignore">#[derive(Encode, Decode, Clone, Default, RuntimeDebug)]
pub struct InnerThing&lt;Hash, Balance&gt; {
	number: u32,
	hash: Hash,
	balance: Balance,
}
</code></pre>
<p>Here you can see that we want to store items of type <code>Hash</code> and <code>Balance</code> in the struct. Because
these types come from the system and balances pallets' configuration traits, we must specify them as
generics when declaring the struct.</p>
<p>It is often convenient to make a type alias that takes <code>T</code>, your pallet's configuration trait, as a
single type parameter. Doing so simply saves you typing in the future.</p>
<pre><code class="language-rust ignore">type InnerThingOf&lt;T&gt; = InnerThing&lt;&lt;T as system::Trait&gt;::Hash, &lt;T as balances::Trait&gt;::Balance&gt;;
</code></pre>
<h2><a class="header" href="#structs-in-storage" id="structs-in-storage">Structs in Storage</a></h2>
<p>Using one of our structs as a storage item is not significantly different than using a primitive
type. When using a generic struct, we must supply all of the generic type parameters. This snippet
shows how to supply thos parameters when you have a type alias (like we do for <code>InnerThing</code>) as well
as when you don't. Whether to include the type alias is a matter of style and taste, but it is
generally preferred when the entire type exceeds the preferred line length.</p>
<pre><code class="language-rust ignore">decl_storage! {
	trait Store for Module&lt;T: Trait&gt; as NestedStructs {
		InnerThingsByNumbers get(fn inner_things_by_numbers):
			map hasher(blake2_128_concat) u32 =&gt; InnerThingOf&lt;T&gt;;
		SuperThingsBySuperNumbers get(fn super_things_by_super_numbers):
			map hasher(blake2_256) u32 =&gt; SuperThing&lt;T::Hash, T::Balance&gt;;
	}
}
</code></pre>
<p>Interacting with the storage maps is now exactly as it was when we didn't use any custom structs</p>
<pre><code class="language-rust ignore">fn insert_inner_thing(origin, number: u32, hash: T::Hash, balance: T::Balance) -&gt; DispatchResult {
	let _ = ensure_signed(origin)?;
	let thing = InnerThing {
					number,
					hash,
					balance,
				};
	&lt;InnerThingsByNumbers&lt;T&gt;&gt;::insert(number, thing);
	Self::deposit_event(RawEvent::NewInnerThing(number, hash, balance));
	Ok(())
}
</code></pre>
<h2><a class="header" href="#nested-structs" id="nested-structs">Nested Structs</a></h2>
<p>Structs can also contain other structs as their fields. We have demonstrated this with the type
<code>SuperThing</code>. As you see, any generic types needed by the inner struct must also be supplied to the
outer.</p>
<pre><code class="language-rust ignore">#[derive(Encode, Decode, Default, RuntimeDebug)]
pub struct SuperThing&lt;Hash, Balance&gt; {
	super_number: u32,
	inner_thing: InnerThing&lt;Hash, Balance&gt;,
}
</code></pre>
<h1><a class="header" href="#ringbuffer-queue" id="ringbuffer-queue">Ringbuffer Queue</a></h1>
<p><code>pallets/ringbuffer-queue</code>
<a href="https://playground-staging.substrate.dev/?deploy=recipes&amp;files=%2Fhome%2Fsubstrate%2Fworkspace%2Fpallets%2Fringbuffer-queue%2Fsrc%2Flib.rs">
<img src="https://img.shields.io/badge/Playground-Try%20it!-brightgreen?logo=Parity%20Substrate" alt="Try on playground" />
</a>
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/ringbuffer-queue/src/lib.rs">
<img src="https://img.shields.io/badge/Github-View%20Code-brightgreen?logo=github" alt="View on GitHub" />
</a></p>
<blockquote>
<p>Building a transient adapter on top of storage.</p>
</blockquote>
<p>This pallet provides a trait and implementation for a
<a href="https://en.wikipedia.org/wiki/Circular_buffer">ringbuffer</a> that abstracts over storage items and
presents them as a <a href="https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)">FIFO</a> queue.</p>
<p>When building more sophisticated pallets you might notice a need for more complex data structures
stored in storage. This recipe shows how to build a transient storage adapter by walking through the
implementation of a ringbuffer FIFO queue. The adapter in this recipe manages a queue that is
persisted as a <code>StorageMap</code> and a <code>(start, end)</code> range in storage.</p>
<p>The
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/ringbuffer-queue/src/lib.rs"><code>ringbuffer-queue/src/lib.rs</code></a>
file contains the <a href="ringbuffer.html#usage">usage</a> of the transient storage adapter while
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/ringbuffer-queue/src/ringbuffer.rs"><code>ringbuffer-queue/src/ringbuffer.rs</code></a>
contains the implementation.</p>
<h2><a class="header" href="#defining-the-ringbuffer-trait-a-name--traita" id="defining-the-ringbuffer-trait-a-name--traita">Defining the RingBuffer Trait <a name = "trait"></a></a></h2>
<p>First we define the queue interface we want to use:</p>
<pre><code class="language-rust ignore">pub trait RingBufferTrait&lt;Item&gt;
where
	Item: Codec + EncodeLike,
{
	/// Store all changes made in the underlying storage.
	fn commit(&amp;self);
	/// Push an item onto the end of the queue.
	fn push(&amp;mut self, i: Item);
	/// Pop an item from the start of the queue.
	fn pop(&amp;mut self) -&gt; Option&lt;Item&gt;;
	/// Return whether the queue is empty.
	fn is_empty(&amp;self) -&gt; bool;
}
</code></pre>
<p>It defines the usual <code>push</code>, <code>pop</code> and <code>is_empty</code> functions we expect from a queue as well as a
<code>commit</code> function that will be used to sync the changes made to the underlying storage.</p>
<h2><a class="header" href="#specifying-the-ringbuffer-transient-a-name--transienta" id="specifying-the-ringbuffer-transient-a-name--transienta">Specifying the RingBuffer Transient <a name = "transient"></a></a></h2>
<p>Now we want to add an implementation of the trait. We will be storing the start and end of the
ringbuffer separately from the actual items and will thus need to store these in our struct:</p>
<pre><code class="language-rust ignore">pub struct RingBufferTransient&lt;Index&gt;
where
	Index: Codec + EncodeLike + Eq + Copy,
{
	start: Index,
	end: Index,
}
</code></pre>
<h3><a class="header" href="#defining-the-storage-interface" id="defining-the-storage-interface">Defining the Storage Interface</a></h3>
<p>In order to access the underlying storage we will also need to include the bounds (we will call the
type <code>B</code>) and the item storage (whose type will be <code>M</code>). In order to specify the constraints on the
storage map (<code>M</code>) we will also need to specify the <code>Item</code> type. This results in the following struct
definition:</p>
<pre><code class="language-rust ignore">pub struct RingBufferTransient&lt;Item, B, M, Index&gt;
where
	Item: Codec + EncodeLike,
	B: StorageValue&lt;(Index, Index), Query = (Index, Index)&gt;,
	M: StorageMap&lt;Index, Item, Query = Item&gt;,
	Index: Codec + EncodeLike + Eq + Copy,
{
	start: Index,
	end: Index,
	_phantom: PhantomData&lt;(Item, B, M)&gt;,
}
</code></pre>
<p>The bounds <code>B</code> will be a <code>StorageValue</code> storing a tuple of indices <code>(Index, Index)</code>. The item
storage will be a <code>StorageMap</code> mapping from our <code>Index</code> type to the <code>Item</code> type. We specify the
associated <code>Query</code> type for both of them to help with type inference (because the value returned can
be different from the stored representation).</p>
<p>The <a href="https://docs.rs/parity-scale-codec/1.3.0/parity_scale_codec/trait.Codec.html"><code>Codec</code></a> and
<a href="https://docs.rs/parity-scale-codec/1.3.0/parity_scale_codec/trait.EncodeLike.html"><code>EncodeLike</code></a>
type constraints make sure that both items and indices can be stored in storage.</p>
<p>We need the <a href="https://doc.rust-lang.org/std/marker/struct.PhantomData.html"><code>PhantomData</code></a> in order
to &quot;hold on to&quot; the types during the lifetime of the transient object.</p>
<h3><a class="header" href="#the-complete-type" id="the-complete-type">The Complete Type</a></h3>
<p>There are two more alterations we will make to our struct to make it work well:</p>
<pre><code class="language-rust ignore">type DefaultIdx = u16;
pub struct RingBufferTransient&lt;Item, B, M, Index = DefaultIdx&gt;
where
	Item: Codec + EncodeLike,
	B: StorageValue&lt;(Index, Index), Query = (Index, Index)&gt;,
	M: StorageMap&lt;Index, Item, Query = Item&gt;,
	Index: Codec + EncodeLike + Eq + WrappingOps + From&lt;u8&gt; + Copy,
{
	start: Index,
	end: Index,
	_phantom: PhantomData&lt;(Item, B, M)&gt;,
}
</code></pre>
<p>We specify a default type for <code>Index</code> and define it as <code>u16</code> to allow for 65536 entries in the
ringbuffer per default. We also add the <code>WrappingOps</code> and <code>From&lt;u8&gt;</code> type bounds to enable the kind
of operations we need in our implementation. More details in the <a href="ringbuffer.html#implementation">implementation</a>
section, especially in the <a href="ringbuffer.html#wrapping_ops"><code>WrappingOps</code></a> subsection.</p>
<h2><a class="header" href="#implementation-of-the-ringbuffer-a-name--implementationa" id="implementation-of-the-ringbuffer-a-name--implementationa">Implementation of the RingBuffer <a name = "implementation"></a></a></h2>
<p>Now that we have the type definition for <code>RingBufferTransient</code> we need to write the implementation.</p>
<h3><a class="header" href="#instantiating-the-transient" id="instantiating-the-transient">Instantiating the Transient</a></h3>
<p>First we need to specify how to create a new instance by providing a <code>new</code> function:</p>
<pre><code class="language-rust ignore">impl&lt;Item, B, M, Index&gt; RingBufferTransient&lt;Item, B, M, Index&gt;
where // ... same where clause as the type, elided here
{
	pub fn new() -&gt; RingBufferTransient&lt;Item, B, M, Index&gt; {
		let (start, end) = B::get();
		RingBufferTransient {
			start, end, _phantom: PhantomData,
		}
	}
}
</code></pre>
<p>Here we access the bounds stored in storage to initialize the transient.</p>
<blockquote>
<p><strong>Aside</strong>: Of course we could also provide a <code>with_bounds</code> function that takes the bounds as a
parameter. Feel free to add that function as an exercise.</p>
</blockquote>
<blockquote>
<p><strong>Second Aside</strong>: This <code>B::get()</code> is one of the reasons for specifying the <code>Query</code> associated type
on the <code>StorageValue</code> type constraint.</p>
</blockquote>
<h3><a class="header" href="#implementing-the-ringbuffertrait" id="implementing-the-ringbuffertrait">Implementing the <code>RingBufferTrait</code></a></h3>
<p>We will now implement the <code>RingBufferTrait</code>:</p>
<pre><code class="language-rust ignore">impl&lt;Item, B, M, Index&gt; RingBufferTrait&lt;Item&gt; for RingBufferTransient&lt;Item, B, M, Index&gt;
where // same as the struct definition
	Item: Codec + EncodeLike,
	B: StorageValue&lt;(Index, Index), Query = (Index, Index)&gt;,
	M: StorageMap&lt;Index, Item, Query = Item&gt;,
	Index: Codec + EncodeLike + Eq + WrappingOps + From&lt;u8&gt; + Copy,
{
	fn commit(&amp;self) {
		B::put((self.start, self.end));
	}
</code></pre>
<p><code>commit</code> just consists of putting the potentially changed bounds into storage. You will notice that
we don't update the bounds' storage when changing them in the other functions.</p>
<pre><code class="language-rust ignore">	fn is_empty(&amp;self) -&gt; bool {
		self.start == self.end
	}
</code></pre>
<p>The <code>is_empty</code> function just checks whether the start and end bounds have the same value to
determine whether the queue is empty, thus avoiding expensive storage accesses. This means we need
to uphold the corresponding invariant in the other (notably the <code>push</code>) functions.</p>
<pre><code class="language-rust ignore">	fn push(&amp;mut self, item: Item) {
		M::insert(self.end, item);
		// this will intentionally overflow and wrap around when bonds_end
		// reaches `Index::max_value` because we want a ringbuffer.
		let next_index = self.end.wrapping_add(1.into());
		if next_index == self.start {
			// queue presents as empty but is not
			// --&gt; overwrite the oldest item in the FIFO ringbuffer
			self.start = self.start.wrapping_add(1.into());
		}
		self.end = next_index;
	}
</code></pre>
<p>In the <code>push</code> function, we insert the pushed <code>item</code> into the map and calculate the new bounds by
using the <code>wrapping_add</code> function. This way our ringbuffer will wrap around when reaching
<code>max_value</code> of the <code>Index</code> type. This is why we need the <code>WrappingOps</code> type trait for <code>Index</code>.</p>
<p>The <code>if</code> is necessary because we need to keep the invariant that <code>start == end</code> means that the queue
is empty, otherwise we would need to keep track of this state separately. We thus &quot;toss away&quot; the
oldest item in the queue if a new item is pushed into a full queue by incrementing the start index.</p>
<blockquote>
<h5><a class="header" href="#note-the-wrappingops-trait-a-name--wrapping_opsa" id="note-the-wrappingops-trait-a-name--wrapping_opsa">Note: The <code>WrappingOps</code> Trait <a name = "wrapping_ops"></a></a></h5>
<p>The ringbuffer should be agnostic to the concrete <code>Index</code> type used. In order to decrement and
increment the start and end index, though, any concrete type needs to implement <code>wrapping_add</code> and
<code>wrapping_sub</code>. Because <code>std</code> does not provide such a trait, we need another way to require this
behavior. We just implement our own trait <code>WrappingOps</code> for the types we
want to support (<code>u8</code>, <code>u16</code>, <code>u32</code> and <code>u64</code>).</p>
</blockquote>
<p>The last function we implement is <code>pop</code>:</p>
<pre><code class="language-rust ignore">	fn pop(&amp;mut self) -&gt; Option&lt;Item&gt; {
		if self.is_empty() {
			return None;
		}
		let item = M::take(self.start);
		self.start = self.start.wrapping_add(1.into());

		item.into()
	}
</code></pre>
<p>We can return <code>None</code> on <code>is_empty</code> because we are upholding the invariant. If the queue is not empty
we <code>take</code> the value at <code>self.start</code> from storage, i.e. the first value is removed from storage and
passed to us. We then increment <code>self.start</code> to point to the new first item of the queue, again
using the <code>wrapping_add</code> to get the ringbuffer behavior.</p>
<h3><a class="header" href="#implementing-drop" id="implementing-drop">Implementing Drop</a></h3>
<p>In order to make the usage more ergonomic and to avoid synchronization errors (where the storage map
diverges from the bounds) we also implement the
<a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code> trait</a>:</p>
<pre><code class="language-rust ignore">impl&lt;Item, B, M, Index&gt; Drop for RingBufferTransient&lt;Item, B, M, Index&gt;
where // ... same where clause elided
{
	fn drop(&amp;mut self) {
		&lt;Self as RingBufferTrait&lt;Item&gt;&gt;::commit(self);
	}
}
</code></pre>
<p>On <code>drop</code>, we <code>commit</code> the bounds to storage. With this implementation of <code>Drop</code>, <code>commit</code> is called
when our transient goes out of scope, making sure that the storage state is consistent for the next
call to the using pallet.</p>
<h2><a class="header" href="#typical-usage-a-name--usagea" id="typical-usage-a-name--usagea">Typical Usage <a name = "usage"></a></a></h2>
<p>The
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/ringbuffer-queue/src/lib.rs"><code>lib.rs</code></a>
file of the pallet shows typical usage of the transient.</p>
<pre><code class="language-rust ignore">impl&lt;T: Trait&gt; Module&lt;T&gt; {
	fn queue_transient() -&gt; Box&lt;dyn RingBufferTrait&lt;ValueStruct&gt;&gt; {
		Box::new(RingBufferTransient::&lt;
			ValueStruct,
			&lt;Self as Store&gt;::BufferRange,
			&lt;Self as Store&gt;::BufferMap,
			BufferIndex,
		&gt;::new())
	}
}
</code></pre>
<p>First we define a constructor function (<code>queue_transient</code>) so we don't have to specify the types
every time we want to access the transient. This function constructs a ringbuffer transient and
returns it as a boxed trait object. See the Rust book's section on
<a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html#trait-objects-perform-dynamic-dispatch">trait objects</a>
for an explanation of why we need a boxed trait object (defined with the syntax <code>dyn TraitName</code>)
when using dynamic dispatch.</p>
<p>The <code>add_multiple</code> function shows the actual typical usage of our transient:</p>
<pre><code class="language-rust ignore">pub fn add_multiple(origin, integers: Vec&lt;i32&gt;, boolean: bool) -&gt; DispatchResult {
	let _user = ensure_signed(origin)?;
	let mut queue = Self::queue_transient();
	for integer in integers {
		queue.push(ValueStruct{ integer, boolean });
	}
	Ok(())
} // commit happens on drop
</code></pre>
<p>Here we use the <code>queue_transient</code> function defined above to get a <code>queue</code> object. We then <code>push</code>
into it repeatedly with <code>commit</code> happening on <code>drop</code> of the <code>queue</code> object at the end of the
function. <code>pop</code> works analogously and can of course be intermixed with <code>push</code>es.</p>
<h1><a class="header" href="#basic-token" id="basic-token">Basic Token</a></h1>
<p><code>pallets/basic-token</code>
<a href="https://playground-staging.substrate.dev/?deploy=recipes&amp;files=%2Fhome%2Fsubstrate%2Fworkspace%2Fpallets%2Fbasic-token%2Fsrc%2Flib.rs">
<img src="https://img.shields.io/badge/Playground-Try%20it!-brightgreen?logo=Parity%20Substrate" alt="Try on playground" />
</a>
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/basic-token/src/lib.rs">
<img src="https://img.shields.io/badge/Github-View%20Code-brightgreen?logo=github" alt="View on GitHub" />
</a></p>
<p>This recipe demonstrates a simple but functional token in a pallet.</p>
<h2><a class="header" href="#mapping-accounts-to-balances" id="mapping-accounts-to-balances">Mapping Accounts to Balances</a></h2>
<p>Mappings are a very powerful primitive. A <em>stateful</em> cryptocurrency might store a mapping between
accounts and balances. Likewise, mappings prove useful when representing <em>owned</em> data. By tracking
ownership with maps, it is easy manage permissions for modifying values specific to individual users
or groups.</p>
<h2><a class="header" href="#storage-items" id="storage-items">Storage Items</a></h2>
<p>The primary storage item is the mapping between AccountIds and Balances described above. Every
account that holds tokens appears as a key in that map and its value is the number of tokens it
holds.</p>
<p>The next two storage items set the total supply of the token and keep track of whether the token has
been initialized yet.</p>
<pre><code class="language-rust ignore">decl_storage! {
	trait Store for Module&lt;T: Trait&gt; as Token {
		pub Balances get(get_balance): map hasher(blake2_128_concat) T::AccountId =&gt; u64;

		pub TotalSupply get(total_supply): u64 = 21000000;

		Init get(is_init): bool;
	}
}
</code></pre>
<p>Because users can influence the keys in our storage map, we've chosen the <code>blake2_128_concat</code> hasher
as described in the recipe on <a href="./storage-maps.html">storage maps</a>s.</p>
<h2><a class="header" href="#events-and-errors" id="events-and-errors">Events and Errors</a></h2>
<p>The pallet defines events and errors for common lifecycle events such as successful and failed
transfers, and successful and failed initialization.</p>
<pre><code class="language-rust ignore">decl_event!(
	pub enum Event&lt;T&gt;
	where
		AccountId = &lt;T as system::Trait&gt;::AccountId,
	{
		/// Token was initialized by user
		Initialized(AccountId),
		/// Tokens successfully transferred between users
		Transfer(AccountId, AccountId, u64), // (from, to, value)
	}
);

decl_error! {
	pub enum Error for Module&lt;T: Trait&gt; {
		/// Attempted to initialize the token after it had already been initialized.
		AlreadyInitialized,
		/// Attempted to transfer more funds than were available
		InsufficientFunds,
	}
}
</code></pre>
<h2><a class="header" href="#initializing-the-token" id="initializing-the-token">Initializing the Token</a></h2>
<p>In order for the token to be useful, some accounts need to own it. There are many possible ways to
initialize a token including genesis config, claims process, lockdrop, and many more. This pallet
will use a simple process where the first user to call the <code>init</code> function receives all of the
funds. The total supply is hard-coded in the pallet in a fairly naive way: It is specified as the
default value in the <code>decl_storage!</code> block.</p>
<pre><code class="language-rustignore">fn init(origin) -&gt; DispatchResult {
	let sender = ensure_signed(origin)?;
	ensure!(!Self::is_init(), &lt;Error&lt;T&gt;&gt;::AlreadyInitialized);

	&lt;Balances&lt;T&gt;&gt;::insert(sender, Self::total_supply());

	Init::put(true);
	Ok(())
}
</code></pre>
<p>As usual, we first check for preconditions. In this case that means making sure that the token is
not already initialized. Then we do any mutation necessary.</p>
<h2><a class="header" href="#transferring-tokens" id="transferring-tokens">Transferring Tokens</a></h2>
<p>To transfer tokens, a user who owns some tokens calls the <code>transfer</code> method specifying the recipient
and the amount of tokens to transfer as parameters.</p>
<p>We again check for error conditions before mutating storage. In this case it is <em>not</em> necessary to
check whether the token has been initialized. If it has not, nobody has any funds and the transfer
will simply fail with <code>InsufficientFunds</code>.</p>
<pre><code class="language-rust ignore">fn transfer(_origin, to: T::AccountId, value: u64) -&gt; DispatchResult {
	let sender = ensure_signed(_origin)?;
	let sender_balance = Self::get_balance(&amp;sender);
	let receiver_balance = Self::get_balance(&amp;to);

	// Calculate new balances
	let updated_from_balance = sender_balance.checked_sub(value).ok_or(&lt;Error&lt;T&gt;&gt;::InsufficientFunds)?;
	let updated_to_balance = receiver_balance.checked_add(value).expect(&quot;Entire supply fits in u64; qed&quot;);

	// Write new balances to storage
	&lt;Balances&lt;T&gt;&gt;::insert(&amp;sender, updated_from_balance);
	&lt;Balances&lt;T&gt;&gt;::insert(&amp;to, updated_to_balance);

	Self::deposit_event(RawEvent::Transfer(sender, to, value));
	Ok(())
}
</code></pre>
<h2><a class="header" href="#dont-panic" id="dont-panic">Don't Panic!</a></h2>
<p>When adding the incoming balance, notice the peculiar <code>.expect</code> method. In a Substrate runtime,
<strong>you must never panic</strong>. To encourage careful thinking about your code, you use the <code>.expect</code>
method and provide a proof of why the potential panic will never happen.</p>
<h1><a class="header" href="#configurable-pallet-constants" id="configurable-pallet-constants">Configurable Pallet Constants</a></h1>
<p><code>pallets/constant-config</code>
<a href="https://playground-staging.substrate.dev/?deploy=recipes&amp;files=%2Fhome%2Fsubstrate%2Fworkspace%2Fpallets%2Fconstant-config%2Fsrc%2Flib.rs">
<img src="https://img.shields.io/badge/Playground-Try%20it!-brightgreen?logo=Parity%20Substrate" alt="Try on playground" />
</a>
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/constant-config/src/lib.rs">
<img src="https://img.shields.io/badge/Github-View%20Code-brightgreen?logo=github" alt="View on GitHub" />
</a></p>
<p>To declare constant values within a runtime, it is necessary to import the
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/frame_support/traits/trait.Get.html"><code>Get</code></a> trait from <code>frame_support</code></p>
<pre><code class="language-rust ignore">use frame_support::traits::Get;
</code></pre>
<p>Configurable constants are declared as associated types in the pallet's configuration trait using
the <code>Get&lt;T&gt;</code> syntax for any type <code>T</code>.</p>
<pre><code class="language-rust ignore">pub trait Trait: system::Trait {
	type Event: From&lt;Event&gt; + Into&lt;&lt;Self as system::Trait&gt;::Event&gt;;

	/// Maximum amount added per invocation
	type MaxAddend: Get&lt;u32&gt;;

	/// Frequency with which the stored value is deleted
	type ClearFrequency: Get&lt;Self::BlockNumber&gt;;
}
</code></pre>
<p>In order to make these constants and their values appear in the runtime metadata, it is necessary to
declare them with the <code>const</code> syntax in the <code>decl_module!</code> block. Usually constants are declared at
the top of this block, right after <code>fn deposit_event</code>.</p>
<pre><code class="language-rust ignore">decl_module! {
	pub struct Module&lt;T: Trait&gt; for enum Call where origin: T::Origin {
		fn deposit_event() = default;

		const MaxAddend: u32 = T::MaxAddend::get();

		const ClearFrequency: T::BlockNumber = T::ClearFrequency::get();

		// --snip--
	}
}
</code></pre>
<p>This example manipulates a single value in storage declared as <code>SingleValue</code>.</p>
<pre><code class="language-rust ignore">decl_storage! {
	trait Store for Module&lt;T: Trait&gt; as Example {
		SingleValue get(fn single_value): u32;
	}
}
</code></pre>
<p><code>SingleValue</code> is set to <code>0</code> every <code>ClearFrequency</code> number of blocks in the <code>on_finalize</code> function
that runs at the end of blocks execution.</p>
<pre><code class="language-rust ignore">fn on_finalize(n: T::BlockNumber) {
	if (n % T::ClearFrequency::get()).is_zero() {
		let c_val = &lt;SingleValue&gt;::get();
		&lt;SingleValue&gt;::put(0u32);
		Self::deposit_event(Event::Cleared(c_val));
	}
}
</code></pre>
<p>Signed transactions may invoke the <code>add_value</code> runtime method to increase <code>SingleValue</code> as long as
each call adds less than <code>MaxAddend</code>. <em>There is no anti-sybil mechanism so a user could just split a
larger request into multiple smaller requests to overcome the <code>MaxAddend</code></em>, but overflow is still
handled appropriately.</p>
<pre><code class="language-rust ignore">fn add_value(origin, val_to_add: u32) -&gt; DispatchResult {
	let _ = ensure_signed(origin)?;
	ensure!(val_to_add &lt;= T::MaxAddend::get(), &quot;value must be &lt;= maximum add amount constant&quot;);

	// previous value got
	let c_val = &lt;SingleValue&gt;::get();

	// checks for overflow when new value added
	let result = match c_val.checked_add(val_to_add) {
		Some(r) =&gt; r,
		None =&gt; return Err(DispatchError::Other(&quot;Addition overflowed&quot;)),
	};
	&lt;SingleValue&gt;::put(result);
	Self::deposit_event(Event::Added(c_val, val_to_add, result));
	Ok(())
}
</code></pre>
<p>In more complex patterns, the constant value may be used as a static, base value that is scaled by a
multiplier to incorporate stateful context for calculating some dynamic fee (i.e. floating
transaction fees).</p>
<h2><a class="header" href="#supplying-the-constant-value" id="supplying-the-constant-value">Supplying the Constant Value</a></h2>
<p>When the pallet is included in a runtime, the runtime developer supplies the value of the constant
using the
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/frame_support/macro.parameter_types.html"><code>parameter_types!</code> macro</a>. This
pallet is included in the <code>super-runtime</code> where we see the following macro invocation and trait
implementation.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>parameter_types! {
	pub const MaxAddend: u32 = 1738;
	pub const ClearFrequency: u32 = 10;
}

impl constant_config::Trait for Runtime {
	type Event = Event;
	type MaxAddend = MaxAddend;
	type ClearFrequency = ClearFrequency;
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#simple-crowdfund" id="simple-crowdfund">Simple Crowdfund</a></h1>
<p><code>pallets/simple-crowdfund</code>
<a href="https://playground-staging.substrate.dev/?deploy=recipes&amp;files=%2Fhome%2Fsubstrate%2Fworkspace%2Fpallets%2Fsimple-crowdfund%2Fsrc%2Flib.rs">
<img src="https://img.shields.io/badge/Playground-Try%20it!-brightgreen?logo=Parity%20Substrate" alt="Try on playground" />
</a>
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/simple-crowdfund/src/lib.rs">
<img src="https://img.shields.io/badge/Github-View%20Code-brightgreen?logo=github" alt="View on GitHub" />
</a>
This pallet demonstrates a simple on-chain crowdfunding app where participants can pool funds toward
a common goal. It demonstrates a pallet that controls multiple token accounts, and storing data in
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/frame_support/storage/child/index.html">child storage</a>.</p>
<h2><a class="header" href="#basic-usage" id="basic-usage">Basic Usage</a></h2>
<p>Any user can start a crowdfund by specifying a goal amount for the crowdfund, an end time, and a
beneficiary who will receive the pooled funds if the goal is reached by the end time. If the fund is
not successful, it enters into a retirement period when contributors can reclaim their pledged
funds. Finally, an unsuccessful fund can be dissolved, sending any remaining tokens to the user who
dissolves it.</p>
<h2><a class="header" href="#configuration-trait-1" id="configuration-trait-1">Configuration Trait</a></h2>
<p>We begin by declaring our configuration trait. In addition to the ubiquitous <code>Event</code> type, our
crowdfund pallet will depend on a notion of
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/frame_support/traits/trait.Currency.html"><code>Currency</code></a>, and three
<a href="./constants.html">configuration constants</a>.</p>
<pre><code class="language-rust ignore">/// The pallet's configuration trait
pub trait Trait: system::Trait {
	/// The ubiquious Event type
	type Event: From&lt;Event&lt;Self&gt;&gt; + Into&lt;&lt;Self as system::Trait&gt;::Event&gt;;

	/// The currency in which the crowdfunds will be denominated
	type Currency: ReservableCurrency&lt;Self::AccountId&gt;;

	/// The amount to be held on deposit by the owner of a crowdfund
	type SubmissionDeposit: Get&lt;BalanceOf&lt;Self&gt;&gt;;

	/// The minimum amount that may be contributed into a crowdfund. Should almost certainly be at
	/// least ExistentialDeposit.
	type MinContribution: Get&lt;BalanceOf&lt;Self&gt;&gt;;

	/// The period of time (in blocks) after an unsuccessful crowdfund ending during which
	/// contributors are able to withdraw their funds. After this period, their funds are lost.
	type RetirementPeriod: Get&lt;Self::BlockNumber&gt;;
}
</code></pre>
<h2><a class="header" href="#custom-types" id="custom-types">Custom Types</a></h2>
<p>Our pallet introduces a custom struct that is used to store the metadata about each fund.</p>
<pre><code class="language-rust ignore">#[derive(Encode, Decode, Default, PartialEq, Eq)]
#[cfg_attr(feature = &quot;std&quot;, derive(Debug))]
pub struct FundInfo&lt;AccountId, Balance, BlockNumber&gt; {
	/// The account that will recieve the funds if the campaign is successful
	beneficiary: AccountId,
	/// The amount of deposit placed
	deposit: Balance,
	/// The total amount raised
	raised: Balance,
	/// Block number after which funding must have succeeded
	end: BlockNumber,
	/// Upper bound on `raised`
	goal: Balance,
}
</code></pre>
<p>In addition to this <code>FundInfo</code> struct, we also introduce an index type to track the number of funds
that have ever been created and three convenience aliases.</p>
<pre><code class="language-rust ignore">pub type FundIndex = u32;

type AccountIdOf&lt;T&gt; = &lt;T as system::Trait&gt;::AccountId;
type BalanceOf&lt;T&gt; = &lt;&lt;T as Trait&gt;::Currency as Currency&lt;AccountIdOf&lt;T&gt;&gt;&gt;::Balance;
type FundInfoOf&lt;T&gt; = FundInfo&lt;AccountIdOf&lt;T&gt;, BalanceOf&lt;T&gt;, &lt;T as system::Trait&gt;::BlockNumber&gt;;
</code></pre>
<h2><a class="header" href="#storage" id="storage">Storage</a></h2>
<p>The pallet has two storage items declared the usual way using <code>decl_storage!</code>. The first is the
index that tracks the number of funds, and the second is a mapping from index to <code>FundInfo</code>.</p>
<pre><code class="language-rust ignore">decl_storage! {
	trait Store for Module&lt;T: Trait&gt; as ChildTrie {
		/// Info on all of the funds.
		Funds get(fn funds):
			map hasher(blake2_128_concat) FundIndex =&gt; Option&lt;FundInfoOf&lt;T&gt;&gt;;

		/// The total number of funds that have so far been allocated.
		FundCount get(fn fund_count): FundIndex;

		// Additional information is stored in a child trie. See the helper
		// functions in the impl&lt;T: Trait&gt; Module&lt;T&gt; block below
	}
}
</code></pre>
<p>This pallet also stores the data about which users have contributed and how many funds they
contributed in a <a href="https://substrate.dev/rustdocs/v2.0.0-rc6/frame_support/storage/child/index.html">child trie</a>. This
child trie is not explicitly declared anywhere.</p>
<p>The use of the child trie provides two advantages over using standard storage. First, it allows for
removing the entirety of the trie is a single storage write when the fund is dispensed or dissolved.
Second, it allows any contributor to prove that they contributed using a
<a href="https://medium.com/crypto-0-nite/merkle-proofs-explained-6dd429623dc5">Merkle Proof</a>.</p>
<h3><a class="header" href="#using-the-child-trie-api" id="using-the-child-trie-api">Using the Child Trie API</a></h3>
<p>The child API is abstracted into a few helper functions in the <code>impl&lt;T: Trait&gt; Module&lt;T&gt;</code> block.</p>
<pre><code class="language-rust ignore">/// Record a contribution in the associated child trie.
pub fn contribution_put(index: FundIndex, who: &amp;T::AccountId, balance: &amp;BalanceOf&lt;T&gt;) {
	let id = Self::id_from_index(index);
	who.using_encoded(|b| child::put(&amp;id, b, &amp;balance));
}

/// Lookup a contribution in the associated child trie.
pub fn contribution_get(index: FundIndex, who: &amp;T::AccountId) -&gt; BalanceOf&lt;T&gt; {
	let id = Self::id_from_index(index);
	who.using_encoded(|b| child::get_or_default::&lt;BalanceOf&lt;T&gt;&gt;(&amp;id, b))
}

/// Remove a contribution from an associated child trie.
pub fn contribution_kill(index: FundIndex, who: &amp;T::AccountId) {
	let id = Self::id_from_index(index);
	who.using_encoded(|b| child::kill(&amp;id, b));
}

/// Remove the entire record of contributions in the associated child trie in a single
/// storage write.
pub fn crowdfund_kill(index: FundIndex) {
	let id = Self::id_from_index(index);
	child::kill_storage(&amp;id);
}
</code></pre>
<p>Because this pallet uses one trie for each active crowdfund, we need to generate a unique
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/frame_support/storage/child/enum.ChildInfo.html"><code>ChildInfo</code></a> for each of
them. To ensure that the ids are really unique, we incluce the <code>FundIndex</code> in the generation.</p>
<pre><code class="language-rust ignore">pub fn id_from_index(index: FundIndex) -&gt; child::ChildInfo {
	let mut buf = Vec::new();
	buf.extend_from_slice(b&quot;crowdfnd&quot;);
	buf.extend_from_slice(&amp;index.to_le_bytes()[..]);

	child::ChildInfo::new_default(T::Hashing::hash(&amp;buf[..]).as_ref())
}
</code></pre>
<h2><a class="header" href="#pallet-dispatchables" id="pallet-dispatchables">Pallet Dispatchables</a></h2>
<p>The dispatchable functions in this pallet follow a standard flow of verifying preconditions, raising
appropriate errors, mutating storage, and finally emitting events. We will not present them all in
this writeup, but as always, you're encouraged to experiment with the recipe.</p>
<p>We will look closely only at the <code>dispense</code> dispatchable which pays the funds to the beneficiary
after a successful crowdfund. This dispatchable, as well as <code>dissolve</code>, use an incentivization
scheme to encourage users of the chain to eliminate extra data as soon as possible.</p>
<p>Data from finished funds takes up space on chain, so it is best to settle the fund and cleanup the
data as soon as possible. To incentivize this behavior, the pallet awards the initial deposit to
whoever calls the <code>dispense</code> function. Users, in hopes of receiving this reward, will race to call
these cleanup methods before each other.</p>
<pre><code class="language-rust ignore">/// Dispense a payment to the beneficiary of a successful crowdfund.
/// The beneficiary receives the contributed funds and the caller receives
/// the deposit as a reward to incentivize clearing settled crowdfunds out of storage.
#[weight = 10_000]
fn dispense(origin, index: FundIndex) {
	let caller = ensure_signed(origin)?;

	let fund = Self::funds(index).ok_or(Error::&lt;T&gt;::InvalidIndex)?;

	// Check that enough time has passed to remove from storage
	let now = &lt;system::Module&lt;T&gt;&gt;::block_number();

	ensure!(now &gt;= fund.end, Error::&lt;T&gt;::FundStillActive);

	// Check that the fund was actually successful
	ensure!(fund.raised &gt;= fund.goal, Error::&lt;T&gt;::UnsuccessfulFund);

	let account = Self::fund_account_id(index);

	// Beneficiary collects the contributed funds
	let _ = T::Currency::resolve_creating(&amp;fund.beneficiary, T::Currency::withdraw(
		&amp;account,
		fund.raised,
		WithdrawReasons::from(WithdrawReason::Transfer),
		ExistenceRequirement::AllowDeath,
	)?);

	// Caller collects the deposit
	let _ = T::Currency::resolve_creating(&amp;caller, T::Currency::withdraw(
		&amp;account,
		fund.deposit,
		WithdrawReasons::from(WithdrawReason::Transfer),
		ExistenceRequirement::AllowDeath,
	)?);
</code></pre>
<p>This pallet also uses Currency
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/frame_support/traits/trait.Imbalance.html"><code>Imbalance</code></a>s as discussed in
the <a href="./charity.html">Charity</a> recipe, to make transfers without incurring transfer fees to the
crowdfund pallet itself.</p>
<h1><a class="header" href="#instantiable-pallets" id="instantiable-pallets">Instantiable Pallets</a></h1>
<p><code>pallets/last-caller</code>
<a href="https://playground-staging.substrate.dev/?deploy=recipes&amp;files=%2Fhome%2Fsubstrate%2Fworkspace%2Fpallets%2Flast-caller%2Fsrc%2Flib.rs">
<img src="https://img.shields.io/badge/Playground-Try%20it!-brightgreen?logo=Parity%20Substrate" alt="Try on playground" />
</a>
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/last-caller/src/lib.rs">
<img src="https://img.shields.io/badge/Github-View%20Code-brightgreen?logo=github" alt="View on GitHub" />
</a></p>
<p><code>pallets/default-instance</code>
<a href="https://playground-staging.substrate.dev/?deploy=recipes&amp;files=%2Fhome%2Fsubstrate%2Fworkspace%2Fpallets%2Fdefault-instance%2Fsrc%2Flib.rs">
<img src="https://img.shields.io/badge/Playground-Try%20it!-brightgreen?logo=Parity%20Substrate" alt="Try on playground" />
</a>
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/default-instance/src/lib.rs">
<img src="https://img.shields.io/badge/Github-View%20Code-brightgreen?logo=github" alt="View on GitHub" />
</a></p>
<p>Instantiable pallets enable multiple instances of the same pallet logic within a single runtime.
Each instance of the pallet has its own independent storage, and extrinsics must specify which
instance of the pallet they are intended for. These patterns are illustrated in the kitchen in the
last-caller and default-instance pallets.</p>
<p>Some use cases:</p>
<ul>
<li>Token chain hosts two independent cryptocurrencies.</li>
<li>Marketplace track users' reputations as buyers separately from their reputations as sellers.</li>
<li>Governance has two (or more) houses which act similarly internally.</li>
</ul>
<p>Substrate's own Balances and Collective pallets are good examples of real-world code using this
technique. The default Substrate node has two instances of the Collectives pallet that make up its
Council and Technical Committee. Each collective has its own storage, events, and configuration.</p>
<pre><code class="language-rust ignore">Council: collective::&lt;Instance1&gt;::{Module, Call, Storage, Origin&lt;T&gt;, Event&lt;T&gt;, Config&lt;T&gt;},
TechnicalCommittee: collective::&lt;Instance2&gt;::{Module, Call, Storage, Origin&lt;T&gt;, Event&lt;T&gt;, Config&lt;T&gt;}
</code></pre>
<h2><a class="header" href="#writing-an-instantiable-pallet" id="writing-an-instantiable-pallet">Writing an Instantiable Pallet</a></h2>
<p>Writing an instantiable pallet is almost entirely the same process as writing a plain
non-instantiable pallet. There are just a few places where the syntax differs.</p>
<blockquote>
<p>You must call <code>decl_storage!</code></p>
<p>Instantiable pallets <em>must</em> call the <code>decl_storage!</code> macro so that the <code>Instance</code> type is created.</p>
</blockquote>
<h3><a class="header" href="#configuration-trait-2" id="configuration-trait-2">Configuration Trait</a></h3>
<pre><code class="language-rust ignore">pub trait Trait&lt;I: Instance&gt;: system::Trait {
	/// The overarching event type.
	type Event: From&lt;Event&lt;Self, I&gt;&gt; + Into&lt;&lt;Self as system::Trait&gt;::Event&gt;;
}
</code></pre>
<h3><a class="header" href="#storage-declaration" id="storage-declaration">Storage Declaration</a></h3>
<pre><code class="language-rust ignore">decl_storage! {
	trait Store for Module&lt;T: Trait&lt;I&gt;, I: Instance&gt; as TemplatePallet {
		...
	}
}
</code></pre>
<h3><a class="header" href="#declaring-the-module-struct" id="declaring-the-module-struct">Declaring the <code>Module</code> Struct</a></h3>
<pre><code class="language-rust ignore">decl_module! {
	/// The module declaration.
	pub struct Module&lt;T: Trait&lt;I&gt;, I: Instance&gt; for enum Call where origin: T::Origin {
		...
	}
}
</code></pre>
<h3><a class="header" href="#accessing-storage" id="accessing-storage">Accessing Storage</a></h3>
<pre><code class="language-rust ignore">&lt;Something&lt;T, I&gt;&gt;::put(something);
</code></pre>
<p>If the storage item does not use any types specified in the configuration trait, the T is omitted,
as always.</p>
<pre><code class="language-rust ignore">&lt;Something&lt;I&gt;&gt;::put(something);
</code></pre>
<h3><a class="header" href="#event-initialization" id="event-initialization">Event initialization</a></h3>
<pre><code class="language-rust ignore">fn deposit_event() = default;
</code></pre>
<h3><a class="header" href="#event-declaration" id="event-declaration">Event Declaration</a></h3>
<pre><code class="language-rust ignore">decl_event!(
	pub enum Event&lt;T, I&gt; where AccountId = &lt;T as system::Trait&gt;::AccountId {
		...
	}
}
</code></pre>
<h2><a class="header" href="#installing-a-pallet-instance-in-a-runtime" id="installing-a-pallet-instance-in-a-runtime">Installing a Pallet Instance in a Runtime</a></h2>
<p>The syntax for including an instance of an instantiable pallet in a runtime is slightly different
than for a regular pallet. The only exception is for pallets that use the
<a href="instantiable.html#default-instance">Default Instance</a> feature described below.</p>
<h3><a class="header" href="#implementing-configuration-traits" id="implementing-configuration-traits">Implementing Configuration Traits</a></h3>
<p>Each instance needs to be configured separately. Configuration consists of implementing the specific
instance's trait. The following snippet shows a configuration for <code>Instance1</code>.</p>
<pre><code class="language-rust ignore">impl template::Trait&lt;template::Instance1&gt; for Runtime {
	type Event = Event;
}
</code></pre>
<h3><a class="header" href="#using-the-construct_runtime-macro" id="using-the-construct_runtime-macro">Using the <code>construct_runtime!</code> Macro</a></h3>
<p>The final step of installing the pallet instance in your runtime is updating the
<code>construct_runtime!</code> macro. You may give each instance a meaningful name. Here I've called
<code>Instance1</code> <code>FirstTemplate</code>.</p>
<pre><code class="language-rust ignore">FirstTemplate: template::&lt;Instance1&gt;::{Module, Call, Storage, Event&lt;T&gt;, Config},
</code></pre>
<h2><a class="header" href="#default-instance-a-namedefault-instancea" id="default-instance-a-namedefault-instancea">Default Instance <a name="default-instance"></a></a></h2>
<p>One drawback of instantiable pallets, as we've presented them so far, is that they require the
runtime designer to use the more elaborate syntax even if they only desire a single instance of the
pallet. To alleviate this inconvenience, Substrate provides a feature known as DefaultInstance. This
allows runtime developers to deploy an instantiable pallet exactly as they would if it were not
instantiable provided they <strong>only use a single instance</strong>.</p>
<p>To make your instantiable pallet support DefaultInstance, you must specify it in four places.</p>
<pre><code class="language-rust ignore">pub trait Trait&lt;I=DefaultInstance&gt;: system::Trait {
</code></pre>
<pre><code class="language-rust ignore">decl_storage! {
	trait Store for Module&lt;T: Trait&lt;I&gt;, I: Instance=DefaultInstance&gt; as TemplateModule {
		...
	}
}
</code></pre>
<pre><code class="language-rust ignore">decl_module! {
	pub struct Module&lt;T: Trait&lt;I&gt;, I: Instance = DefaultInstance&gt; for enum Call where origin: T::Origin {
		...
	}
}
</code></pre>
<pre><code class="language-rust ignore">decl_event!(
	pub enum Event&lt;T, I=DefaultInstance&gt; where ... {
		...
	}
}
</code></pre>
<p>Having made these changes, a developer who uses your pallet doesn't need to know or care that your
pallet is instantable. They can deploy it just as they would any other pallet.</p>
<h2><a class="header" href="#genesis-configuration" id="genesis-configuration">Genesis Configuration</a></h2>
<p>Some pallets require a genesis configuration to be specified. Let's look to the default Substrate
node's use of the Collective pallet as an example.</p>
<p>In its <code>chain_spec.rs</code> file we see</p>
<pre><code class="language-rust ignore">GenesisConfig {
	...
	collective_Instance1: Some(CouncilConfig {
		members: vec![],
		phantom: Default::default(),
	}),
	collective_Instance2: Some(TechnicalCommitteeConfig {
		members: vec![],
		phantom: Default::default(),
	}),
	...
}
</code></pre>
<h1><a class="header" href="#computational-resources-and-weights" id="computational-resources-and-weights">Computational Resources and Weights</a></h1>
<p><code>pallets/weights</code>
<a href="https://playground-staging.substrate.dev/?deploy=recipes&amp;files=%2Fhome%2Fsubstrate%2Fworkspace%2Fpallets%2Fweights%2Fsrc%2Flib.rs">
<img src="https://img.shields.io/badge/Playground-Try%20it!-brightgreen?logo=Parity%20Substrate" alt="Try on playground" />
</a>
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/weights/src/lib.rs">
<img src="https://img.shields.io/badge/Github-View%20Code-brightgreen?logo=github" alt="View on GitHub" />
</a></p>
<p>Any computational resources used by a transaction must be accounted for so that appropriate fees can
be applied, and it is a pallet author's job to ensure that this accounting happens. Substrate
provides a mechanism known as transaction weighting to quantify the resources consumed while
executing a transaction.</p>
<p><em>Indeed, mispriced EVM operations have shown how operations that underestimate cost can provide
economic DOS attack vectors: <a href="https://www.parity.io/onwards/">Onwards; Underpriced EVM Operations</a></em></p>
<h2><a class="header" href="#assigning-transaction-weights" id="assigning-transaction-weights">Assigning Transaction Weights</a></h2>
<p>Pallet authors can annotate their dispatchable function with a weight using syntax like this,</p>
<pre><code class="language-rust ignore">#[weight = &lt;Some Weighting Instance&gt;]
fn some_call(...) -&gt; Result {
	// --snip--
}
</code></pre>
<p>For simple transactions a fixed weight will do. Substrate allows simply specifying a constant
integer in cases situations like this.</p>
<pre><code class="language-rust ignore">decl_module! {
	pub struct Module&lt;T: Trait&gt; for enum Call {

		#[weight = 10_000]
		fn store_value(_origin, entry: u32) -&gt; DispatchResult {
			StoredValue::put(entry);
			Ok(())
		}
</code></pre>
<p>For more complex transactions, custom weight calculations can be performed that consider the
parameters passed to the call. This snippet shows a weighting struct that weighs transactions where
the first parameter is a <code>bool</code>. If the first parameter is <code>true</code>, then the weight is linear in the
second parameter. Otherwise the weight is constant. A transaction where this weighting scheme makes
sense is demonstrated in the kitchen.</p>
<pre><code class="language-rust ignore">pub struct Conditional(u32);

impl WeighData&lt;(&amp;bool, &amp;u32)&gt; for Conditional {
	fn weigh_data(&amp;self, (switch, val): (&amp;bool, &amp;u32)) -&gt; Weight {

		if *switch {
			val.saturating_mul(self.0)
		}
		else {
			self.0
		}
	}
}
</code></pre>
<p>In addition to the
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/frame_support/weights/trait.WeighData.html"><code>WeightData</code> Trait</a>, shown
above, types that are used to calculate transaction weights must also implement
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/frame_support/weights/trait.ClassifyDispatch.html"><code>ClassifyDispatch</code></a>,
and <a href="https://substrate.dev/rustdocs/v2.0.0-rc6/frame_support/weights/trait.PaysFee.html"><code>PaysFee</code></a>.</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; ClassifyDispatch&lt;T&gt; for Conditional {
    fn classify_dispatch(&amp;self, _: T) -&gt; DispatchClass {
        // Classify all calls as Normal (which is the default)
        Default::default()
    }
}
</code></pre>
<pre><code class="language-rust ignore">impl PaysFee for Conditional {
    fn pays_fee(&amp;self) -&gt; bool {
        true
    }
}
</code></pre>
<p>The complete code for this example as well as several others can be found in the kitchen.</p>
<h2><a class="header" href="#cautions" id="cautions">Cautions</a></h2>
<p>While you can make reasonable estimates of resource consumption at design time, it is always best to
actually measure the resources required of your functions through an empirical process. Failure to
perform such rigorous measurement may result in an economically insecure chain.</p>
<p>While it isn't enforced, calculating a transaction's weight should itself be a cheap operation. If
the weight calculation itself is expensive, your chain will be insecure.</p>
<h2><a class="header" href="#what-about-fees" id="what-about-fees">What About Fees?</a></h2>
<p>Weights are used only to describe the computational resources consumed by a transaction, and enable
accounting of these resources. To learn how to turn these weights into actual fees charged to
transactors, continue to the recipe on <a href="./fees.html">Fees</a>.</p>
<h1><a class="header" href="#charity" id="charity">Charity</a></h1>
<p><code>pallets/charity</code>
<a href="https://playground-staging.substrate.dev/?deploy=recipes&amp;files=%2Fhome%2Fsubstrate%2Fworkspace%2Fpallets%2Fcharity%2Fsrc%2Flib.rs">
<img src="https://img.shields.io/badge/Playground-Try%20it!-brightgreen?logo=Parity%20Substrate" alt="Try on playground" />
</a>
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/charity/src/lib.rs">
<img src="https://img.shields.io/badge/Github-View%20Code-brightgreen?logo=github" alt="View on GitHub" />
</a></p>
<p>The Charity pallet represents a simple charitable organization that collects funds into a pot that
it controls, and allocates those funds to the appropriate causes. It demonstrates two useful
concepts in Substrate development:</p>
<ul>
<li>A pallet-controlled shared pot of funds</li>
<li>Absorbing imbalances from the runtime</li>
</ul>
<h2><a class="header" href="#instantiate-a-pot" id="instantiate-a-pot">Instantiate a Pot</a></h2>
<p>Our charity needs an account to hold its funds. Unlike other accounts, it will not be controlled by
a user's cryptographic key pair, but directly by the pallet. To instantiate such a pool of funds,
import <a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sp_runtime/struct.ModuleId.html"><code>ModuleId</code></a> and
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sp_runtime/traits/trait.AccountIdConversion.html"><code>AccountIdConversion</code></a>
from <a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sp_runtime/index.html"><code>sp-runtime</code></a>.</p>
<pre><code class="language-rust ignore">use sp-runtime::{ModuleId, traits::AccountIdConversion};
</code></pre>
<p>With these imports, a <code>PALLET_ID</code> constant can be generated as an identifier for the pool of funds.
The <code>PALLET_ID</code> must be exactly eight characters long which is why we've included the exclamation
point. (Well, that and Charity work is just so exciting!) This identifier can be converted into an
<code>AccountId</code> with the <code>into_account()</code> method provided by the <code>AccountIdConversion</code> trait.</p>
<pre><code class="language-rust ignore">const PALLET_ID: ModuleId = ModuleId(*b&quot;Charity!&quot;);

impl&lt;T: Trait&gt; Module&lt;T&gt; {
	/// The account ID that holds the Charity's funds
	pub fn account_id() -&gt; T::AccountId {
		PALLET_ID.into_account()
	}

	/// The Charity's balance
	fn pot() -&gt; BalanceOf&lt;T&gt; {
		T::Currency::free_balance(&amp;Self::account_id())
	}
}
</code></pre>
<h1><a class="header" href="#receiving-funds" id="receiving-funds">Receiving Funds</a></h1>
<p>Our charity can receive funds in two different ways.</p>
<h2><a class="header" href="#donations" id="donations">Donations</a></h2>
<p>The first and perhaps more familiar way is through charitable donations. Donations can be made
through a standard <code>donate</code> extrinsic which accepts the amount to be donated as a parameter.</p>
<pre><code class="language-rust ignore">fn donate(
		origin,
		amount: BalanceOf&lt;T&gt;
) -&gt; DispatchResult {
		let donor = ensure_signed(origin)?;

		let _ = T::Currency::transfer(&amp;donor, &amp;Self::account_id(), amount, AllowDeath);

		Self::deposit_event(RawEvent::DonationReceived(donor, amount, Self::pot()));
		Ok(())
}
</code></pre>
<h2><a class="header" href="#imbalances" id="imbalances">Imbalances</a></h2>
<p>The second way the charity can receive funds is by absorbing imbalances created elsewhere in the
runtime. An <a href="https://substrate.dev/rustdocs/v2.0.0-rc6/frame_support/traits/trait.Imbalance.html"><code>Imbalance</code></a> is
created whenever tokens are burned, or minted. Because our charity wants to <em>collect</em> funds, we are
specifically interested in
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/pallet_balances/struct.NegativeImbalance.html"><code>NegativeImbalance</code></a>s.
Negative imbalances are created, for example, when a validator is slashed for violating consensus
rules, transaction fees are collected, or another pallet burns funds as part of an
incentive-alignment mechanism. To allow our pallet to absorb these imbalances, we implement the
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/frame_support/traits/trait.OnUnbalanced.html"><code>OnUnbalanced</code> trait</a>.</p>
<pre><code class="language-rust ignore">use frame_support::traits::{OnUnbalanced, Imbalance};
type NegativeImbalanceOf&lt;T&gt; = &lt;&lt;T as Trait&gt;::Currency as Currency&lt;&lt;T as system::Trait&gt;::AccountId&gt;&gt;::NegativeImbalance;

impl&lt;T: Trait&gt; OnUnbalanced&lt;NegativeImbalanceOf&lt;T&gt;&gt; for Module&lt;T&gt; {
	fn on_nonzero_unbalanced(amount: NegativeImbalanceOf&lt;T&gt;) {
		let numeric_amount = amount.peek();

		// Must resolve into existing but better to be safe.
		let _ = T::Currency::resolve_creating(&amp;Self::account_id(), amount);

		Self::deposit_event(RawEvent::ImbalanceAbsorbed(numeric_amount, Self::pot()));
	}
}
</code></pre>
<h1><a class="header" href="#allocating-funds" id="allocating-funds">Allocating Funds</a></h1>
<p>In order for the charity to affect change with the funds it has collected it must be able to
allocate those funds. Our charity pallet abstracts the governance of where funds will be allocated
to the rest of the runtime. Funds can be allocated by a root call to the <code>allocate</code> extrinsic. One
good example of a governance mechanism for such decisions is Substrate's own
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/pallet_democracy/index.html">Democracy pallet</a>.</p>
<h1><a class="header" href="#fixed-point-arithmetic" id="fixed-point-arithmetic">Fixed Point Arithmetic</a></h1>
<p><code>pallets/fixed-point</code>
<a href="https://playground-staging.substrate.dev/?deploy=recipes&amp;files=%2Fhome%2Fsubstrate%2Fworkspace%2Fpallets%2Ffixed-point%2Fsrc%2Flib.rs">
<img src="https://img.shields.io/badge/Playground-Try%20it!-brightgreen?logo=Parity%20Substrate" alt="Try on playground" />
</a>
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/fixed-point/src/lib.rs">
<img src="https://img.shields.io/badge/Github-View%20Code-brightgreen?logo=github" alt="View on GitHub" />
</a></p>
<p><code>pallets/compounding-interest</code>
<a href="https://playground-staging.substrate.dev/?deploy=recipes&amp;files=%2Fhome%2Fsubstrate%2Fworkspace%2Fpallets%2Fcompounding-interest%2Fsrc%2Flib.rs">
<img src="https://img.shields.io/badge/Playground-Try%20it!-brightgreen?logo=Parity%20Substrate" alt="Try on playground" />
</a>
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/compounding-interest/src/lib.rs">
<img src="https://img.shields.io/badge/Github-View%20Code-brightgreen?logo=github" alt="View on GitHub" />
</a></p>
<p>When programmers learn to use non-integer numbers in their programs, they are usually taught to use
<a href="https://en.wikipedia.org/wiki/Floating-point_arithmetic">floating point</a>s. In blockchain, we use an
alternative representation of fractional numbers called
<a href="https://en.wikipedia.org/wiki/Fixed-point_arithmetic">fixed point</a>. There are several ways to use
fixed point numbers, and this recipe will introduce three of them. In particular we'll see:</p>
<ul>
<li>Substrate's own fixed point structs and traits</li>
<li>The <a href="https://github.com/encointer/substrate-fixed/">substrate-fixed</a> library</li>
<li>A manual fixed point implementation (and why it's nicer to use a library)</li>
<li>A comparison of the two libraries in a compounding interest example</li>
</ul>
<h2><a class="header" href="#whats-wrong-with-floats" id="whats-wrong-with-floats">What's Wrong with Floats?</a></h2>
<p>Floats are cool for all kinds of reasons, but they also have one important drawback. Floating point
arithmetic is <strong>nondeterministic</strong> which means that different processors compute (slightly)
different results for the same operation. Although there is an
<a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE spec</a>, nondeterminism can come from specific libraries
used, or even hardware. In order for the nodes in a blockchain network to reach agreement on the
state of the chain, all operations must be completely deterministic. Luckily fixed point arithmetic
is deterministic, and is often not much harder to use once you get the hang of it.</p>
<h2><a class="header" href="#multiplicative-accumulators" id="multiplicative-accumulators">Multiplicative Accumulators</a></h2>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/fixed-point"><code>pallets/fixed-point</code></a></em></p>
<p>The first pallet covered in this recipe contains three implementations of a multiplicative
accumulator. That's a fancy way to say the pallet lets users submit fractional numbers and keeps
track of the product from multiplying them all together. The value starts out at one (the
<a href="https://en.wikipedia.org/wiki/Identity_element">multiplicative identity</a>), and it gets multiplied
by whatever values the users submit. These three independent implementations compare and contrast
the features of each.</p>
<h3><a class="header" href="#permill-accumulator" id="permill-accumulator">Permill Accumulator</a></h3>
<p>We'll be using the most common approach which takes its fixed point implementation from Substrate
itself. There are a few fixed-point structs available in Substrate, all of which implement the
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sp_arithmetic/trait.PerThing.html"><code>PerThing</code> trait</a>, that cover different
amounts of precision. For this accumulator example, we'll use the
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sp_arithmetic/struct.Permill.html"><code>PerMill</code> struct</a> which represents
fractions as parts per million. There are also
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sp_arithmetic/struct.Perbill.html"><code>Perbill</code></a>,
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sp_arithmetic/struct.Percent.html"><code>PerCent</code></a>, and
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sp_arithmetic/struct.PerU16.html"><code>PerU16</code></a>, which all provide the same
interface (because it comes from the trait). Substrate's fixed-point structs are somewhat unique
because they represent <em>only</em> fractional parts of numbers. That means they can represent numbers
between 0 and 1 inclusive, but <em>not</em> numbers with whole parts like 2.718 or 3.14.</p>
<p>To begin we declare the storage item that will hold our accumulated product. You can see that the
trait provides a handy function for getting the identity value which we use to set the default
storage value to <code>1</code>.</p>
<pre><code class="language-rust ignore">decl_storage! {
	trait Store for Module&lt;T: Trait&gt; as Example {
		// --snip--

		/// Permill accumulator, value starts at 1 (multiplicative identity)
		PermillAccumulator get(fn permill_value): Permill = Permill::one();
	}
}
</code></pre>
<p>The only extrinsic for this Permill accumulator is the one that allows users to submit new <code>Permill</code>
values to get multiplied into the accumulator.</p>
<pre><code class="language-rust ignore">fn update_permill(origin, new_factor: Permill) -&gt; DispatchResult {
	ensure_signed(origin)?;

	let old_accumulated = Self::permill_value();

	// There is no need to check for overflow here. Permill holds values in the range
	// [0, 1] so it is impossible to ever overflow.
	let new_product = old_accumulated.saturating_mul(new_factor);

	// Write the new value to storage
	PermillAccumulator::put(new_product);

	// Emit event
	Self::deposit_event(Event::PermillUpdated(new_factor, new_product));
	Ok(())
}
</code></pre>
<p>The code of this extrinsic largely speaks for itself. One thing to take particular note of is that
we <em>don't</em> check for overflow on the multiplication. If you've read many of the recipes you know
that a Substrate runtime must never panic, and a developer must be extremely diligent in always
checking for and gracefully handling error conditions. Because <code>Permill</code> only holds values between 0
and 1, we know that their product will always be in that same range. Thus it is impossible to
overflow or saturate. So we can happily use <code>saturating_mul</code> and move on.</p>
<h3><a class="header" href="#substrate-fixed-accumulator" id="substrate-fixed-accumulator">Substrate-fixed Accumulator</a></h3>
<p><a href="https://github.com/encointer/substrate-fixed/">Substrate-fixed</a> takes a more traditional approach
in that their types represent numbers with both whole <em>and</em> fractional parts. For this
implementation, we'll use the <code>U16F16</code> type. This type contains an unsigned number (indicated by the
<code>U</code> at the beginning) and has 32 <em>total</em> bits of precision - 16 for the integer part, and 16 for the
fractional part. There are several other types provided that follow the same naming convention. Some
examples include <code>U32F32</code> and <code>I32F32</code> where the <code>I</code> indicates a signed number, just like in Rust
primitive types.</p>
<p>As in the <code>Permill</code> example, we begin by declaring the storage item. With substrate-fixed, there is
not a <code>one</code> function, but there is a <code>from_num</code> function that we use to set the storage item's
default value. This <code>from_num</code> method and its counterpart <code>to-num</code> are your primary ways of
converting between substrate-fixed types and Rust primitive types. If your use case does a lot of
fixed-point arithmetic, like ours does, it is advisable to keep your data in substrate-fixed types.</p>
<blockquote>
<p>We're able to use <code>U16F16</code> as a storage item type because it, and the other substrate-fixed types,
implements the parity scale codec.</p>
</blockquote>
<pre><code class="language-rust ignore">decl_storage! {
	trait Store for Module&lt;T: Trait&gt; as Example {
		// --snip--

		/// Substrate-fixed accumulator, value starts at 1 (multiplicative identity)
		FixedAccumulator get(fn fixed_value): U16F16 = U16F16::from_num(1);
	}
}
</code></pre>
<p>Next we implement the extrinsic that allows users to update the accumulator by multiplying in a new
value.</p>
<pre><code class="language-rust ignore">fn update_fixed(origin, new_factor: U16F16) -&gt; DispatchResult {
	ensure_signed(origin)?;

	let old_accumulated = Self::fixed_value();

	// Multiply, handling overflow
	let new_product = old_accumulated.checked_mul(new_factor)
		.ok_or(Error::&lt;T&gt;::Overflow)?;

	// Write the new value to storage
	FixedAccumulator::put(new_product);

	// Emit event
	Self::deposit_event(Event::FixedUpdated(new_factor, new_product));
	Ok(())
}
</code></pre>
<p>This extrinsic is quite similar to the <code>Permill</code> version with one notable difference. Because
<code>U16F16</code> handles numbers greater than one, overflow is possible, and we need to handle it. The error
handling here is straightforward, the important part is just that you remember to do it.</p>
<p>This example has shown the fundamentals of substrate-fixed, but this library has much more to offer
as we'll see in the compounding interest example.</p>
<h3><a class="header" href="#manual-accumulator" id="manual-accumulator">Manual Accumulator</a></h3>
<p>In this final accumulator implementation, we manually track fixed point numbers using Rust's native
<code>u32</code> as the underlying data type. This example is educational, but is only practical in the
simplest scenarios. Generally you will have a <del>more fun</del> less error-prone time coding if you use
one of the previous two fixed-point types in your real-world applications.</p>
<p>Fixed point is not very complex conceptually. We represent fractional numbers as regular old
integers, and we decide in advance to consider some of the place values fractional. It's just like
saying we'll omit the decimal point when talking about money and all agree that &quot;1995&quot; actually
<em>means</em> 19.95 ‚Ç¨. This is exactly how Substrate's
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/pallet_balances/index.html">Balances pallet</a> works, a tradition that's
been in blockchain since Bitcon. In our example we will treat 16 bits as integer values, and 16 as
fractional, just as substrate-fixed's <code>U16F16</code> did.</p>
<p>If you're rusty or unfamiliar with place values in the
<a href="https://en.wikipedia.org/wiki/Binary_number">binary number system</a>, it may be useful to brush up.
(Or skip this detailed section and proceed to the compounding interest example.)</p>
<pre><code>Normal interpretation of u32 place values
... ___ ___ ___ ___ ___ ___ ___ .
...  64  32  16  8   4   2   1

Fixed interpretation of u32 place values
... ___ ___ ___ ___ . ___ ___ ___ ___ ...
...  8   4   2   1    1/2 1/4 1/8 1/16...
</code></pre>
<p>Although the concepts are straight-forward, you'll see that manually implementing operations like
multiplication is quite error prone. Therefore, when writing your own blockchain applications, it is
often best to use on of the provided libraries covered in the other two implementations of the
accumulator.</p>
<p>As before, we begin by declaring the storage value. This time around it is just a simple u32. But
the default value, <code>1 &lt;&lt; 16</code> looks quite funny. If you haven't encountered it before <code>&lt;&lt;</code> is Rust's
<a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#arithmetic-and-logical-binary-operators">bit shift operator</a>.
It takes a value and moves all the bits to the left. In this case we start with the value <code>1</code> and
move it 16 bits to the left. This is because Rust interprets <code>1</code> as a regular <code>u32</code> value and puts
the <code>1</code> in the far right place value. But because we're treating this <code>u32</code> specially, we need to
shift that bit to the middle just left of the imaginary radix point.</p>
<pre><code class="language-rust ignore">decl_storage! {
	trait Store for Module&lt;T: Trait&gt; as Example {
		// --snip--

		/// Manual accumulator, value starts at 1 (multiplicative identity)
		ManualAccumulator get(fn manual_value): u32 = 1 &lt;&lt; 16;
	}
}
</code></pre>
<p>The extrinsic to multiply a new factor into the accumulator follows the same general flow as in the
other two implementations. In this case, there are more intermediate values calculated, and more
comments explaining the bit-shifting operations. In the function body most intermediate values are
held in <code>u64</code> variables. This is because when you multiply two 32-bit numbers, you can end up with
as much as 64 bits in the product.</p>
<pre><code class="language-rust ignore">fn update_manual(origin, new_factor: u32) -&gt; DispatchResult {
	ensure_signed(origin)?;

	// To ensure we don't overflow unnecessarily, the values are cast up to u64 before multiplying.
	// This intermediate format has 48 integer positions and 16 fractional.
	let old_accumulated : u64 = Self::manual_value() as u64;
	let new_factor_u64 : u64 = new_factor as u64;

	// Perform the multiplication on the u64 values
	// This intermediate format has 32 integer positions and 32 fractional.
	let raw_product : u64 = old_accumulated * new_factor_u64;

	// Right shift to restore the convention that 16 bits are fractional.
	// This is a lossy conversion.
	// This intermediate format has 48 integer positions and 16 fractional.
	let shifted_product : u64 = raw_product &gt;&gt; 16;

	// Ensure that the product fits in the u32, and error if it doesn't
	if shifted_product &gt; (u32::max_value() as u64) {
		return Err(Error::&lt;T&gt;::Overflow.into())
	}

	// Write the new value to storage
	ManualAccumulator::put(shifted_product as u32);

	// Emit event
	Self::deposit_event(Event::ManualUpdated(new_factor, shifted_product as u32));
	Ok(())
}
</code></pre>
<p>As mentioned above, when you multiply two 32-bit numbers, you can end up with as much as 64 bits in
the product. In this 64-bit intermediate product, we have 32 integer bits and 32 fractional. We can
simply throw away the 16 right-most fractional bits that merely provide extra precision. But we need
to be careful with the 16 left-most integer bits. If any of those bits are non-zero after the
multiplication it means overflow has occurred. If they are all zero, then we can safely throw them
away as well.</p>
<blockquote>
<p>If this business about having more bits after the multiplication is confusing, try this exercise
in the more familiar decimal system. Consider these numbers that have 4 total digits (2 integer,
and two fractional): 12.34 and 56.78. Multiply them together. How many integer and fractional
digits are in the product? Try that again with larger numbers like 98.76 and 99.99, and smaller like
00.11 and 00.22. Which of these products can be fit back into a 4-digit number like the ones we
started with?</p>
</blockquote>
<h2><a class="header" href="#compounding-interest" id="compounding-interest">Compounding Interest</a></h2>
<p><em><a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/compounding-interest"><code>pallets/compounding-interest</code></a></em></p>
<p>Many financial agreements involve interest for loaned or borrowed money.
<a href="https://en.wikipedia.org/wiki/Compound_interest">Compounding interest</a> is when new interest is paid
on top of not only the original loan amount, the so-called &quot;principal&quot;, but also any interest that
has been previously paid.</p>
<h3><a class="header" href="#discrete-compounding" id="discrete-compounding">Discrete Compounding</a></h3>
<p>Our first example will look at discrete compounding interest. This is when interest is paid at a
fixed interval. In our case, interest will be paid every ten blocks.</p>
<p>For this implementation we've chosen to use Substrate's
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sp_arithmetic/struct.Percent.html"><code>Percent</code> type</a>. It works nearly the
same as <code>Permill</code>, but it represents numbers as &quot;parts per hundred&quot; rather than &quot;parts per million&quot;.
We could also have used Substrate-fixed for this implementation, but chose to save it for the next
example.</p>
<p>The only storage item needed is a tracker of the account's balance. In order to focus on the
fixed-point- and interest-related topics, this pallet does not actually interface with a <code>Currency</code>.
Instead we just allow anyone to &quot;deposit&quot; or &quot;withdraw&quot; funds with no source or destination.</p>
<pre><code class="language-rust ignore">decl_storage! {
	trait Store for Module&lt;T: Trait&gt; as Example {
		// --snip--

		/// Balance for the discrete interest account
		DiscreteAccount get(fn discrete_account): u64;
	}
}
</code></pre>
<p>There are two extrinsics associated with the discrete interest account. The <code>deposit_discrete</code>
extrinsic is shown here, and the <code>withdraw_discrete</code> extrinsic is nearly identical. Check it out in
the kitchen.</p>
<pre><code class="language-rust ignore">fn deposit_discrete(origin, val_to_add: u64) -&gt; DispatchResult {
	ensure_signed(origin)?;

	let old_value = DiscreteAccount::get();

	// Update storage for discrete account
	DiscreteAccount::put(old_value + val_to_add);

	// Emit event
	Self::deposit_event(Event::DepositedDiscrete(val_to_add));
	Ok(())
}
</code></pre>
<p>The flow of these deposit and withdraw extrinsics is entirely straight-forward. They each perform a
simple addition or substraction from the stored value, and they have nothing to do with interest.</p>
<p>Because the interest is paid discretely every ten blocks it can be handled independently of deposits
and withdrawals. The interest calculation happens automatically in the <code>on_finalize</code> block.</p>
<pre><code class="language-rust ignore">fn on_finalize(n: T::BlockNumber) {
	// Apply newly-accrued discrete interest every ten blocks
	if (n % 10.into()).is_zero() {

		// Calculate interest Interest = principal * rate * time
		// We can use the `*` operator for multiplying a `Percent` by a u64
		// because `Percent` implements the trait Mul&lt;u64&gt;
		let interest = Self::discrete_interest_rate() * DiscreteAccount::get() * 10;

		// The following line, although similar, does not work because
		// u64 does not implement the trait Mul&lt;Percent&gt;
		// let interest = DiscreteAccount::get() * Self::discrete_interest_rate() * 10;

		// Update the balance
		let old_balance = DiscreteAccount::get();
		DiscreteAccount::put(old_balance + interest);

		// Emit the event
		Self::deposit_event(Event::DiscreteInterestApplied(interest));
	}
}
</code></pre>
<p><code>on_finalize</code> is called at the end of every block, but we only want to pay interest every ten
blocks, so the first thing we do is check whether this block is a multiple of ten. If it is we
calculate the interest due by the formula <code>interest = principal * rate * time</code>. As the comments
explain, there is some subtlety in the order of the multiplication. You can multiply <code>PerCent * u64</code>
but not <code>u64 * PerCent</code>.</p>
<h3><a class="header" href="#continuously-compounding" id="continuously-compounding">Continuously Compounding</a></h3>
<p>You can imagine increasing the frequency at which the interest is paid out. Increasing the frequency
enough approaches
<a href="https://en.wikipedia.org/wiki/Compound_interest#Continuous_compounding">continuously compounding interest</a>.
Calculating continuously compounding interest requires the
<a href="https://en.wikipedia.org/wiki/Exponential_function">exponential function</a> which is not available
using Substrate's <code>PerThing</code> types. Luckily exponential and other
<a href="https://en.wikipedia.org/wiki/Transcendental_function">transcendental functions</a> are available in
substrate-fixed, which is why we've chosen to use it for this example.</p>
<p>With continuously compounded interest, we <em>could</em> update the interest in <code>on_finalize</code> as we did
before, but it would need to be updated every single block. Instead we wait until a user tries to
use the account (to deposit or withdraw funds), and then calculate the account's current value &quot;just
in time&quot;.</p>
<p>To facilitate this implementation, we represent the state of the account not only as a balance, but
as a balance, paired with the time when that balance was last updated.</p>
<pre><code class="language-rust ignore">#[derive(Encode, Decode, Default)]
pub struct ContinuousAccountData&lt;BlockNumber&gt; {
	/// The balance of the account after last manual adjustment
	principal: I32F32,
	/// The time (block height) at which the balance was last adjusted
	deposit_date: BlockNumber,
}
</code></pre>
<p>You can see we've chosen substrate-fixed's <code>I32F32</code> as our balance type this time. While we don't
intend to handle negative balances, there is currently a limitation in the transcendental functions
that requires using signed types.</p>
<p>With the struct to represent the account's state defined, we can initialize the storage value.</p>
<pre><code class="language-rust ignore">decl_storage! {
	trait Store for Module&lt;T: Trait&gt; as Example {
		// --snip--

		/// Balance for the continuously compounded account
		ContinuousAccount get(fn balance_compound): ContinuousAccountData&lt;T::BlockNumber&gt;;
	}
}
</code></pre>
<p>As before, there are two relevant extrinsics, <code>deposit_continuous</code> and <code>withdraw_continuous</code>. They
are nearly identical so we'll only show one.</p>
<pre><code class="language-rust ignore">fn deposit_continuous(origin, val_to_add: u64) -&gt; DispatchResult {
	ensure_signed(origin)?;

	let current_block = system::Module::&lt;T&gt;::block_number();
	let old_value = Self::value_of_continuous_account(&amp;current_block);

	// Update storage for compounding account
	ContinuousAccount::&lt;T&gt;::put(
		ContinuousAccountData {
			principal: old_value + I32F32::from_num(val_to_add),
			deposit_date: current_block,
		}
	);

	// Emit event
	Self::deposit_event(Event::DepositedContinuous(val_to_add));
	Ok(())
}
</code></pre>
<p>This function itself isn't too insightful. It does the same basic things as the discrete variant:
look up the old value and the deposit, update storage, and emit an event. The one interesting part
is that it calls a helper function to get the account's previous value. This helper function
calculates the value of the account considering all the interest that has accrued since the last
time the account was touched. Let's take a closer look.</p>
<pre><code class="language-rust ignore">fn value_of_continuous_account(now: &amp;&lt;T as system::Trait&gt;::BlockNumber) -&gt; I32F32 {
	// Get the old state of the accout
	let ContinuousAccountData{
		principal,
		deposit_date,
	} = ContinuousAccount::&lt;T&gt;::get();

	// Calculate the exponential function (lots of type conversion)
	let elapsed_time_block_number = *now - deposit_date;
	let elapsed_time_u32 = TryInto::try_into(elapsed_time_block_number)
		.expect(&quot;blockchain will not exceed 2^32 blocks; qed&quot;);
	let elapsed_time_i32f32 = I32F32::from_num(elapsed_time_u32);
	let exponent : I32F32 = Self::continuous_interest_rate() * elapsed_time_i32f32;
	let exp_result : I32F32 = exp(exponent)
		.expect(&quot;Interest will not overflow account (at least not until the learner has learned enough about fixed point :)&quot;);

	// Return the result interest = principal * e ^ (rate * time)
	principal * exp_result
}
</code></pre>
<p>This function gets the previous state of the account, makes the interest calculation and returns the
result. The reality of making these fixed point calculations is that type conversion will likely be
your biggest pain point. Most of the lines are doing type conversion between the <code>BlockNumber</code>,
<code>u32</code>, and <code>I32F32</code> types.</p>
<p>We've already seen that this helper function is used within the runtime for calculating the current
balance &quot;just in time&quot; to make adjustments. In a real-world scenario, chain users would also want to
check their balance at any given time. Because the current balance is not stored in runtime storage,
it would be wise to <a href="./runtime-api.html">implement a runtime API</a> so this helper can be called from
outside the runtime.</p>
<h1><a class="header" href="#off-chain-workers" id="off-chain-workers">Off-chain Workers</a></h1>
<blockquote>
<p>Here we focus on building off-chain workers in Substrate. To read more about what off-chain
workers are, why you want to use them, and what kinds of problems they solve best. Please goto
<a href="https://substrate.dev/docs/en/knowledgebase/learn-substrate/off-chain-workers">our guide</a>.</p>
</blockquote>
<p>Off-chain workers allow your Substrate node to offload tasks that take too long or too much CPU /
memory resources to compute, or have non-deterministic result. In particular there are a set of
helpers allowing fetching of HTTP requests and parsing for JSON. It also provides storage that is
specific to the particular Substrate node and not shared across the network. Off-chain workers can
also submit either signed or unsigned transactions back on-chain.</p>
<p>We will deep-dive into each of the topics below.</p>
<ul>
<li><a href="off-chain-workers/./transactions.html">Signed and Unsigned Transactions</a></li>
<li><a href="off-chain-workers/./http-json.html">HTTP fetching and JSON parsing</a></li>
<li><a href="off-chain-workers/./storage.html">Local storage in Off-chain Workers</a></li>
</ul>
<h1><a class="header" href="#transactions-in-off-chain-workers" id="transactions-in-off-chain-workers">Transactions in Off-chain Workers</a></h1>
<p><code>pallets/ocw-demo</code>
<a href="https://playground-staging.substrate.dev/?deploy=recipes&files=%2Fhome%2Fsubstrate%2Fworkspace%2Fpallets%ocw-demo%2Fsrc%2Flib.rs" target="_blank"><img src="https://img.shields.io/badge/Playground-Try%20it!-brightgreen?logo=Parity%20Substrate" alt="Try on playground" /></a>
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/ocw-demo/src/lib.rs" target="_blank"><img src="https://img.shields.io/badge/Github-View%20Code-brightgreen?logo=github" alt="View on GitHub" /></a></p>
<h2><a class="header" href="#compiling-this-pallet" id="compiling-this-pallet">Compiling this Pallet</a></h2>
<p>This <code>ocw-demo</code> pallet is included in the
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/runtimes/ocw-runtime">ocw-runtime</a>.
In order to use this runtime in the kitchen node, we open the <code>nodes/kitchen-node/Cargo.toml</code> file,
enable the <code>ocw-runtime</code> package and comment out the <code>super-runtime</code> package.</p>
<p>Then we build the kitchen node with <code>ocw</code> feature flag:</p>
<pre><code class="language-bash"># Switch to kitchen-node directory
cd nodes/kitchen-node

# Compile with OCW feature
cargo build --release --features ocw
</code></pre>
<p>With this feature flag, an account key is injected into the Substrate node keystore.</p>
<p>src:
<a href="https://github.com/substrate-developer-hub/recipes/blob/master/nodes/kitchen-node/src/service.rs"><code>nodes/kitchen-node/src/service.rs</code></a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Initialize seed for signing transaction using off-chain workers
#[cfg(feature = &quot;ocw&quot;)]
{
	keystore.write().insert_ephemeral_from_seed_by_type::&lt;runtime::offchain_demo::crypto::Pair&gt;(
		&quot;//Alice&quot;, runtime::offchain_demo::KEY_TYPE
	).expect(&quot;Creating key with account Alice should succeed.&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#life-cycle-of-off-chain-worker" id="life-cycle-of-off-chain-worker">Life-cycle of Off-chain Worker</a></h2>
<p>Running the <code>kitchen-node</code> you will see log messages similar to the following:</p>
<pre><code>2020-09-02 11:09:33.780 main WARN sc_cli::commands::run_cmd  Running in --dev mode, RPC CORS has been disabled.
2020-09-02 11:09:33.780 main INFO sc_cli::runner  Kitchen Node
2020-09-02 11:09:33.781 main INFO sc_cli::runner  ‚úåÔ∏è  version 2.0.0-rc6-unknown-x86_64-linux-gnu
2020-09-02 11:09:33.781 main INFO sc_cli::runner  ‚ù§Ô∏è  by Substrate DevHub &lt;https://github.com/substrate-developer-hub&gt;, 2019-2020
2020-09-02 11:09:33.781 main INFO sc_cli::runner  üìã Chain specification: Development
2020-09-02 11:09:33.781 main INFO sc_cli::runner  üè∑  Node name: precious-angle-3060
2020-09-02 11:09:33.781 main INFO sc_cli::runner  üë§ Role: AUTHORITY
2020-09-02 11:09:33.781 main INFO sc_cli::runner  üíæ Database: RocksDb at /home/jimmychu/.local/share/kitchen-node/chains/dev/db
2020-09-02 11:09:33.781 main INFO sc_cli::runner  ‚õì  Native runtime: ocw-runtime-1 (ocw-runtime-1.tx1.au1)
2020-09-02 11:09:34.881 main INFO sc_service::client::client  üî® Initializing Genesis block/state (state: 0x2b24‚Ä¶4bf9, header-hash: 0xde55‚Ä¶8fed)
2020-09-02 11:09:35.081 main WARN sc_service::builder  Using default protocol ID &quot;sup&quot; because none is configured in the chain specs
2020-09-02 11:09:35.083 main INFO sub-libp2p  üè∑  Local node identity is: 12D3KooWC8iNnJqM64qiurVSA3mRFGE4LPj99QPVtUE6whyxFAJy (legacy representation: QmZPmiuc4DAmM7Fo6GdChmxF4pTaDc8brgUKVXLhxKjq62)
2020-09-02 11:09:35.517 main INFO sc_service::builder  üì¶ Highest known block at #0
2020-09-02 11:09:35.519 tokio-runtime-worker INFO substrate_prometheus_endpoint::known_os  „ÄΩÔ∏è Prometheus server started at 127.0.0.1:9615
2020-09-02 11:09:40.527 tokio-runtime-worker INFO substrate  üí§ Idle (0 peers), best: #0 (0xde55‚Ä¶8fed), finalized #0 (0xde55‚Ä¶8fed), ‚¨á 0 ‚¨Ü 0
...
</code></pre>
<p>First, pay attention the line <code>‚õì  Native runtime: ocw-runtime-1 (ocw-runtime-1.tx1.au1)</code>
to ensure we are running the kitchen-node with the <code>ocw-runtime</code>.</p>
<p>Other than that, you will realized the chain is just sitting idled. This is because currently off-chain
worker is only run after a block is imported. Our kitchen node is configured to use
<a href="off-chain-workers/../kitchen-node.html">instant-seal consensus</a>, meaning that we need to send a transaction to trigger a
block to be imported.</p>
<p>Once a transaction is sent, such as using <a href="https://polkadot.js.org/apps?rpc=ws://localhost:9944">Polkadot-JS App</a>
to perform a balance transfer, the following more interesting logs are shown.</p>
<pre><code>2020-09-03 23:47:24.656 tokio-runtime-worker INFO sc_consensus_manual_seal::rpc  Instant Seal success: CreatedBlock { hash: 0x02f2fd8e06bd8138040813f18c4b2df41404c289c3418142f613ae5c72abe6ce, aux: ImportedAux { header_only: false, clear_justification_requests: false, needs_justification: false, bad_justification: false, needs_finality_proof: false, is_new_best: true } }
2020-09-03 23:47:24.658  INFO ocw_demo  Entering off-chain worker
2020-09-03 23:47:24.866 tokio-runtime-worker INFO sc_basic_authorship::basic_authorship  üôå Starting consensus session on top of parent 0x02f2fd8e06bd8138040813f18c4b2df41404c289c3418142f613ae5c72abe6ce
2020-09-03 23:47:24.874 tokio-blocking-driver INFO ocw_demo  submit_number_signed: (0, d43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d (5GrwvaEF...))
2020-09-03 23:47:24.874 tokio-blocking-driver INFO ocw_demo  Number vector: [0]
...
</code></pre>
<p>Let's take a deeper look at what's happening here. Referring to the code at
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/ocw-demo/src/lib.rs"><code>pallets/ocw-demo/src/lib.rs</code></a>,
there is an <code>fn offchain_worker()</code> function inside <code>decl_module!</code>. This is the entry point of the
off-chain worker logic which is executed once per block import.</p>
<p>As off-chain workers, by definition, run computation off-chain, they cannot alter the block state
directly. In order to do so, they need to send transactions back on-chain. Three kinds of transaction
can be sent here, <strong>signed transactions</strong>, <strong>unsigned transactions</strong>, and <strong>unsigned transactions
with signed payload</strong>.</p>
<ul>
<li><a href="off-chain-workers/transactions.html#signed-transactions">Signed transactions</a> are used if the transaction requires the sender to be
specified.</li>
<li><a href="off-chain-workers/transactions.html#unsigned-transactions">Unsigned transactions</a> are used when the sender does not need to be known.</li>
<li><a href="off-chain-workers/transactions.html#unsigned-transactions-with-signed-payloads">Unsigned transactions with signed payloads</a> are used
if the transaction requires the sender to be specified but the sender account not be charged for the transaction fee.</li>
</ul>
<p>We will walk through each of them in the following.</p>
<h2><a class="header" href="#signed-transactions" id="signed-transactions">Signed Transactions</a></h2>
<blockquote>
<p><strong>Notes</strong>: This example will have account <code>Alice</code> submitting signed transactions to the node in
the off-chain worker, and these transactions have associated fees. If you run the node in development
mode (with <code>--dev</code> flag) using the default sr25519 crypto signature, <code>Alice</code> will have sufficient funds
initialized in the chain and this example will run fine. Otherwise, please be aware <code>Alice</code> account
must be funded to run this example.</p>
</blockquote>
<h3><a class="header" href="#setup" id="setup">Setup</a></h3>
<p>For signed transactions, we have to define a crypto signature sub-module:</p>
<p>src:
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/ocw-demo/src/lib.rs"><code>pallets/ocw-demo/src/lib.rs</code></a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub const KEY_TYPE: KeyTypeId = KeyTypeId(*b&quot;demo&quot;);

pub mod crypto {
	use crate::KEY_TYPE;
	use sp_runtime::app_crypto::{app_crypto, sr25519};
	// -- snip --
	app_crypto!(sr25519, KEY_TYPE);
}
<span class="boring">}
</span></code></pre></pre>
<p><code>KEY_TYPE</code> is the application key prefix for the pallet in the underlying storage. This is to be used
for signing transactions.</p>
<p>Second, we have our pallet configration trait be additionally bounded by <code>CreateSignedTransaction</code>
and add an additional associated type <code>AuthorityId</code>. This tell the runtime that this pallet can
create signed transactions.</p>
<p>src:
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/ocw-demo/src/lib.rs"><code>pallets/ocw-demo/src/lib.rs</code></a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Trait: system::Trait + CreateSignedTransaction&lt;Call&lt;Self&gt;&gt; {
	/// The identifier type for an offchain worker.
	type AuthorityId: AppCrypto&lt;Self::Public, Self::Signature&gt;;
	// -- snip --
}
<span class="boring">}
</span></code></pre></pre>
<p>Now if we <a href="off-chain-workers/transactions.html#compiling-this-pallet">build the <code>kitchen-node</code></a>, we will see compiler errors saying
three trait bounds are not satisfied: <code>Runtime: frame_system::offchain::CreateSignedTransaction</code>,
<code>frame_system::offchain::SigningTypes</code>, and <code>frame_system::offchain::SendTransactionTypes</code>. So let's
implement these traits in our runtime.</p>
<p>src:
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/runtimes/ocw-runtime/src/lib.rs"><code>runtimes/ocw-runtime/src/lib.rs</code></a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;LocalCall&gt; frame_system::offchain::CreateSignedTransaction&lt;LocalCall&gt; for Runtime
where
	Call: From&lt;LocalCall&gt;,
{
	fn create_transaction&lt;C: frame_system::offchain::AppCrypto&lt;Self::Public, Self::Signature&gt;&gt;(
		call: Call,
		public: &lt;Signature as sp_runtime::traits::Verify&gt;::Signer,
		account: AccountId,
		index: Index,
	) -&gt; Option&lt;(
		Call,
		&lt;UncheckedExtrinsic as sp_runtime::traits::Extrinsic&gt;::SignaturePayload,
	)&gt; {
		let period = BlockHashCount::get() as u64;
		let current_block = System::block_number()
			.saturated_into::&lt;u64&gt;()
			.saturating_sub(1);
		let tip = 0;
		let extra: SignedExtra = (
			frame_system::CheckTxVersion::&lt;Runtime&gt;::new(),
			frame_system::CheckGenesis::&lt;Runtime&gt;::new(),
			frame_system::CheckEra::&lt;Runtime&gt;::from(generic::Era::mortal(period, current_block)),
			frame_system::CheckNonce::&lt;Runtime&gt;::from(index),
			frame_system::CheckWeight::&lt;Runtime&gt;::new(),
			pallet_transaction_payment::ChargeTransactionPayment::&lt;Runtime&gt;::from(tip),
		);

		#[cfg_attr(not(feature = &quot;std&quot;), allow(unused_variables))]
		let raw_payload = SignedPayload::new(call, extra)
			.map_err(|e| {
				debug::native::warn!(&quot;SignedPayload error: {:?}&quot;, e);
			})
			.ok()?;

		let signature = raw_payload.using_encoded(|payload| C::sign(payload, public))?;

		let address = account;
		let (call, extra, _) = raw_payload.deconstruct();
		Some((call, (address, signature, extra)))
	}
}
<span class="boring">}
</span></code></pre></pre>
<p>The overall goal here is to perform the following:</p>
<ul>
<li>Signing the on-chain <code>call</code> and <code>extra</code> payload of the call. This together is called the signature.</li>
<li>Finally returning the on-chain <code>call</code>, the account/address making the signature, the signature
itself, and the <code>extra</code> payload.</li>
</ul>
<p>The <code>SignedExtra</code> data type used above is defined later in our runtime.</p>
<p>src:
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/runtimes/ocw-runtime/src/lib.rs"><code>runtimes/ocw-runtime/src/lib.rs</code></a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// The SignedExtension to the basic transaction logic.
pub type SignedExtra = (
	frame_system::CheckSpecVersion&lt;Runtime&gt;,
	frame_system::CheckTxVersion&lt;Runtime&gt;,
	frame_system::CheckGenesis&lt;Runtime&gt;,
	frame_system::CheckEra&lt;Runtime&gt;,
	frame_system::CheckNonce&lt;Runtime&gt;,
	frame_system::CheckWeight&lt;Runtime&gt;,
	pallet_transaction_payment::ChargeTransactionPayment&lt;Runtime&gt;,
);
<span class="boring">}
</span></code></pre></pre>
<p>Next the remaining two traits are also implemented by specifying the concrete types of their respective
trait associated types.</p>
<p>src:
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/runtimes/ocw-runtime/src/lib.rs"><code>runtimes/ocw-runtime/src/lib.rs</code></a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl frame_system::offchain::SigningTypes for Runtime {
	type Public = &lt;Signature as sp_runtime::traits::Verify&gt;::Signer;
	type Signature = Signature;
}

impl&lt;C&gt; frame_system::offchain::SendTransactionTypes&lt;C&gt; for Runtime
where
	Call: From&lt;C&gt;,
{
	type OverarchingCall = Call;
	type Extrinsic = UncheckedExtrinsic;
}
<span class="boring">}
</span></code></pre></pre>
<p>By now, we have completed the setup of implementing the necessary trait bounds for our runtime to
create signed transactions.</p>
<h3><a class="header" href="#sending-signed-transactions" id="sending-signed-transactions">Sending Signed Transactions</a></h3>
<p>A signed transaction is sent with <code>frame_system::offchain::SendSignedTransaction::send_signed_transaction</code>,
as shown below:</p>
<p>src:
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/ocw-demo/src/lib.rs"><code>pallets/ocw-demo/src/lib.rs</code></a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn offchain_signed_tx(block_number: T::BlockNumber) -&gt; Result&lt;(), Error&lt;T&gt;&gt; {
	// We retrieve a signer and check if it is valid.
	//   Since this pallet only has one key in the keystore. We use `any_account()1 to
	//   retrieve it. If there are multiple keys and we want to pinpoint it, `with_filter()` can be chained,
	//   ref: https://substrate.dev/rustdocs/v2.0.0-rc6/frame_system/offchain/struct.Signer.html
	let signer = Signer::&lt;T, T::AuthorityId&gt;::any_account();

	// Translating the current block number to number and submit it on-chain
	let number: u64 = block_number.try_into().unwrap_or(0) as u64;

	// `result` is in the type of `Option&lt;(Account&lt;T&gt;, Result&lt;(), ()&gt;)&gt;`. It is:
	//   - `None`: no account is available for sending transaction
	//   - `Some((account, Err(())))`: error occured when sending the transaction
	//   - `Some((account, Ok(())))`: transaction is successfully sent
	let result = signer.send_signed_transaction(|_acct|
		// This is the on-chain function
		Call::submit_number_signed(number)
	);

	// Display error if the signed tx fails.
	if let Some((acc, res)) = result {
		if res.is_err() {
			debug::error!(&quot;failure: offchain_signed_tx: tx sent: {:?}&quot;, acc.id);
			return Err(&lt;Error&lt;T&gt;&gt;::OffchainSignedTxError);
		}
		// Transaction is sent successfully
		return Ok(());
	}

	// The case of `None`: no account is available for sending
	debug::error!(&quot;No local account available&quot;);
	Err(&lt;Error&lt;T&gt;&gt;::NoLocalAcctForSignedTx)
}
<span class="boring">}
</span></code></pre></pre>
<p>On the above code, we first retrieve a signer. Then we send a signed transaction on-chain by calling
<code>send_signed_transaction</code> with a closure returning the on-chain call,
<code>Call::submit_number_signed(submission)</code>.</p>
<p>Then we use the signer to send signed transaction, and the result is in the type of
<code>Option&lt;(Account&lt;T&gt;, Result&lt;(), ()&gt;)&gt;</code>. So we handle each of the following cases:</p>
<ul>
<li><code>None</code>: when no account is available for sending transaction</li>
<li><code>Some((account, Err(())))</code>: when an error occured when sending the transaction</li>
<li><code>Some((account, Ok(())))</code>: when transaction is successfully sent</li>
</ul>
<p>Eventually, the <code>call</code> transaction is made on-chain via the
<code>frame_system::offchain::CreateSignedTransaction::create_transaction</code> function we defined in our
runtime.</p>
<h2><a class="header" href="#unsigned-transactions" id="unsigned-transactions">Unsigned Transactions</a></h2>
<h3><a class="header" href="#setup-1" id="setup-1">Setup</a></h3>
<p>By default unsigned transactions are rejected by the runtime unless they are explicitly
allowed. So we write the logic to allow unsigned transactions to be validated:</p>
<p>src:
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/ocw-demo/src/lib.rs"><code>pallets/ocw-demo/src/lib.rs</code></a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: Trait&gt; frame_support::unsigned::ValidateUnsigned for Module&lt;T&gt; {
	type Call = Call&lt;T&gt;;

	fn validate_unsigned(_source: TransactionSource, call: &amp;Self::Call) -&gt; TransactionValidity {
		let valid_tx = |provide| ValidTransaction::with_tag_prefix(&quot;ocw-demo&quot;)
			.priority(T::UnsignedPriority::get())
			.and_provides([&amp;provide])
			.longevity(3)
			.propagate(true)
			.build();

		match call {
			Call::submit_number_unsigned(_number) =&gt; valid_tx(b&quot;submit_number_unsigned&quot;.to_vec()),
			// -- snip --
			_ =&gt; InvalidTransaction::Call.into(),
		}
	}
}
<span class="boring">}
</span></code></pre></pre>
<p>We implement the <code>ValidateUnsigned</code> trait for <code>Module</code>, and add the allowance logic inside the
<code>validate_unsigned</code> function. We verify that if the call is <code>Call::submit_number_unsigned</code> we return
a <a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sp_runtime/transaction_validity/struct.ValidTransaction.html"><code>ValidTransaction</code></a> object using the <a href="https://github.com/rust-unofficial/patterns/blob/master/patterns/builder.md">builder pattern</a>.</p>
<p>The <code>ValidTransaction</code> object contain some fields we have not seen before:</p>
<ul>
<li><code>priority</code>: determine the ordering of two transactions, given their dependencies are satisfied.</li>
<li><code>requires</code>: contain a list of tags the transaction depends on.</li>
<li><code>provides</code>: contain a list of tags provided by this transaction. Successfully importing the
transaction will enable other transactions that depend on these tags be included. Both<code>provides</code>
and <code>requires</code> tags allow Substrate to build a dependency graph of transactions and import them in
the right order.</li>
<li><code>longevity</code>: this transaction longevity describes the minimum number of blocks the transaction
has to be valid for. After this period the transaction should be removed from the pool or revalidated.</li>
<li><code>propagate</code>: indicate if the transaction should be propagated to other peers. By setting to
<code>false</code> the transaction will still be considered for inclusion in blocks on
the current node but will never be sent to other peers.</li>
</ul>
<p>Finally, to tell the runtime that we have our own <code>ValidateUnsigned</code> logic, we need to pass
this as a parameter when constructing the runtime:</p>
<p>src:
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/runtimes/ocw-runtime/src/lib.rs"><code>runtimes/ocw-runtime/src/lib.rs</code></a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>construct_runtime!(
	pub enum Runtime where
		Block = Block,
		NodeBlock = opaque::Block,
		UncheckedExtrinsic = UncheckedExtrinsic
	{
		//...snip
		OcwDemo: ocw_demo::{Module, Call, Storage, Event&lt;T&gt;, ValidateUnsigned},
	}
);
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#sending-unsigned-transactions" id="sending-unsigned-transactions">Sending Unsigned Transactions</a></h3>
<p>We can now send an unsigned transaction from offchain worker with the
<code>T::SubmitUnsignedTransaction::submit_unsigned</code> function, as shown in the code.</p>
<p>src:
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/ocw-demo/src/lib.rs"><code>pallets/ocw-demo/src/lib.rs</code></a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn offchain_unsigned_tx(block_number: T::BlockNumber) -&gt; Result&lt;(), Error&lt;T&gt;&gt; {
	let number: u64 = block_number.try_into().unwrap_or(0) as u64;
	let call = Call::submit_number_unsigned(number);

	// `submit_unsigned_transaction` returns a type of `Result&lt;(), ()&gt;`
	//   ref: https://substrate.dev/rustdocs/v2.0.0-rc6/frame_system/offchain/struct.SubmitTransaction.html#method.submit_unsigned_transaction
	SubmitTransaction::&lt;T, Call&lt;T&gt;&gt;::submit_unsigned_transaction(call.into())
		.map_err(|_| {
			debug::error!(&quot;Failed in offchain_unsigned_tx&quot;);
			&lt;Error&lt;T&gt;&gt;::OffchainUnsignedTxError
		})
}
<span class="boring">}
</span></code></pre></pre>
<p>As in signed transactions, we prepare a function reference with its parameters and call
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/frame_system/offchain/struct.SubmitTransaction.html#method.submit_unsigned_transaction"><code>frame_system::offchain::SubmitTransaction::submit_unsigned_transaction</code></a>.</p>
<h2><a class="header" href="#unsigned-transactions-with-signed-payloads" id="unsigned-transactions-with-signed-payloads">Unsigned Transactions with Signed Payloads</a></h2>
<p>With this type of transaction, we need to first specify a signer, sign the transaction, and then send
it back on-chain as unsigned transaction. The main difference with signed transactions is that the signer
account will not be charged for the transaction fee. This is not the case for signed transaction normally.</p>
<p>But this could potentially be an attack vector, so extra precaution should be added as to what counted
as a valid (unsigned) transaction.</p>
<p>Since we are still sending unsigned transactions, we need to add extra code to validate them. <a href="off-chain-workers/transactions.html#setup-1">See above</a>.</p>
<h3><a class="header" href="#sending-unsigned-transactions-with-signed-payloads" id="sending-unsigned-transactions-with-signed-payloads">Sending Unsigned Transactions with Signed Payloads</a></h3>
<p>We send unsigned transactions with signed payloads as followed.</p>
<p>src:
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/ocw-demo/src/lib.rs"><code>pallets/ocw-demo/src/lib.rs</code></a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn offchain_unsigned_tx_signed_payload(block_number: T::BlockNumber) -&gt; Result&lt;(), Error&lt;T&gt;&gt; {
	// Retrieve the signer to sign the payload
	let signer = Signer::&lt;T, T::AuthorityId&gt;::any_account();

	let number: u64 = block_number.try_into().unwrap_or(0) as u64;

	// `send_unsigned_transaction` is returning a type of `Option&lt;(Account&lt;T&gt;, Result&lt;(), ()&gt;)&gt;`.
	//   Similar to `send_signed_transaction`, they account for:
	//   - `None`: no account is available for sending transaction
	//   - `Some((account, Ok(())))`: transaction is successfully sent
	//   - `Some((account, Err(())))`: error occured when sending the transaction
	if let Some((_, res)) = signer.send_unsigned_transaction(
		|acct| Payload { number, public: acct.public.clone() },
		Call::submit_number_unsigned_with_signed_payload
	) {
		return res.map_err(|_| {
			debug::error!(&quot;Failed in offchain_unsigned_tx_signed_payload&quot;);
			&lt;Error&lt;T&gt;&gt;::OffchainUnsignedTxSignedPayloadError
		});
	}

	// The case of `None`: no account is available for sending
	debug::error!(&quot;No local account available&quot;);
	Err(&lt;Error&lt;T&gt;&gt;::NoLocalAcctForSigning)
}
<span class="boring">}
</span></code></pre></pre>
<p>What is unique here is that
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/frame_system/offchain/trait.SendUnsignedTransaction.html#tymethod.send_unsigned_transaction"><code>send_unsigned_transaction</code> function</a> takes two functions. The first, expressed as a closure,
returns a <code>SignedPayload</code> object, and the second returns an on-chain call to be made.</p>
<p>We have defined our <code>SignedPayload</code> object earlier in the pallet.</p>
<p>src:
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/ocw-demo/src/lib.rs"><code>pallets/ocw-demo/src/lib.rs</code></a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Encode, Decode, Clone, PartialEq, Eq, RuntimeDebug)]
pub struct Payload&lt;Public&gt; {
	number: u64,
	public: Public
}

impl &lt;T: SigningTypes&gt; SignedPayload&lt;T&gt; for Payload&lt;T::Public&gt; {
	fn public(&amp;self) -&gt; T::Public {
		self.public.clone()
	}
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#conclusion" id="conclusion">Conclusion</a></h2>
<p>By now, you should be able to code your own off-chain workers that send signed transactions, unsigned
transactions, and unsigned transactions with signed payloads back on chain.</p>
<h1><a class="header" href="#http-fetching-and-json-parsing-in-off-chain-workers" id="http-fetching-and-json-parsing-in-off-chain-workers">HTTP Fetching and JSON Parsing in Off-chain Workers</a></h1>
<p><code>pallets/ocw-demo</code>
<a href="https://playground-staging.substrate.dev/?deploy=recipes&amp;files=%2Fhome%2Fsubstrate%2Fworkspace%2Fpallets%ocw-demo%2Fsrc%2Flib.rs">
<img src="https://img.shields.io/badge/Playground-Try%20it!-brightgreen?logo=Parity%20Substrate" alt="Try on playground" />
</a>
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/ocw-demo/src/lib.rs">
<img src="https://img.shields.io/badge/Github-View%20Code-brightgreen?logo=github" alt="View on GitHub" />
</a></p>
<h2><a class="header" href="#http-fetching" id="http-fetching">HTTP Fetching</a></h2>
<p>In traditional web apps, we use HTTP requests to communicate with and fetch data from third-party APIs.
But this is tricky when we want to perform this in Substrate runtime on chain. First, HTTP requests
are indeterministic. There are uncertainty in terms of how long the request will take, and the result
may not be the same all the time. This causes problem for the network reaching consensus.</p>
<p>So in Substrate runtime, we use off-chain workers to issue HTTP requests and fetching the results back.</p>
<p>In this chapter, we will dive into fetching information of the GitHub organization <code>substrate-developer-hub</code>
that hosts this recipe, specifically, the <code>login</code>, <code>blog</code>, and <code>public_repos</code> values out using GitHub
public API.</p>
<p>We issue an http request and return the JSON string in byte vector inside the <code>fetch_from_remote()</code>
function.</p>
<p>src:
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/ocw-demo/src/lib.rs"><code>pallets/ocw-demo/src/lib.rs</code></a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Initiate an external HTTP GET request. This is using high-level wrappers from `sp_runtime`.
let request = rt_offchain::http::Request::get(HTTP_REMOTE_REQUEST);

// Keeping the offchain worker execution time reasonable, so limiting the call to be within 3s.
let timeout = sp_io::offchain::timestamp()
	.add(rt_offchain::Duration::from_millis(FETCH_TIMEOUT_PERIOD));

// For github API request, we also need to specify `user-agent` in http request header.
//   See: https://developer.github.com/v3/#user-agent-required
let pending = request
	.add_header(&quot;User-Agent&quot;, HTTP_HEADER_USER_AGENT)
	.deadline(timeout) // Setting the timeout time
	.send() // Sending the request out by the host
	.map_err(|_| &lt;Error&lt;T&gt;&gt;::HttpFetchingError)?;

// By default, the http request is async from the runtime perspective. So we are asking the
//   runtime to wait here.
// The returning value here is a `Result` of `Result`, so we are unwrapping it twice by two `?`
//   ref: https://substrate.dev/rustdocs/v2.0.0-rc6/sp_runtime/offchain/http/struct.PendingRequest.html#method.try_wait
let response = pending
	.try_wait(timeout)
	.map_err(|_| &lt;Error&lt;T&gt;&gt;::HttpFetchingError)?
	.map_err(|_| &lt;Error&lt;T&gt;&gt;::HttpFetchingError)?;

if response.code != 200 {
	debug::error!(&quot;Unexpected http request status code: {}&quot;, response.code);
	return Err(&lt;Error&lt;T&gt;&gt;::HttpFetchingError);
}

// Next we fully read the response body and collect it to a vector of bytes.
Ok(response.body().collect::&lt;Vec&lt;u8&gt;&gt;())
<span class="boring">}
</span></code></pre></pre>
<p>We first create a request object. We also set a timeout period so the http request does not hold
indefinitely with <code>.deadline(timeout)</code>. For querying github APIs, we also need to add an extra HTTP
header with <code>add_header(...)</code>. HTTP requests from off-chain workers are fetched asynchronously. Here
we use <code>try_wait()</code> to wait for the result to come back, and terminate and return if any errors occured.</p>
<p>We then check the response status code to ensure it is okay (equals to 200). Any status code that is
non-200 is regarded as error and return. Finally, we get the response back from <code>response.body()</code>
iterator. Since we are in a <code>no_std</code> environment, we collect them back as a byte vector instead of a
string and return.</p>
<h2><a class="header" href="#json-parsing" id="json-parsing">JSON Parsing</a></h2>
<p>We frequently get JSON back when requesting from HTTP APIs. The next task is to parse the JSON
and fetch the required (key, value) pair out. This is demonstrated in the <code>fetch_n_parse</code>
function.</p>
<h3><a class="header" href="#setup-2" id="setup-2">Setup</a></h3>
<p>In Rust, <code>serde</code> and <code>serde-json</code> are the popular combo-package used for JSON parsing. Due to the
project setup of compiling Substrate with <code>serde</code> feature <code>std</code> on and cargo feature
unification limitation, we cannot simultaneously have <code>serde</code> feature <code>std</code> off (<code>no_std</code> on) when
compiling the runtime (this is a bit of a mouthful,
<a href="https://github.com/rust-lang/cargo/issues/4463">the details can be seen in this issue</a>). So we are
going to use a renamed <code>serde</code> crate, <code>alt_serde</code>, in our pallet to remedy this situation.</p>
<p>src:
<code>pallets/ocw-demo/Cargo.toml</code></p>
<pre><code class="language-toml">[package]
# ...

[dependencies]
# external dependencies
# ...

alt_serde = { version = &quot;1&quot;, default-features = false, features = [&quot;derive&quot;] }
serde_json = { version = &quot;1&quot;, default-features = false, git = &quot;https://github.com/Xanewok/json&quot;, branch = &quot;no-std&quot;, features = [&quot;alloc&quot;] }

# ...
</code></pre>
<p>We also use a modified version of <code>serde_json</code> with the latest <code>alloc</code> feature that depends on <code>alt_serde</code>.</p>
<h3><a class="header" href="#deserializing-json-string-to-struct" id="deserializing-json-string-to-struct">Deserializing JSON string to struct</a></h3>
<p>Then we use the usual <code>serde-derive</code> approach on deserializing. First we define the struct with
fields that we are interested to extract out.</p>
<p>src:
<code>pallets/ocw-demo/src/lib.rs</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// We use `alt_serde`, and Xanewok-modified `serde_json` so that we can compile the program
//   with serde(features `std`) and alt_serde(features `no_std`).
use alt_serde::{Deserialize, Deserializer};

// Specifying serde path as `alt_serde`
// ref: https://serde.rs/container-attrs.html#crate
#[serde(crate = &quot;alt_serde&quot;)]
#[derive(Deserialize, Encode, Decode, Default)]
struct GithubInfo {
	// Specify our own deserializing function to convert JSON string to vector of bytes
	#[serde(deserialize_with = &quot;de_string_to_bytes&quot;)]
	login: Vec&lt;u8&gt;,
	#[serde(deserialize_with = &quot;de_string_to_bytes&quot;)]
	blog: Vec&lt;u8&gt;,
	public_repos: u32,
}
<span class="boring">}
</span></code></pre></pre>
<p>By default, <code>serde</code> deserialize JSON string to the datatype <code>String</code>. We want to write our own
deserializer to convert it to vector of bytes.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn de_string_to_bytes&lt;'de, D&gt;(de: D) -&gt; Result&lt;Vec&lt;u8&gt;, D::Error&gt;
where D: Deserializer&lt;'de&gt; {
	let s: &amp;str = Deserialize::deserialize(de)?;
	Ok(s.as_bytes().to_vec())
}
<span class="boring">}
</span></code></pre></pre>
<p>Now the actual deserialization takes place in the <code>fetch_n_parse</code> function.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Fetch from remote and deserialize the JSON to a struct
fn fetch_n_parse() -&gt; Result&lt;GithubInfo, Error&lt;T&gt;&gt; {
	let resp_bytes = Self::fetch_from_remote()
		.map_err(|e| {
			debug::error!(&quot;fetch_from_remote error: {:?}&quot;, e);
			&lt;Error&lt;T&gt;&gt;::HttpFetchingError
		})?;

	let resp_str = str::from_utf8(&amp;resp_bytes)
		.map_err(|_| &lt;Error&lt;T&gt;&gt;::HttpFetchingError)?;

	// Deserializing JSON to struct, thanks to `serde` and `serde_derive`
	let gh_info: GithubInfo = serde_json::from_str(&amp;resp_str).unwrap();
	Ok(gh_info)
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#local-storage-in-off-chain-workers" id="local-storage-in-off-chain-workers">Local Storage in Off-chain Workers</a></h1>
<p><code>pallets/ocw-demo</code>
<a href="https://playground-staging.substrate.dev/?deploy=recipes&amp;files=%2Fhome%2Fsubstrate%2Fworkspace%2Fpallets%ocw-demo%2Fsrc%2Flib.rs">
<img src="https://img.shields.io/badge/Playground-Try%20it!-brightgreen?logo=Parity%20Substrate" alt="Try on playground" />
</a>
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/ocw-demo/src/lib.rs">
<img src="https://img.shields.io/badge/Github-View%20Code-brightgreen?logo=github" alt="View on GitHub" />
</a></p>
<p>Remember we mentioned that off-chain workers (or <strong>ocw</strong> for short) cannot write directly to the
blockchain state? This is why they have to submit transactions back on-chain. Fortunately, there is
also local storage that persist across runs in off-chain workers. Storage is only local to off-chain
workers and is not passed within the blockchain network.</p>
<p>Off-chain workers are asynchronously run at the end of block import. Since ocws are not limited by how
long they run, at any single instance there could be multiple ocws running, being initiated by previous
block imports. See diagram below.</p>
<p><img src="off-chain-workers/../img/multiple-ocws.png" alt="More than one off-chain workers at a single instance" /></p>
<p>The storage has a similar API as their on-chain counterpart with <code>get</code>, <code>set</code>, and <code>mutate</code>. <code>mutate</code> is
using a <a href="https://en.wikipedia.org/wiki/Compare-and-swap"><code>compare-and-set</code></a> pattern. It compares the
contents of a memory location with a given value and, only if they are the same, modifies the
contents of that memory location to a new given value. This is done as a single atomic operation.
The atomicity guarantees that the new value is calculated based on up-to-date information; if the
value had been updated by another thread in the meantime, the write would fail.</p>
<p>In this recipe, we will add a cache and lock over our previous
<a href="off-chain-workers/./http-json.html">http fetching example</a>. If the cached value existed, we will return using the
cached value. Otherwise we acquire the lock, fetch from github public API, and save it to the cahce.</p>
<h2><a class="header" href="#setup-3" id="setup-3">Setup</a></h2>
<p>In the <code>fetch_if_needed()</code> function, we first define a storage reference used by the off-chain
worker.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn fetch_github_info() -&gt; Result&lt;(), Error&lt;T&gt;&gt; {
	// Create a reference to Local Storage value.
	// Since the local storage is common for all offchain workers, it's a good practice
	// to prepend our entry with the pallet name.
	let s_info = StorageValueRef::persistent(b&quot;offchain-demo::gh-info&quot;);
	// ...
}
<span class="boring">}
</span></code></pre></pre>
<p>We pass in a key as our storage key. As storage keys are namespaced globally, a good practice
would be to prepend our pallet name in front of our storage key.</p>
<h2><a class="header" href="#access" id="access">Access</a></h2>
<p>Once we have the storage reference, we can access the storage via <code>get</code>, <code>set</code>, and <code>mutate</code>. Let's
demonstrate the <code>mutate</code> function as the usage of the remaining two functions are pretty
self-explanatory.</p>
<p>We first check if the github info has been fetched and cached.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn fetch_github_info() -&gt; Result&lt;(), Error&lt;T&gt;&gt; {
	// ...
	if let Some(Some(gh_info)) = s_info.get::&lt;GithubInfo&gt;() {
		// gh-info has already been fetched. Return early.
		debug::info!(&quot;cached gh-info: {:?}&quot;, gh_info);
		return Ok(());
	}
	// ...
}
<span class="boring">}
</span></code></pre></pre>
<p>We then define a lock and try to acquire it before fetching github info.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn fetch_if_needed() -&gt; Result&lt;(), Error&lt;T&gt;&gt; {
	//...
	// off-chain storage can be accessed by off-chain workers from multiple runs, so we want to lock
	//   it before doing heavy computations and write operations.
	// ref: https://substrate.dev/rustdocs/v2.0.0-rc3/sp_runtime/offchain/storage_lock/index.html
	//
	// There are four ways of defining a lock:
	//   1) `new` - lock with default time and block exipration
	//   2) `with_deadline` - lock with default block but custom time exipration
	//   3) `with_block_deadline` - lock with default time but custom block exipration
	//   4) `with_block_and_time_deadline` - lock with custom time and block exipration
	// Here we choose the most custom one for demonstration purpose.
	let mut lock = StorageLock::&lt;BlockAndTime&lt;Self&gt;&gt;::with_block_and_time_deadline(
		b&quot;offchain-demo::lock&quot;,
		LOCK_BLOCK_EXPIRATION,
		rt_offchain::Duration::from_millis(LOCK_TIMEOUT_EXPIRATION)
	);

	// We try to acquire the lock here. If failed, we know the fetching logic inside is being
	//   executed by previous run of ocw, so the function just returns.
	// ref: https://substrate.dev/rustdocs/v2.0.0-rc3/sp_runtime/offchain/storage_lock/struct.StorageLock.html#method.try_lock
	if let Ok(_guard) = lock.try_lock() {
		// fetching logic here ...
	}

	//...
}
<span class="boring">}
</span></code></pre></pre>
<p>We then perform the fetch after the lock is acquired</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn fetch_if_needed() -&gt; Result&lt;(), Error&lt;T&gt;&gt; {
	// ...
	if let Ok(_guard) = lock.try_lock() {
		match Self::fetch_n_parse() {
			Ok(gh_info) =&gt; { s_info.set(&amp;gh_info); }
			Err(err) =&gt; { return Err(err); }
		}
	}

	Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>Finally when the <code>_guard</code> variable goes out of scope, the lock is released.</p>
<h2><a class="header" href="#reference" id="reference">Reference</a></h2>
<ul>
<li><a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sp_runtime/offchain/storage/struct.StorageValueRef.html"><code>StorageValueRef</code> API doc</a></li>
<li><a href="https://github.com/paritytech/substrate/tree/master/frame/example-offchain-worker"><code>example-offchain-worker</code> pallet in Substrate repo</a></li>
</ul>
<h1><a class="header" href="#currency-types" id="currency-types">Currency Types</a></h1>
<p><code>pallets/lockable-currency</code>
<a href="https://playground-staging.substrate.dev/?deploy=recipes&amp;files=%2Fhome%2Fsubstrate%2Fworkspace%2Fpallets%2Flockable-currency%2Fsrc%2Flib.rs">
<img src="https://img.shields.io/badge/Playground-Try%20it!-brightgreen?logo=Parity%20Substrate" alt="Try on playground" />
</a>
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/lockable-currency/src/lib.rs">
<img src="https://img.shields.io/badge/Github-View%20Code-brightgreen?logo=github" alt="View on GitHub" />
</a></p>
<p><code>pallets/reservable-currency</code>
<a href="https://playground-staging.substrate.dev/?deploy=recipes&amp;files=%2Fhome%2Fsubstrate%2Fworkspace%2Fpallets%2Freservable-currency%2Fsrc%2Flib.rs">
<img src="https://img.shields.io/badge/Playground-Try%20it!-brightgreen?logo=Parity%20Substrate" alt="Try on playground" />
</a>
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/reservable-currency/src/lib.rs">
<img src="https://img.shields.io/badge/Github-View%20Code-brightgreen?logo=github" alt="View on GitHub" />
</a></p>
<p><code>pallets/currency-imbalances</code>
<a href="https://playground-staging.substrate.dev/?deploy=recipes&amp;files=%2Fhome%2Fsubstrate%2Fworkspace%2Fpallets%2Fcurrency-imbalances%2Fsrc%2Flib.rs">
<img src="https://img.shields.io/badge/Playground-Try%20it!-brightgreen?logo=Parity%20Substrate" alt="Try on playground" />
</a>
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/currency-imbalances/src/lib.rs">
<img src="https://img.shields.io/badge/Github-View%20Code-brightgreen?logo=github" alt="View on GitHub" />
</a></p>
<h2><a class="header" href="#just-plain-currency" id="just-plain-currency">Just Plain Currency</a></h2>
<p>To use a balance type in the runtime, import the
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/frame_support/traits/trait.Currency.html"><code>Currency</code></a> trait from
<code>frame_support</code>.</p>
<pre><code class="language-rust ignore">use support::traits::Currency;
</code></pre>
<p>The <code>Currency</code> trait provides an abstraction over a
<a href="https://en.wikipedia.org/wiki/Fungibility">fungible assets</a> system. To use such a fungible asset
from your pallet, include an associated type with the <code>Currency</code> trait bound in your pallet's
configuration trait.</p>
<pre><code class="language-rust ignore">pub trait Trait: system::Trait {
	type Currency: Currency&lt;Self::AccountId&gt;;
}
</code></pre>
<p>Defining an associated type with this trait bound allows this pallet to access the provided methods
of <a href="https://substrate.dev/rustdocs/v2.0.0-rc6/frame_support/traits/trait.Currency.html"><code>Currency</code></a>. For example, it
is straightforward to check the total issuance of the system:</p>
<pre><code class="language-rust ignore">// in decl_module block
T::Currency::total_issuance();
</code></pre>
<p>As promised, it is also possible to type alias a balances type for use in the runtime:</p>
<pre><code class="language-rust ignore">type BalanceOf&lt;T&gt; = &lt;&lt;T as Trait&gt;::Currency as Currency&lt;&lt;T as system::Trait&gt;::AccountId&gt;&gt;::Balance;
</code></pre>
<p>This new <code>BalanceOf&lt;T&gt;</code> type satisfies the type constraints of <code>Self::Balance</code> for the provided
methods of <code>Currency</code>. This means that this type can be used for
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/frame_support/traits/trait.Currency.html#tymethod.transfer">transfer</a>,
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/frame_support/traits/trait.Currency.html#tymethod.deposit_into_existing">minting</a>,
and much more.</p>
<h2><a class="header" href="#reservable-currency" id="reservable-currency">Reservable Currency</a></h2>
<p>Substrate's <a href="https://substrate.dev/rustdocs/v2.0.0-rc6/pallet_treasury/index.html">Treasury pallet</a> uses the
<code>Currency</code> type for bonding spending proposals. To reserve and unreserve funds for bonding,
<code>treasury</code> uses the
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/frame_support/traits/trait.ReservableCurrency.html"><code>ReservableCurrency</code></a>
trait. The import and associated type declaration follow convention</p>
<pre><code class="language-rust ignore">use frame_support::traits::{Currency, ReservableCurrency};

pub trait Trait: system::Trait {
	type Currency: Currency&lt;Self::AccountId&gt; + ReservableCurrency&lt;Self::AccountId&gt;;
}
</code></pre>
<p>To lock or unlock some quantity of funds, it is sufficient to invoke <code>reserve</code> and <code>unreserve</code>
respectively</p>
<pre><code class="language-rust ignore">pub fn reserve_funds(origin, amount: BalanceOf&lt;T&gt;) -&gt; DispatchResult {
	let locker = ensure_signed(origin)?;

	T::Currency::reserve(&amp;locker, amount)
			.map_err(|_| &quot;locker can't afford to lock the amount requested&quot;)?;

	let now = &lt;system::Module&lt;T&gt;&gt;::block_number();

	Self::deposit_event(RawEvent::LockFunds(locker, amount, now));
	Ok(())
}
</code></pre>
<pre><code class="language-rust ignore">pub fn unreserve_funds(origin, amount: BalanceOf&lt;T&gt;) -&gt; DispatchResult {
	let unlocker = ensure_signed(origin)?;

	T::Currency::unreserve(&amp;unlocker, amount);
	// ReservableCurrency::unreserve does not fail (it will lock up as much as amount)

	let now = &lt;system::Module&lt;T&gt;&gt;::block_number();

	Self::deposit_event(RawEvent::UnlockFunds(unlocker, amount, now));
	Ok(())
}
</code></pre>
<h2><a class="header" href="#lockable-currency" id="lockable-currency">Lockable Currency</a></h2>
<p>Substrate's <a href="https://substrate.dev/rustdocs/v2.0.0-rc6/pallet_staking/index.html">Staking pallet</a> similarly uses
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/frame_support/traits/trait.LockableCurrency.html"><code>LockableCurrency</code></a>
trait for more nuanced handling of capital locking based on time increments. This type can be very
useful in the context of economic systems that enforce accountability by collateralizing fungible
resources. Import this trait in the usual way</p>
<pre><code class="language-rust ignore">use frame_support::traits::{LockIdentifier, LockableCurrency}
</code></pre>
<p>To use <code>LockableCurrency</code>, it is necessary to define a
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/frame_support/traits/type.LockIdentifier.html"><code>LockIdentifier</code></a>.</p>
<pre><code class="language-rust ignore">const EXAMPLE_ID: LockIdentifier = *b&quot;example &quot;;
</code></pre>
<p>By using this <code>EXAMPLE_ID</code>, it is straightforward to define logic within the runtime to schedule
locking, unlocking, and extending existing locks.</p>
<pre><code class="language-rust ignore">fn lock_capital(origin, amount: BalanceOf&lt;T&gt;) -&gt; DispatchResult {
	let user = ensure_signed(origin)?;

	T::Currency::set_lock(
		EXAMPLE_ID,
		&amp;user,
		amount,
		WithdrawReasons::except(WithdrawReason::TransactionPayment),
	);

	Self::deposit_event(RawEvent::Locked(user, amount));
	Ok(())
}
</code></pre>
<h2><a class="header" href="#imbalances-1" id="imbalances-1">Imbalances</a></h2>
<p>Functions that alter balances return an object of the
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/frame_support/traits/trait.Imbalance.html"><code>Imbalance</code></a> type to express
how much account balances have been altered in aggregate. This is useful in the context of state
transitions that adjust the total supply of the <code>Currency</code> type in question.</p>
<p>To manage this supply adjustment, the
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/frame_support/traits/trait.OnUnbalanced.html"><code>OnUnbalanced</code></a> handler is
often used. An example might look something like</p>
<pre><code class="language-rust ignore">pub fn reward_funds(origin, to_reward: T::AccountId, reward: BalanceOf&lt;T&gt;) {
	let _ = ensure_signed(origin)?;

	let mut total_imbalance = &lt;PositiveImbalanceOf&lt;T&gt;&gt;::zero();

	let r = T::Currency::deposit_into_existing(&amp;to_reward, reward).ok();
	total_imbalance.maybe_subsume(r);
	T::Reward::on_unbalanced(total_imbalance);

	let now = &lt;system::Module&lt;T&gt;&gt;::block_number();
	Self::deposit_event(RawEvent::RewardFunds(to_reward, reward, now));
}
</code></pre>
<h2><a class="header" href="#takeaway" id="takeaway">takeaway</a></h2>
<p>The way we represent value in the runtime dictates both the security and flexibility of the
underlying transactional system. Likewise, it is convenient to be able to take advantage of Rust's
<a href="https://blog.rust-lang.org/2015/05/11/traits.html">flexible trait system</a> when building systems
intended to rethink how we exchange information and value üöÄ</p>
<h1><a class="header" href="#currency-imbalances" id="currency-imbalances">Currency Imbalances</a></h1>
<p><code>pallets/currency-imbalances</code>
<a href="https://playground-staging.substrate.dev/?deploy=recipes&amp;files=%2Fhome%2Fsubstrate%2Fworkspace%2Fpallets%2Fcurrency-imbalances%2Fsrc%2Flib.rs"> <img src="https://img.shields.io/badge/Playground-Try%20it!-brightgreen?logo=Parity%20Substrate" alt="Try on playground" /> </a>
<a href="https://github.com/substrate-developer-hub/recipes/blob/master/pallets/currency-imbalances/src/lib.rs"> <img src="https://img.shields.io/badge/Github-View%20Code-brightgreen?logo=github" alt="View on GitHub" /> </a></p>
<p><a href="https://substrate.dev/rustdocs/v2.0.0-rc6/frame_support/traits/trait.Imbalance.html"><code>Imbalance</code></a>
is used when tokens are burned or minted. In order to execute <code>imbalance</code> implement the
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/frame_support/traits/trait.OnUnbalanced.html"><code>OnUnbalanced</code></a>trait.
In this pallet a specific amount of funds will be slashed from an account and award a specific
amount of funds to said specific account.</p>
<h2><a class="header" href="#slash-funds" id="slash-funds">Slash funds</a></h2>
<pre><code class="language-rust ignore">pub fn slash_funds(origin, to_punish: T::AccountId, collateral: BalanceOf&lt;T&gt;) {
    let _ = ensure_signed(origin)?;

    let imbalance = T::Currency::slash_reserved(&amp;to_punish, collateral).0;
    T::Slash::on_unbalanced(imbalance);

    let now = &lt;system::Module&lt;T&gt;&gt;::block_number();
    Self::deposit_event(RawEvent::SlashFunds(to_punish, collateral, now));
}
</code></pre>
<h2><a class="header" href="#reward-funds" id="reward-funds">Reward funds</a></h2>
<pre><code class="language-rust ignore">pub fn reward_funds(origin, to_reward: T::AccountId, reward: BalanceOf&lt;T&gt;) {

    let _ = ensure_signed(origin)?;

    let mut total_imbalance = &lt;PositiveImbalanceOf&lt;T&gt;&gt;::zero();

    let r = T::Currency::deposit_into_existing(&amp;to_reward, reward).ok();
    total_imbalance.maybe_subsume(r);
    T::Reward::on_unbalanced(total_imbalance);

    let now = &lt;system::Module&lt;T&gt;&gt;::block_number();
    Self::deposit_event(RawEvent::RewardFunds(to_reward, reward, now));
}
</code></pre>
<h1><a class="header" href="#generating-randomness" id="generating-randomness">Generating Randomness</a></h1>
<p><code>pallets/randomness</code>
<a href="https://playground-staging.substrate.dev/?deploy=recipes&amp;files=%2Fhome%2Fsubstrate%2Fworkspace%2Fpallets%2Frandomness%2Fsrc%2Flib.rs">
<img src="https://img.shields.io/badge/Playground-Try%20it!-brightgreen?logo=Parity%20Substrate" alt="Try on playground" />
</a>
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/randomness/src/lib.rs">
<img src="https://img.shields.io/badge/Github-View%20Code-brightgreen?logo=github" alt="View on GitHub" />
</a></p>
<p>Randomness is useful in computer programs for everything from gambling, to generating DNA for
digital kitties, to selecting block authors. Randomness is hard to come by in deterministic
computers as explained at <a href="https://www.random.org/randomness/">random.org</a>. This is particularly
true in the context of a blockchain when all the nodes in the network must agree on the state of the
chain. Some techniques have been developed to address this problem including
<a href="https://github.com/randao/randao">RanDAO</a> and
<a href="https://en.wikipedia.org/wiki/Verifiable_random_function">Verifiable Random Functions</a>. Substrate
abstracts the implementation of a randomness source using the
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/frame_support/traits/trait.Randomness.html"><code>Randomness</code> trait</a>, and
provides a few implementations. This recipe will demonstrate using the <code>Randomness</code> trait and two
concrete implementations.</p>
<h2><a class="header" href="#disclaimer" id="disclaimer">Disclaimer</a></h2>
<p>All of the randomness sources described here have limitations on their usefulness and security. This
recipe shows how to use these randomness sources and makes an effort to explain their trade-offs.
However, the author of this recipe is a blockchain chef, <strong>not a trained cryptographer</strong>. It is your
responsibility to understand the security implications of using any of the techniques described in
this recipe, before putting them to use. When in doubt, consult a trustworthy cryptographer.</p>
<p>The resources linked at the end of this recipe may be helpful in assessing the security and
limitations of these randomness sources.</p>
<h2><a class="header" href="#randomness-trait" id="randomness-trait">Randomness Trait</a></h2>
<p>The randomness trait provides two methods, <code>random_seed</code>, and <code>random</code>, both of which provide a
pesudo-random value of the type specified in the traits type parameter.</p>
<h3><a class="header" href="#random_seed" id="random_seed"><code>random_seed</code></a></h3>
<p>The <code>random_seed</code> method takes no parameters and returns a random seed which changes once per block.
If you call this method twice in the same block you will get the same result. This method is
typically not as useful as its counterpart.</p>
<h3><a class="header" href="#random" id="random"><code>random</code></a></h3>
<p>The <code>random</code> method takes a byte array, <code>&amp;[u8]</code>, known as the subject, and uses the subject's bytes
along with the random seed described in the previous section to calculate a final random value.
Using a subject in this way allows pallet (or multiple pallets) to seek randomness in the same block
and get different results. The subject does not add entropy or security to the generation process,
it merely prevents each call from returning identical values.</p>
<p>Common values to use for a subject include:</p>
<ul>
<li>The block number</li>
<li>The caller's accountId</li>
<li>A Nonce</li>
<li>A pallet-specific identifier</li>
<li>A tuple containing several of the above</li>
</ul>
<p>To bring a randomness source into scope, we include it in our configuration trait with the
appropriate trait bound. This pallet, being a demo, will use two different sources. Using multiple
sources is not necessary in practice.</p>
<pre><code class="language-rust ignore">pub trait Trait: system::Trait {
	type Event: From&lt;Event&gt; + Into&lt;&lt;Self as system::Trait&gt;::Event&gt;;

	type RandomnessSource: Randomness&lt;H256&gt;;
}
</code></pre>
<p>We've provided the <code>Output</code> type as <a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sp_core/struct.H256.html"><code>H256</code></a>.</p>
<h2><a class="header" href="#consuming-randomness" id="consuming-randomness">Consuming Randomness</a></h2>
<p>Calling the randomness source from Rust code is straightforward. Our <code>consume_randomness</code> extrinsic
demonstrates consuming the raw random seed as well as a context-augmented random value. Try submitting the same extrinsic twice in the same block. The raw seed should be the same each time.</p>
<pre><code class="language-rust ignore">fn consume_randomness(origin) -&gt; DispatchResult {
	let _ = ensure_signed(origin)?;

	// Using a subject is recommended to prevent accidental re-use of the seed
	// (This does not add security or entropy)
	let subject = Self::encode_and_update_nonce();

	let random_seed = T::RandomnessSource::random_seed();
	let random_result = T::RandomnessSource::random(&amp;subject);

	Self::deposit_event(Event::RandomnessConsumed(random_seed, random_result));
	Ok(())
}
}
</code></pre>
<h2><a class="header" href="#collective-coin-flipping" id="collective-coin-flipping">Collective Coin Flipping</a></h2>
<p>Substrate's
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/pallet_randomness_collective_flip/index.html">Randomness Collective Flip pallet</a>
uses a safe mixing algorithm to generate randomness using the entropy of previous block hashes.
Because it is dependent on previous blocks, it can take many blocks for the seed to change.</p>
<p>A naive randomness source based on block hashes would take the hash of the previous block and use it
as a random seed. Such a technique has the significant disadvantage that the block author can
preview the random seed, and choose to discard the block choosing a slightly modified block with a
more desirable hash. This pallet is subject to similar manipulation by the previous 81 block authors
rather than just the previous 1.</p>
<p>Although it may <em>seem</em> harmless, <strong>you should not hash the result</strong> of the randomness provided by
the collective flip pallet. Secure hash functions satisfy the
<a href="https://en.wikipedia.org/wiki/Avalanche_effect">Avalance effect</a> which means that each bit of input
is equally likely to affect a given bit of the output. Hashing will negate the low-influence
property provided by the pallet.</p>
<h2><a class="header" href="#babe-vrf-output" id="babe-vrf-output">Babe VRF Output</a></h2>
<p>Substrate's <a href="https://substrate.dev/rustdocs/v2.0.0-rc6/pallet_babe/index.html">Babe pallet</a> which is primarily
responsible for managing validator rotation in Babe consensus, also collects the VRF outputs that
Babe validators publish to demonstrate that they are permitted to author a block. These VRF outputs
can be used to provide a random seed.</p>
<p>Because we are accessing the randomness via the <code>Randomness</code> trait, the calls look the same as
before.</p>
<pre><code class="language-rust ignore">let random_seed = T::BabeRandomnessSource::random_seed();
let random_result = T::BabeRandomnessSource::random(&amp;subject);
</code></pre>
<p>In production networks, Babe VRF output is preferable to Collective Flip. Collective Flip provides
essentially no real security.</p>
<h2><a class="header" href="#down-the-rabbit-hole" id="down-the-rabbit-hole">Down the Rabbit Hole</a></h2>
<p>As mentioned previously, there are many tradeoffs and security concerns to be aware of when using
these randomness sources. If you'd like to get into the research, here are some jumping off points.</p>
<ul>
<li><a href="https://github.com/paritytech/ink/issues/57">https://github.com/paritytech/ink/issues/57</a></li>
<li><a href="https://wiki.polkadot.network/docs/en/learn-randomness">https://wiki.polkadot.network/docs/en/learn-randomness</a></li>
</ul>
<!-- markdown-link-check-disable-next-line -->
<ul>
<li><a href="http://www.cse.huji.ac.il/%7Enati/PAPERS/coll_coin_fl.pdf">http://www.cse.huji.ac.il/~nati/PAPERS/coll_coin_fl.pdf</a></li>
<li><a href="https://eccc.weizmann.ac.il/report/2018/140/">https://eccc.weizmann.ac.il/report/2018/140/</a></li>
</ul>
<h1><a class="header" href="#tightly--and-loosely-coupled-pallets" id="tightly--and-loosely-coupled-pallets">Tightly- and Loosely-Coupled Pallets</a></h1>
<p><code>pallets/check-membership</code>
<a href="https://playground-staging.substrate.dev/?deploy=recipes&amp;files=%2Fhome%2Fsubstrate%2Fworkspace%2Fpallets%2Fcheck-membership%2Fsrc%2Flib.rs">
<img src="https://img.shields.io/badge/Playground-Try%20it!-brightgreen?logo=Parity%20Substrate" alt="Try on playground" />
</a>
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/check-membership/src/lib.rs">
<img src="https://img.shields.io/badge/Github-View%20Code-brightgreen?logo=github" alt="View on GitHub" />
</a></p>
<p>The <code>check-membership</code> crate contains two pallets that solve the same problems in slightly different
ways. Both pallets implement a single dispatchable function that can only be successfully executed
by callers who are members of an
<a href="https://en.wikipedia.org/wiki/Access-control_list">access control list</a>. The job of maintaining the
access control list is abstracted away to another pallet. This pallet and the membership-managing
pallet can be coupled in two different ways which are demonstrated by the tight and loose variants
of the pallet.</p>
<h2><a class="header" href="#twin-pallets" id="twin-pallets">Twin Pallets</a></h2>
<p>Before we dive into the pallet code, let's talk a bit more about the structure of the crate in the
<code>pallets/check-membership</code> directory. This directory is a single Rust crate that contains two
pallets. The two pallets live in the <code>pallets/check-membership/tight</code> and
<code>pallets/check-membership/loose</code> directories. In the crate's main <code>lib.rs</code> we simply export each of
these variants of the pallet.</p>
<pre><code class="language-rust ignore">pub mod loose;
pub mod tight;
</code></pre>
<p>This allows us to demonstrate both techniques while keeping the closely related work in a single
crate.</p>
<h2><a class="header" href="#controlling-access" id="controlling-access">Controlling Access</a></h2>
<p>While the primary learning objective of these twin pallets is understanding the way in which they
are coupled to the membership-managing pallets, they also demonstrate the concept of an access
control list, which we will investigate first.</p>
<p>It is often useful to designate some functions as permissioned and, therefore, accessible only to a
defined group of users. In this pallet, we check that the caller of the <code>check_membership</code> function
corresponds to a member of the permissioned set.</p>
<p>The loosely coupled variant looks like this.</p>
<pre><code class="language-rust ignore">/// Checks whether the caller is a member of the set of Account Ids provided by the
/// MembershipSource type. Emits an event if they are, and errors if not.
fn check_membership(origin) -&gt; DispatchResult {
	let caller = ensure_signed(origin)?;

	// Get the members from the vec-set pallet
	let members = T::MembershipSource::accounts();

	// Check whether the caller is a member
	ensure!(members.contains(&amp;caller), Error::&lt;T&gt;::NotAMember);

	// If the previous call didn't error, then the caller is a member, so emit the event
	Self::deposit_event(RawEvent::IsAMember(caller));
	Ok(())
}
</code></pre>
<h2><a class="header" href="#coupling-pallets" id="coupling-pallets">Coupling Pallets</a></h2>
<p>Each <code>check-membership</code> pallet actually contains very little logic. It has no storage of its own and
a single extrinsic that does the membership checking. All of the heavy lifting is abstracted away to
another pallet. There are two different ways that pallets can be coupled to one another and this
section investigates both.</p>
<h3><a class="header" href="#tight-coupling" id="tight-coupling">Tight Coupling</a></h3>
<p>Tightly coupling pallets is more explicit than loosely coupling them. When you are writing a pallet
that you want to tightly couple with some other pallet as a dependency, you explicitly specify the
name of the pallet on which you depend as a trait bound on the configuration trait of the pallet you
are writing. This is demonstrated in the tightly coupled variant of <code>check-membership</code>.</p>
<pre><code class="language-rust ignore">pub trait Trait: system::Trait + vec_set::Trait {
	// --snip--
}
</code></pre>
<blockquote>
<p>This pallet, and all pallets, are tightly coupled to <code>frame_system</code>.</p>
</blockquote>
<p>Supplying this trait bound means that the tightly coupled variant of <code>check-membership</code> pallet can
only be installed in a runtime that also has the <a href="./vec-set.html"><code>vec-set</code> pallet</a>
installed. We also see the tight coupling in the pallet's <code>Cargo.toml</code> file, where <code>vec-set</code> is
listed by name.</p>
<pre><code class="language-toml">vec-set = { path = '../vec-set', default-features = false }
</code></pre>
<p>To actually get the set of members, we have access to the getter function declared in <code>vec-set</code>.</p>
<pre><code class="language-rust ignore">// Get the members from the vec-set pallet
let members = vec_set::Module::&lt;T&gt;::members();
</code></pre>
<p>While tightly coupling pallets is conceptually simple, it has the disadvantage that it depends on a
specific implementation rather than an abstract interface. This makes the code more difficult to
maintain over time and is generally frowned upon. The tightly coupled version of <code>check-membership</code>
depends on exactly the <code>vec-set</code> pallet rather than a behavior such as managing a set of accounts.</p>
<h2><a class="header" href="#loose-coupling" id="loose-coupling">Loose Coupling</a></h2>
<p>Loose coupling solves the problem of coupling to a specific implementation. When loosely coupling to
another pallet, you add an associated type to the pallet's configuration trait and ensure the
supplied type implements the necessary behavior by specifying a trait bound.</p>
<pre><code class="language-rust ignore">pub trait Trait: system::Trait {
	// --snip--

	/// A type that will supply a set of members to check access control against
	type MembershipSource: AccountSet&lt;AccountId = Self::AccountId&gt;;
}
</code></pre>
<blockquote>
<p>Many pallets throughout the ecosystem are coupled to a token through the
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/frame_support/traits/trait.Currency.html"><code>Currency</code> trait</a>.</p>
</blockquote>
<p>Having this associated type means that the loosely coupled variant of the <code>check-membership</code> pallet
can be installed in any runtime that can supply it with a set of accounts to use as an access
control list. The code for the <code>AccountSet</code> trait lives in <code>traits/account-set/src/lib.rs</code> directory
and is quite short.</p>
<pre><code class="language-rust ignore">pub trait AccountSet {
	type AccountId;

	fn accounts() -&gt; BTreeSet&lt;Self::AccountId&gt;;
}
</code></pre>
<p>We also see the loose coupling in the pallet's <code>Cargo.toml</code> file, where <code>account-set</code> is listed.</p>
<pre><code class="language-toml">account-set = { path = '../../traits/account-set', default-features = false }
</code></pre>
<p>To actually get the set of members, we use the <code>accounts</code> method supplied by the trait.</p>
<pre><code class="language-rust ignore">// Get the members from the vec-set pallet
let members = T::MembershipSource::accounts();
</code></pre>
<h1><a class="header" href="#runtimes" id="runtimes">Runtimes</a></h1>
<p>A runtime represents the onchain application logic of a blockchain. They are typically written by composing FRAME pallets, but they can also be written directly. Learn about them in this section of the cookbook.</p>
<h1><a class="header" href="#runtime-apis" id="runtime-apis">Runtime APIs</a></h1>
<p><code>pallets/sum-storage</code>
<a href="https://playground-staging.substrate.dev/?deploy=recipes&amp;files=%2Fhome%2Fsubstrate%2Fworkspace%2Fpallets%2Fsum-storage%2Fsrc%2Flib.rs">
<img src="https://img.shields.io/badge/Playground-Try%20it!-brightgreen?logo=Parity%20Substrate" alt="Try on playground" />
</a>
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/pallets/sum-storage/src/lib.rs">
<img src="https://img.shields.io/badge/Github-View%20Code-brightgreen?logo=github" alt="View on GitHub" />
</a></p>
<p><code>runtimes/api-runtime</code>
<a href="https://playground-staging.substrate.dev/?deploy=recipes&amp;files=%2Fhome%2Fsubstrate%2Fworkspace%2Fruntimes%2Fapi-runtime%2Fsrc%2Flib.rs">
<img src="https://img.shields.io/badge/Playground-Try%20it!-brightgreen?logo=Parity%20Substrate" alt="Try on playground" />
</a>
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/runtimes/api-runtime/src/lib.rs">
<img src="https://img.shields.io/badge/Github-View%20Code-brightgreen?logo=github" alt="View on GitHub" />
</a></p>
<p>Each Substrate node contains a runtime. The runtime contains the business logic of the chain. It
defines what transactions are valid and invalid and determines how the chain's state changes in
response to transactions. The runtime is compiled to Wasm to facilitate runtime upgrades. The &quot;outer
node&quot;, everything other than the runtime, does not compile to Wasm, only to native. The outer node
is responsible for handling peer discovery, transaction pooling, block and transaction gossiping,
consensus, and answering RPC calls from the outside world. While performing these tasks, the outer
node sometimes needs to query the runtime for information, or provide information to the runtime. A
Runtime API facilitates this kind of communication between the outer node and the runtime. In this
recipe, we will write our own minimal runtime API.</p>
<h2><a class="header" href="#our-example" id="our-example">Our Example</a></h2>
<p>For this example, we will write a pallet called <code>sum-storage</code> with two storage items, both <code>u32</code>s.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>decl_storage! {
	trait Store for Module&lt;T: Trait&gt; as TemplateModule {
		Thing1 get(fn thing1): Option&lt;u32&gt;;
		Thing2 get(fn thing2): Option&lt;u32&gt;;
	}
}
<span class="boring">}
</span></code></pre></pre>
<p>Substrate already comes with a runtime API for querying storage values, which is why we can easily
query our two storage values from a front-end. In this example we imagine that the outer node is
interested in knowing the <em>sum</em> of the two values, rather than either individual value. Our runtime
API will provide a way for the outer node to query the runtime for this sum. Before we define the
actual runtime API, let's write a public helper function in the pallet to do the summing.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: Trait&gt; Module&lt;T&gt; {
	pub fn get_sum() -&gt; u32 {
		Thing1::get() + Thing2::get()
	}
}
<span class="boring">}
</span></code></pre></pre>
<p>So far, nothing we've done is specific to runtime APIs. In the coming sections, we will use this
helper function in our runtime API's implementation.</p>
<h2><a class="header" href="#defining-the-api" id="defining-the-api">Defining the API</a></h2>
<p>The first step in adding a runtime API to your runtime is defining its interface using a Rust trait.
This is done in the <code>sum-storage/runtime-api/src/lib.rs</code> file. This file can live anywhere you like,
but because it defines an API that is closely related to a particular pallet, it makes sense to
include the API definition in the pallet's directory.</p>
<p>The code to define the API is quite simple, and looks almost like any old Rust trait. The one
addition is that it must be placed in the
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sp_api/macro.decl_runtime_apis.html"><code>decl_runtime_apis!</code> macro</a>. This
macro allows the outer node to query the runtime API at specific blocks. Although this runtime API
only provides a single function, you may write as many as you like.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>sp_api::decl_runtime_apis! {
	pub trait SumStorageApi {
		fn get_sum() -&gt; u32;
	}
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#implementing-the-api" id="implementing-the-api">Implementing the API</a></h2>
<p>With our pallet written and our runtime API defined, we may now implement the API for our runtime.
This happens in the main runtime aggregation file. In our case we've provided the <code>api-runtime</code> in
<code>runtimes/api-runtime/src/lib.rs</code>.</p>
<p>As with defining the API, implementing a runtime API looks similar to implementing any old Rust
trait with the exception that the implementation must go inside of the
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sp_api/macro.impl_runtime_apis.html"><code>impl_runtime_apis!</code> macro</a>. Every
runtime must use <code>iml_runtime_apis!</code> because the
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sp_api/trait.Core.html"><code>Core</code> API</a> is required. We will add an
implementation for our own API alongside the others in this macro. Our implementation is
straight-forward as it merely calls the pallet's helper function that we wrote previously.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl_runtime_apis! {
  // --snip--

  impl sum_storage_rpc_runtime_api::SumStorageApi&lt;Block&gt; for Runtime {
		fn get_sum() -&gt; u32 {
			SumStorage::get_sum()
		}
	}
}
<span class="boring">}
</span></code></pre></pre>
<p>You may be wondering about the <code>Block</code> type parameter which is present here, but not in our
definition. This type parameter is added by the macros along with a few other features. All runtime
APIs have this type parameter to facilitate querying the runtime at arbitrary blocks. Read more
about this in the docs for
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sp_api/macro.impl_runtime_apis.html"><code>impl_runtime_apis!</code></a>.</p>
<h2><a class="header" href="#calling-the-runtime-api" id="calling-the-runtime-api">Calling the Runtime API</a></h2>
<p>We've now successfully added a runtime API to our runtime. The outer node can now call this API to
query the runtime for the sum of two storage values. Given a reference to a
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sc_service/client/struct.Client.html">'client'</a> we can make the call like
this.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sum_at_block_fifty = client.runtime_api().get_sum(&amp;50);
<span class="boring">}
</span></code></pre></pre>
<p>This recipe was about defining and implementing a custom runtime API. To see an example of calling
this API in practice, see the recipe on <a href="./custom-rpc.html">custom RPCs</a>, where we connect this
runtime API to an RPC that can be called by an end user.</p>
<h1><a class="header" href="#transaction-fees" id="transaction-fees">Transaction Fees</a></h1>
<p><code>runtimes/weight-fee-runtime</code>
<a href="https://playground-staging.substrate.dev/?deploy=recipes&amp;files=%2Fhome%2Fsubstrate%2Fworkspace%2Fruntimes%2Fweight-fee-runtime%2Fsrc%2Flib.rs">
<img src="https://img.shields.io/badge/Playground-Try%20it!-brightgreen?logo=Parity%20Substrate" alt="Try on playground" />
</a>
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/runtimes/weight-fee-runtime/src/lib.rs">
<img src="https://img.shields.io/badge/Github-View%20Code-brightgreen?logo=github" alt="View on GitHub" />
</a></p>
<p>Substrate provides the
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/pallet_transaction_payment/index.html"><code>transaction_payment</code> pallet</a> for
calculating and collecting fees for executing transactions. Fees are broken down into two
components:</p>
<ul>
<li>Byte fee - A fee proportional to the transaction's length in bytes. The proportionality constant
is a parameter in the <code>transaction_payment</code> pallet.</li>
<li>Weight fee - A fee calculated from the transaction's weight. Weights quantify the time spent
executing the transaction. Learn more in the <a href="./weights.html">recipe on weights</a>. The conversion
doesn't need to be linear, although it often is. The same conversion function is applied across
all transactions from all pallets in the runtime.</li>
<li>Fee Multiplier - A multiplier for the computed fee, that can change as the chain progresses.
This topic is not (yet) covered further in the recipes.</li>
</ul>
<pre><code>total_fee = transaction_length * length_fee + weight_to_fee(total_weight)
</code></pre>
<h2><a class="header" href="#setting-the-parameters" id="setting-the-parameters">Setting the Parameters</a></h2>
<p>Each of the parameters described above is set in the
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/pallet_transaction_payment/index.html">transaction payment pallet</a>'s
configuration trait. For example, the <code>super-runtime</code> sets these parameters as follows.</p>
<p>src:
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/runtimes/super-runtime/src/lib.rs"><code>runtimes/super-runtime/src/lib.rs</code></a></p>
<pre><code class="language-rust ignore">parameter_types! {
	pub const TransactionByteFee: u128 = 1;
}

impl transaction_payment::Trait for Runtime {
	type Currency = balances::Module&lt;Runtime&gt;;
	type OnTransactionPayment = ();
	type TransactionByteFee = TransactionByteFee;
	type WeightToFee = IdentityFee&lt;Balance&gt;;
	type FeeMultiplierUpdate = ();
}
</code></pre>
<h2><a class="header" href="#1-to-1-conversion" id="1-to-1-conversion">1 to 1 Conversion</a></h2>
<p>In many cases converting weight to fees one-to-one, as shown above, will suffice and can be
accomplished with
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/frame_support/weights/struct.IdentityFee.html"><code>IdentityFee</code></a>. This
approach is also taken in the
<a href="https://github.com/paritytech/substrate/blob/2d39ec2c4aaec1cc0f91fcb91734de8f408dc1b2/bin/node-template/runtime/src/lib.rs#L246">node template</a>.
It is also possible to provide a type that makes a more complex calculation. Any type that
implements
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/frame_support/weights/trait.WeightToFeePolynomial.html"><code>WeightToFeePolynomial</code></a>
will suffice.</p>
<h2><a class="header" href="#linear-conversion" id="linear-conversion">Linear Conversion</a></h2>
<p>Another common way to convert weight to fees is linearly. When converting linearly, the weight is
multiplied by a constant coefficient to determine the fee to charge. This is demonstrated in the
<code>weight-fee-runtime</code> with the <code>LinearWeightToFee</code> struct.</p>
<p>We declare the struct with an associated type <code>C</code>, which will provide the coefficient.</p>
<pre><code class="language-rust ignore">pub struct LinearWeightToFee&lt;C&gt;(sp_std::marker::PhantomData&lt;C&gt;);
</code></pre>
<p>Then we implement <code>WeightToFeePolynomial</code> for it. When implementing this trait, your main job is to
return a set of
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/frame_support/weights/struct.WeightToFeeCoefficient.html"><code>WeightToFeeCoefficient</code></a>s.
These coefficients can have integer and fractional parts and be positive or negative. In our
<code>LinearWeightToFee</code> there is a single integer coefficient supplied by the associated type.</p>
<pre><code class="language-rust ignore">impl&lt;C&gt; WeightToFeePolynomial for LinearWeightToFee&lt;C&gt;
where
	C: Get&lt;Balance&gt;,
{
	type Balance = Balance;

	fn polynomial() -&gt; WeightToFeeCoefficients&lt;Self::Balance&gt; {
		let coefficient = WeightToFeeCoefficient {
			coeff_integer: C::get(),
			coeff_frac: Perbill::zero(),
			negative: false,
			degree: 1,
		};

		// Return a smallvec of coefficients. Order does not need to match degrees
		// because each coefficient has an explicit degree annotation.
		smallvec!(coefficient)
	}
}
</code></pre>
<p>This struct is reusable, and works with different coefficients. Using it looks like this.</p>
<pre><code class="language-rust ignore">parameter_types! {
	// Used with LinearWeightToFee conversion. Leaving this constant intact when using other
	// conversion techniques is harmless.
	pub const FeeWeightRatio: u128 = 1_000;

	// --snip--
}

impl transaction_payment::Trait for Runtime {

	// Convert dispatch weight to a chargeable fee.
	type WeightToFee = LinearWeightToFee&lt;FeeWeightRatio&gt;;

	// --snip--
}
</code></pre>
<h2><a class="header" href="#quadratic-conversion" id="quadratic-conversion">Quadratic Conversion</a></h2>
<p>More complex polynomials can also be used. When using complex polynomials, it is unlikely that your
logic will be reused among multiple chains, so it is generally not worth the overhead of making the
coefficients configurable. The <code>QuadraticWeightToFee</code> demonstrates a 2nd-degree polynomial with
hard-coded non-integer signed coefficients.</p>
<pre><code class="language-rust ignore">pub struct QuadraticWeightToFee;

impl WeightToFeePolynomial for QuadraticWeightToFee {
	type Balance = Balance;

	fn polynomial() -&gt; WeightToFeeCoefficients&lt;Self::Balance&gt; {
		let linear = WeightToFeeCoefficient {
			coeff_integer: 2,
			coeff_frac: Perbill::from_percent(40),
			negative: true,
			degree: 1,
		};
		let quadratic = WeightToFeeCoefficient {
			coeff_integer: 3,
			coeff_frac: Perbill::zero(),
			negative: false,
			degree: 2,
		};

		// Return a smallvec of coefficients. Order does not need to match degrees
		// because each coefficient has an explicit degree annotation. In fact, any
		// negative coefficients should be saved for last regardless of their degree
		// because large negative coefficients will likely cause saturation (to zero)
		// if they happen early on.
		smallvec![quadratic, linear]
	}
}
</code></pre>
<h2><a class="header" href="#collecting-fees" id="collecting-fees">Collecting Fees</a></h2>
<p>Having calculated the amount of fees due, runtime authors must decide which asset the fees should be
paid in. A common choice is the use the
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/pallet_balances/index.html"><code>Balances</code> pallet</a>, but any type that
implements the <a href="https://substrate.dev/rustdocs/v2.0.0-rc6/frame_support/traits/trait.Currency.html"><code>Currency</code> trait</a>
can be used. The weight-fee-runtime demonstrates how to use an asset provided by the
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/pallet_generic_asset/index.html"><code>Generic Asset</code> pallet</a>.</p>
<p>src:
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/runtimes/weight-fee-runtime/src/lib.rs"><code>runtimes/weight-fee-runtime/src/lib.rs</code></a></p>
<pre><code class="language-rust ignore">impl transaction_payment::Trait for Runtime {

	// A generic asset whose ID is stored in the generic_asset pallet's runtime storage
	type Currency = SpendingAssetCurrency&lt;Self&gt;;

	// --snip--
}
</code></pre>
<h1><a class="header" href="#consensus" id="consensus">Consensus</a></h1>
<p>Consensus is the part of the outer node that decides which blocks are in the real blockchain. Learn about it in this section of the cookbook.</p>
<h1><a class="header" href="#sha3-proof-of-work-algorithms" id="sha3-proof-of-work-algorithms">Sha3 Proof of Work Algorithms</a></h1>
<p><code>consensus/sha3-pow</code>
<a href="https://playground-staging.substrate.dev/?deploy=recipes&amp;files=%2Fhome%2Fsubstrate%2Fworkspace%2Fconsensus%2Fsha3-pow%2Fsrc%2Flib.rs">
<img src="https://img.shields.io/badge/Playground-Try%20it!-brightgreen?logo=Parity%20Substrate" alt="Try on playground" />
</a>
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/consensus/sha3-pow/src/lib.rs">
<img src="https://img.shields.io/badge/Github-View%20Code-brightgreen?logo=github" alt="View on GitHub" />
</a></p>
<p><a href="https://en.wikipedia.org/wiki/Proof_of_work">Proof of Work</a> is not a single consensus algorithm.
Rather it is a class of algorithms represented in Substrate by the
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sc_consensus_pow/trait.PowAlgorithm.html"><code>PowAlgorithm</code> trait</a>. Before we
can build a PoW node we must specify a concrete PoW algorithm by implementing this trait. In this
recipe we specify two concrete PoW algorithms, both of which are based on the
<a href="https://en.wikipedia.org/wiki/SHA-3">sha3 hashing algorithm</a>.</p>
<h2><a class="header" href="#minimal-sha3-pow" id="minimal-sha3-pow">Minimal Sha3 PoW</a></h2>
<p>First we turn our attention to a minimal working implementation. This consensus engine is kept
intentionally simple. It omits some features that make Proof of Work practical for real-world use
such as difficulty adjustment.</p>
<p>Begin by creating a struct that will implement the <code>PowAlgorithm Trait</code>.</p>
<pre><code class="language-rust ignore">/// A minimal PoW algorithm that uses Sha3 hashing.
/// Difficulty is fixed at 1_000_000
#[derive(Clone)]
pub struct MinimalSha3Algorithm;
</code></pre>
<p>Because this is a <em>minimal</em> PoW algorithm, our struct can also be quite simple. In fact, it is a
<a href="https://doc.rust-lang.org/rust-by-example/custom_types/structs.html">unit struct</a>. A more complex
PoW algorithm that interfaces with the runtime would need to hold a reference to the client. An
example of this (on an older Substrate codebase) can be seen in
<a href="https://github.com/kulupu/kulupu/">Kulupu</a>'s
<a href="https://github.com/kulupu/kulupu/blob/3500b7f62fdf90be7608b2d813735a063ad1c458/pow/src/lib.rs#L137-L145">RandomXAlgorithm</a>.</p>
<h3><a class="header" href="#difficulty" id="difficulty">Difficulty</a></h3>
<p>The first function we must provide returns the difficulty of the next block to be mined. In our
minimal sha3 algorithm, this function is quite simple. The difficulty is fixed. This means that as
more mining power joins the network, the block time will become faster.</p>
<pre><code class="language-rust ignore">impl&lt;B: BlockT&lt;Hash=H256&gt;&gt; PowAlgorithm&lt;B&gt; for Sha3Algorithm {
	type Difficulty = U256;

	fn difficulty(&amp;self, _parent: &amp;BlockId&lt;B&gt;) -&gt; Result&lt;Self::Difficulty, Error&lt;B&gt;&gt; {
		// This basic PoW uses a fixed difficulty.
		// Raising this difficulty will make the block time slower.
		Ok(U256::from(1_000_000))
	}

	// --snip--
}
</code></pre>
<h3><a class="header" href="#verification" id="verification">Verification</a></h3>
<p>Our PoW algorithm must also be able to verify blocks provided by other authors. We are first given
the pre-hash, which is a hash of the block before the proof of work seal is attached. We are also
given the seal, which testifies that the work has been done, and the difficulty that the block
author needed to meet. This function first confirms that the provided seal actually meets the target
difficulty, then it confirms that the seal is actually valid for the given pre-hash.</p>
<pre><code class="language-rust ignore">fn verify(
	&amp;self,
	_parent: &amp;BlockId&lt;B&gt;,
	pre_hash: &amp;H256,
	_pre_digest: Option&lt;&amp;[u8]&gt;,
	seal: &amp;RawSeal,
	difficulty: Self::Difficulty
) -&gt; Result&lt;bool, Error&lt;B&gt;&gt; {
	// Try to construct a seal object by decoding the raw seal given
	let seal = match Seal::decode(&amp;mut &amp;seal[..]) {
		Ok(seal) =&gt; seal,
		Err(_) =&gt; return Ok(false),
	};

	// See whether the hash meets the difficulty requirement. If not, fail fast.
	if !hash_meets_difficulty(&amp;seal.work, difficulty) {
		return Ok(false)
	}

	// Make sure the provided work actually comes from the correct pre_hash
	let compute = Compute {
		difficulty,
		pre_hash: *pre_hash,
		nonce: seal.nonce,
	};

	if compute.compute() != seal {
		return Ok(false)
	}

	Ok(true)
}
</code></pre>
<h3><a class="header" href="#mining" id="mining">Mining</a></h3>
<p>Finally our proof of work algorithm needs to be able to mine blocks of our own.</p>
<pre><code class="language-rust ignore">fn mine(
	&amp;self,
	_parent: &amp;BlockId&lt;B&gt;,
	pre_hash: &amp;H256,
	_pre_digest: Option&lt;&amp;[u8]&gt;,
	difficulty: Self::Difficulty,
	round: u32 // The number of nonces to try during this call
) -&gt; Result&lt;Option&lt;RawSeal&gt;, Error&lt;B&gt;&gt; {
	// Get a randomness source from the environment; fail if one isn't available
	let mut rng = SmallRng::from_rng(&amp;mut thread_rng())
		.map_err(|e| Error::Environment(format!(&quot;Initialize RNG failed for mining: {:?}&quot;, e)))?;

	// Loop the specified number of times
	for _ in 0..round {

		// Choose a new nonce
		let nonce = H256::random_using(&amp;mut rng);

		// Calculate the seal
		let compute = Compute {
			difficulty,
			pre_hash: *pre_hash,
			nonce,
		};
		let seal = compute.compute();

		// If we solved the PoW then return, otherwise loop again
		if hash_meets_difficulty(&amp;seal.work, difficulty) {
			return Ok(Some(seal.encode()))
		}
	}

	// Tried the specified number of rounds and never found a solution
	Ok(None)
}
</code></pre>
<p>Notice that this function takes a parameter for the number of rounds of mining it should attempt. If
no block has been successfully mined in this time, the method will return. This gives the service a
chance to check whether any new blocks have been received from other authors since the mining
started. If a valid block has been received, then we will start mining on it. If no such block has
been received, we will go in for another try at mining on the same block as before.</p>
<h2><a class="header" href="#realistic-sha3-pow" id="realistic-sha3-pow">Realistic Sha3 PoW</a></h2>
<p>Having understood the fundamentals, we can now build a more realistic sha3 algorithm. The primary
difference here is that this algorithm will fetch the difficulty from the runtime via a
<a href="./runtime-api.html">runtime api</a>. This change allows the runtime to dynamically adjust the difficulty
based on block time. So if more mining power joins the network, the diffculty adjusts, and the
blocktime remains constant.</p>
<h3><a class="header" href="#defining-the-sha3algorithm-struct" id="defining-the-sha3algorithm-struct">Defining the <code>Sha3Algorithm</code> Struct</a></h3>
<p>We begin as before by defining a struct that will implement the <code>PowAlgorithm</code> trait. Unlike before,
this struct must hold a reference to the
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sc_service/client/struct.Client.html"><code>Client</code></a> so it can call the
appropriate runtime APIs.</p>
<pre><code class="language-rust ignore">/// A complete PoW Algorithm that uses Sha3 hashing.
/// Needs a reference to the client so it can grab the difficulty from the runtime.
pub struct Sha3Algorithm&lt;C&gt; {
	client: Arc&lt;C&gt;,
}
</code></pre>
<p>Next we provide a <code>new</code> method for conveniently creating instances of our new struct.</p>
<pre><code class="language-rust ignore">impl&lt;C&gt; Sha3Algorithm&lt;C&gt; {
	pub fn new(client: Arc&lt;C&gt;) -&gt; Self {
		Self { client }
	}
}
</code></pre>
<p>And finally we manually implement <code>Clone</code>. We cannot derive clone as we did for the
<code>MinimalSha3Algorithm</code>.</p>
<pre><code class="language-rust ignore">// Manually implement clone. Deriving doesn't work because
// it'll derive impl&lt;C: Clone&gt; Clone for Sha3Algorithm&lt;C&gt;. But C in practice isn't Clone.
impl&lt;C&gt; Clone for Sha3Algorithm&lt;C&gt; {
	fn clone(&amp;self) -&gt; Self {
		Self::new(self.client.clone())
	}
}
</code></pre>
<blockquote>
<p>It isn't critical to understand <em>why</em> the manual <code>Clone</code> implementation is necessary, just that it
is necessary.</p>
</blockquote>
<h3><a class="header" href="#implementing-the-powalgorithm-trait" id="implementing-the-powalgorithm-trait">Implementing the <code>PowAlgorithm</code> trait</a></h3>
<p>As before we implement the <code>PowAlgorithm</code> trait for out <code>Sha3Algorithm</code>. This time we supply more
complex trait bounds to ensure that the client the algorithm holds a reference to actually provides
the <a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sp_consensus_pow/trait.DifficultyApi.html"><code>DifficultyAPI</code></a> necessary
to fetch the PoW difficulty from the runtime.</p>
<pre><code class="language-rust ignore">// Here we implement the general PowAlgorithm trait for our concrete Sha3Algorithm
impl&lt;B: BlockT&lt;Hash=H256&gt;, C&gt; PowAlgorithm&lt;B&gt; for Sha3Algorithm&lt;C&gt; where
	C: ProvideRuntimeApi&lt;B&gt;,
	C::Api: DifficultyApi&lt;B, U256&gt;,
{
	type Difficulty = U256;

	// --snip
}
</code></pre>
<h3><a class="header" href="#difficulty-1" id="difficulty-1">Difficulty</a></h3>
<p>The implementation of <code>PowAlgorithm</code>'s <code>difficulty</code> function, no longer returns a fxed value, but
rather calls into the runtime API which is guaranteed to exist because of the trait bounds. It also
maps any errors that may have occurred when using the API.</p>
<pre><code class="language-rust ignore">fn difficulty(&amp;self, parent: B::Hash) -&gt; Result&lt;Self::Difficulty, Error&lt;B&gt;&gt; {
	let parent_id = BlockId::&lt;B&gt;::hash(parent);
	self.client.runtime_api().difficulty(&amp;parent_id)
		.map_err(|e| sc_consensus_pow::Error::Environment(
			format!(&quot;Fetching difficulty from runtime failed: {:?}&quot;, e)
		))
}
</code></pre>
<h3><a class="header" href="#verify-and-mine" id="verify-and-mine">Verify and Mine</a></h3>
<p>The <code>verify</code> and <code>mine</code> functions are unchanged from the <code>MinimalSha3Algorithm</code> implementation.</p>
<h1><a class="header" href="#nodes" id="nodes">Nodes</a></h1>
<p>The &quot;outer node&quot; is the part of a Substrate chain that is not in the runtime. It handles networking, gossip, transaction queueing, and consensus. Learn about it in this section of the cookbook.</p>
<h1><a class="header" href="#kitchen-node-instant-seal" id="kitchen-node-instant-seal">Kitchen Node (Instant Seal)</a></h1>
<p><code>nodes/kitchen-node</code>
<a href="https://playground-staging.substrate.dev/?deploy=recipes&amp;files=%2Fhome%2Fsubstrate%2Fworkspace%2Fnodes%2Fkitchen-node%2Fsrc%2Flib.rs">
<img src="https://img.shields.io/badge/Playground-Try%20it!-brightgreen?logo=Parity%20Substrate" alt="Try on playground" />
</a>
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/nodes/kitchen-node/src/lib.rs">
<img src="https://img.shields.io/badge/Github-View%20Code-brightgreen?logo=github" alt="View on GitHub" />
</a></p>
<p>This recipe demonstrates a general purpose Substrate node that supports most of the recipes'
runtimes, and uses
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sc_consensus_manual_seal/index.html">Instant Seal consensus</a>.</p>
<p>The kitchen node serves as the first point of entry for most aspiring chefs when they first
encounter the recipes. By default it builds with the super-runtime, but it can be used with most of
the runtimes in the recipes. Changing the runtime is described below. It features the instant seal
consensus which is perfect for testing and iterating on a runtime.</p>
<h2><a class="header" href="#installing-a-runtime" id="installing-a-runtime">Installing a Runtime</a></h2>
<h3><a class="header" href="#cargo-dependency" id="cargo-dependency">Cargo Dependency</a></h3>
<p>The <code>Cargo.toml</code> file specifies the runtime as a dependency. The file imports the super-runtime, and
has dependencies on other runtimes commented out.</p>
<pre><code class="language-toml"># Common runtime configured with most Recipes pallets.
runtime = { package = &quot;super-runtime&quot;, path = &quot;../../runtimes/super-runtime&quot; }

# Runtime with custom weight and fee calculation.
# runtime = { package = &quot;weight-fee-runtime&quot;, path = &quot;../../runtimes/weight-fee-runtime&quot;}

# Runtime with off-chain worker enabled.
# To use this runtime, compile the node with `ocw` feature enabled,
#   `cargo build --release --features ocw`.
# runtime = { package = &quot;ocw-runtime&quot;, path = &quot;../../runtimes/ocw-runtime&quot; }

# Runtime with custom runtime-api (custom API only used in rpc-node)
#runtime = { package = &quot;api-runtime&quot;, path = &quot;../../runtimes/api-runtime&quot; }
</code></pre>
<p>Installing a different runtime in the node is just a matter of commenting out the super-runtime
line, and enabling another one. Try the weight-fee runtime for example. Of course cargo will
complain if you try to import two crates under the name <code>runtime</code>.</p>
<p>It is worth noting that this node does not work with <em>all</em> of the recipes' runtimes. In particular,
it is not compatible with the babe-grandpa runtime. That runtime uses the babe pallet which requires
a node that will include a special
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sp_runtime/enum.DigestItem.html#variant.PreRuntime"><code>PreRuntime</code> <code>DigestItem</code></a>.</p>
<h3><a class="header" href="#building-a-service-with-the-runtime" id="building-a-service-with-the-runtime">Building a Service with the Runtime</a></h3>
<p>With a runtime of our choosing listed among our dependencies, we can wiring the nodes <a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sc_service/index.html"><code>Service</code></a>, the part of the node that coordinates communication between all other parts.</p>
<p>We begin by invoking the
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sc_executor/macro.native_executor_instance.html"><code>native_executor_instance!</code> macro</a>.
This creates an executor which is responsible for executing transactions in the runtime and
determining whether to run the native or Wasm version of the runtime.</p>
<pre><code class="language-rust_ignore">native_executor_instance!(
	pub Executor,
	runtime::api::dispatch,
	runtime::native_version,
);
</code></pre>
<p>The remainder of the file will create the individual components of the node and connect them together. Most of this code is boilerplate taken from the Substrate Node Template. We will focus specifically on the unique consensus engine used here.</p>
<h2><a class="header" href="#instant-seal-consensus" id="instant-seal-consensus">Instant Seal Consensus</a></h2>
<p>The instant seal consensus engine, and its cousin the manual seal consensus engine, are both
included in the same
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sc_consensus_manual_seal/index.html"><code>sc-consensus-manual-seal</code> crate</a>. Instant seal
simply authors a new block whenever a new transaction is available in the queue. This is similar to
<a href="https://www.trufflesuite.com/ganache">Truffle Suite's Ganache</a> in the Ethereum ecosystem, but
without the UI.</p>
<h3><a class="header" href="#the-cargo-dependencies" id="the-cargo-dependencies">The Cargo Dependencies</a></h3>
<p>Installing the instant seal engine has three dependencies whereas the runtime had only one.</p>
<pre><code class="language-toml">sc-consensus = '0.8.0-rc4'
sc-consensus-manual-seal = '0.8.0-rc4'
sp-consensus = '0.8.0-rc4'
</code></pre>
<h3><a class="header" href="#the-import-queue" id="the-import-queue">The Import Queue</a></h3>
<p>We begin in <code>new_partial</code> by creating a manual-seal import queue. Both instant seal and manual seal use the same import queue. This process is similar to, but simpler than, the
<a href="./basic-pow.html">basic-pow</a> import queue.</p>
<pre><code class="language-rust ignore">let import_queue = sc_consensus_manual_seal::import_queue(
	Box::new(client.clone()),
	&amp;task_manager.spawn_handle(),
	config.prometheus_registry(),
);
</code></pre>
<h3><a class="header" href="#the-proposer" id="the-proposer">The Proposer</a></h3>
<p>Now we pick up in the <code>new_full</code> function. All of the code in this portion is executed only if the node is an authority. Create a
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sc_basic_authorship/struct.Proposer.html"><code>Proposer</code></a> which will be
responsible for creating proposing blocks in the chain.</p>
<pre><code class="language-rust ignore">let proposer = sc_basic_authorship::ProposerFactory::new(
	service.client().clone(),
	service.transaction_pool(),
);
</code></pre>
<h3><a class="header" href="#the-authorship-task" id="the-authorship-task">The Authorship Task</a></h3>
<p>As with every authoring engine, instant seal needs to be run as an <code>async</code> authoring task.</p>
<pre><code class="language-rust ignore">let authorship_future = sc_consensus_manual_seal::run_instant_seal(
	Box::new(client.clone()),
	proposer,
	client,
	transaction_pool.pool().clone(),
	select_chain,
	inherent_data_providers,
);
</code></pre>
<p>With the future created, we can now kick it off using the <a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sc_service/struct.TaskManager.html"><code>TaskManager</code></a>'s
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sc_service/struct.TaskManager.html#method.spawn_essential_handle"><code>spawn_essential_handle</code> method</a>.</p>
<pre><code class="language-rust ignore">task_manager.spawn_essential_handle().spawn_blocking(&quot;instant-seal&quot;, authorship_future);
</code></pre>
<h2><a class="header" href="#manual-seal-consensus" id="manual-seal-consensus">Manual Seal Consensus</a></h2>
<p>The instant seal consensus engine used in this node is built on top of a similar manual seal engine. Manual seal listens for commands to come over the RPC instructing it to author blocks. To see this engine in use, check out the <a href="./custom-rpc.html">RPC node recipe</a>.</p>
<h1><a class="header" href="#custom-rpcs" id="custom-rpcs">Custom RPCs</a></h1>
<p><code>nodes/custom-rpc</code>
<a href="https://playground-staging.substrate.dev/?deploy=recipes&amp;files=%2Fhome%2Fsubstrate%2Fworkspace%2Fnodes%2Frpc-node%2Fsrc%2Flib.rs">
<img src="https://img.shields.io/badge/Playground-Try%20it!-brightgreen?logo=Parity%20Substrate" alt="Try on playground" />
</a>
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/nodes/rpc-node/src/lib.rs">
<img src="https://img.shields.io/badge/Github-View%20Code-brightgreen?logo=github" alt="View on GitHub" />
</a></p>
<p><code>runtimes/api-runtime</code>
<a href="https://playground-staging.substrate.dev/?deploy=recipes&amp;files=%2Fhome%2Fsubstrate%2Fworkspace%2Fruntimes%2Fapi-runtime%2Fsrc%2Flib.rs">
<img src="https://img.shields.io/badge/Playground-Try%20it!-brightgreen?logo=Parity%20Substrate" alt="Try on playground" />
</a>
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/runtimes/api-runtime/src/lib.rs">
<img src="https://img.shields.io/badge/Github-View%20Code-brightgreen?logo=github" alt="View on GitHub" />
</a></p>
<p>Remote Procedure Calls, or RPCs, are a way for an external program (eg. a frontend) to communicate
with a Substrate node. They are used for checking storage values, submitting transactions, and
querying the current consensus authorities. Substrate comes with several
<a href="https://polkadot.js.org/api/substrate/rpc.html">default RPCs</a>. In many cases it is useful to add
custom RPCs to your node. In this recipe, we will add three custom RPCs to our node. The first is trivial, the second calls into a <a href="./runtime-api.html">custom runtime API</a>, and the third interfaces with consensus.</p>
<h2><a class="header" href="#the-rpc-extensions-builder" id="the-rpc-extensions-builder">The RPC Extensions Builder</a></h2>
<p>In order to connect custom RPCs you must provide an function known as an &quot;RPC extension builder&quot;. This function takes a parameter for whether the node should deny unsafe RPC calls, and returns an <a href="https://docs.rs/jsonrpc-core/14.2.0/jsonrpc_core/struct.IoHandler.html">IoHandler</a> that the node needs to create a json RPC.</p>
<pre><code class="language-rust ignore">let rpc_extensions_builder = {
	let client = client.clone();
	let pool = transaction_pool.clone();
	Box::new(move |deny_unsafe| {
		let deps = crate::rpc::FullDeps {
			client: client.clone(),
			pool: pool.clone(),
			deny_unsafe,
			command_sink: command_sink.clone(),
		};

		crate::rpc::create_full(deps)
	})
};
</code></pre>
<p>This code is mostly boilerplate and can be reused. The one difference that you will encounter in your own node is the parameters that you pass. Here we've passed four parameters:</p>
<ul>
<li><code>client</code> - will be used in our second RPC</li>
<li>The transaction <code>pool</code> - we will not actually use it but many RPCs do</li>
<li><code>deny_unsafe</code> - whether to deny unsafe calls</li>
<li><code>commands_sink</code> - will be used in our third RPC</li>
</ul>
<p>With this builder function out of the way we can begin attaching our actual RPC endpoints.</p>
<h2><a class="header" href="#the-silly-rpc" id="the-silly-rpc">The Silly RPC</a></h2>
<p>We'll begin by defining a simple RPC called &quot;silly rpc&quot; which just returns integers. A Hello world of sorts.</p>
<h3><a class="header" href="#defining-the-silly-rpc" id="defining-the-silly-rpc">Defining the Silly RPC</a></h3>
<p>Every RPC that the node will use must be defined in a trait. In the
<code>nodes/rpc-node/src/silly_rpc.rs</code> file, we define a basic rpc as</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[rpc]
pub trait SillyRpc {
	#[rpc(name = &quot;silly_seven&quot;)]
	fn silly_7(&amp;self) -&gt; Result&lt;u64&gt;;

	#[rpc(name = &quot;silly_double&quot;)]
	fn silly_double(&amp;self, val: u64) -&gt; Result&lt;u64&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>This definition defines two RPC methods called <code>silly_seven</code> and <code>silly_double</code>. Each RPC method must
take a <code>&amp;self</code> reference and must return a <code>Result</code>. Next, we define a struct that implements this
trait.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Silly;

impl SillyRpc for Silly {
	fn silly_7(&amp;self) -&gt; Result&lt;u64&gt; {
		Ok(7)
	}

	fn silly_double(&amp;self, val: u64) -&gt; Result&lt;u64&gt; {
		Ok(2 * val)
	}
}
<span class="boring">}
</span></code></pre></pre>
<p>Finally, to make the contents of this new file usable, we need to add a line in our <code>main.rs</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod silly_rpc;
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#including-the-silly-rpc" id="including-the-silly-rpc">Including the Silly RPC</a></h3>
<p>With our RPC written, we're ready to extend our <code>IoHandler</code> with it. We begin with a few dependencies in our
<code>rpc-node</code>'s <code>Cargo.toml</code>.</p>
<pre><code class="language-toml">jsonrpc-core = &quot;14.0.3&quot;
jsonrpc-core-client = &quot;14.0.3&quot;
jsonrpc-derive = &quot;14.0.3&quot;
sc-rpc = '2.0.0-rc6'
</code></pre>
<p>Now we're ready to write the <code>create_full</code> function we referenced from our service. The function is quoted in its entirety below. You ca see we add the</p>
<pre><code class="language-rust ignore">pub fn create_full&lt;C, P&gt;(
	deps: FullDeps&lt;C, P&gt;,
) -&gt; jsonrpc_core::IoHandler&lt;sc_rpc::Metadata&gt; where
	// --snip--
{

	let mut io = jsonrpc_core::IoHandler::default();

	// Add a silly RPC that returns constant values
	io.extend_with(crate::silly_rpc::SillyRpc::to_delegate(
		crate::silly_rpc::Silly {},
	));

	// --snip--

	io
}
</code></pre>
<p>These few lines extend our node with the Silly RPC.</p>
<h3><a class="header" href="#calling-the-silly-rpc" id="calling-the-silly-rpc">Calling the Silly RPC</a></h3>
<p>Once your node is running, you can test the RPC by calling it with any client that speaks json RPC.
One widely available option is <code>curl</code>.</p>
<pre><code class="language-bash">$ curl http://localhost:9933 -H &quot;Content-Type:application/json;charset=utf-8&quot; -d   '{
     &quot;jsonrpc&quot;:&quot;2.0&quot;,
      &quot;id&quot;:1,
      &quot;method&quot;:&quot;silly_seven&quot;,
      &quot;params&quot;: []
    }'
</code></pre>
<p>To which the RPC responds</p>
<pre><code>{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;:7,&quot;id&quot;:1}
</code></pre>
<p>You may have noticed that our second RPC takes a parameter, the value to double. You can supply this
parameter by including its in the <code>params</code> list. For example:</p>
<pre><code class="language-bash">$ curl http://localhost:9933 -H &quot;Content-Type:application/json;charset=utf-8&quot; -d   '{
     &quot;jsonrpc&quot;:&quot;2.0&quot;,
      &quot;id&quot;:1,
      &quot;method&quot;:&quot;silly_double&quot;,
      &quot;params&quot;: [7]
    }'
</code></pre>
<p>To which the RPC responds with the doubled parameter</p>
<pre><code>{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;:14,&quot;id&quot;:1}
</code></pre>
<h2><a class="header" href="#rpc-to-call-a-runtime-api" id="rpc-to-call-a-runtime-api">RPC to Call a Runtime API</a></h2>
<p>The silly RPC demonstrates the fundamentals of working with RPCs in Substrate. Nonetheless, most
RPCs will go beyond what we've learned so far and actually interacts with other parts of the node.
In this second example, we will include an RPC that calls into the <code>sum-storage</code> runtime API from
the <a href="./runtime-api.html">runtime API recipe</a>. While it isn't strictly necessary to understand what the
runtime API does, reading that recipe may provide helpful context.</p>
<h3><a class="header" href="#defining-the-sum-storage-rpc" id="defining-the-sum-storage-rpc">Defining the Sum Storage RPC</a></h3>
<p>Because this RPC's behavior is closely related to a specific pallet, we've chosen to define the RPC
in the pallet's directory. In this case the RPC is defined in <code>pallets/sum-storage/rpc</code>. So rather
than using the <code>mod</code> keyword as we did before, we must include this RPC definition in the node's
<code>Cargo.toml</code> file.</p>
<pre><code class="language-toml">sum-storage-rpc = { path = &quot;../../pallets/sum-storage/rpc&quot; }
</code></pre>
<p>Defining the RPC interface is similar to before, but there are a few differences worth noting.
First, the struct that implements the RPC needs a reference to the <code>client</code>. This is necessary so we
can actually call into the runtime. Second the struct is generic over the <code>BlockHash</code> type. This is
because it will call a runtime API, and runtime APIs must always be called at a specific block.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[rpc]
pub trait SumStorageApi&lt;BlockHash&gt; {
	#[rpc(name = &quot;sumStorage_getSum&quot;)]
	fn get_sum(
		&amp;self,
		at: Option&lt;BlockHash&gt;
	) -&gt; Result&lt;u32&gt;;
}

/// A struct that implements the `SumStorageApi`.
pub struct SumStorage&lt;C, M&gt; {
	client: Arc&lt;C&gt;,
	_marker: std::marker::PhantomData&lt;M&gt;,
}

impl&lt;C, M&gt; SumStorage&lt;C, M&gt; {
	/// Create new `SumStorage` instance with the given reference to the client.
	pub fn new(client: Arc&lt;C&gt;) -&gt; Self {
		Self { client, _marker: Default::default() }
	}
}
<span class="boring">}
</span></code></pre></pre>
<p>The RPC's implementation is also similar to before. The additional syntax here is related to calling
the runtime at a specific block, as well as ensuring that the runtime we're calling actually has the
correct runtime API available.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;C, Block&gt; SumStorageApi&lt;&lt;Block as BlockT&gt;::Hash&gt;
	for SumStorage&lt;C, Block&gt;
where
	Block: BlockT,
	C: Send + Sync + 'static,
	C: ProvideRuntimeApi,
	C: HeaderBackend&lt;Block&gt;,
	C::Api: SumStorageRuntimeApi&lt;Block&gt;,
{
	fn get_sum(
		&amp;self,
		at: Option&lt;&lt;Block as BlockT&gt;::Hash&gt;
	) -&gt; Result&lt;u32&gt; {

		let api = self.client.runtime_api();
		let at = BlockId::hash(at.unwrap_or_else(||
			// If the block hash is not supplied assume the best block.
			self.client.info().best_hash
		));

		let runtime_api_result = api.get_sum(&amp;at);
		runtime_api_result.map_err(|e| RpcError {
			code: ErrorCode::ServerError(9876), // No real reason for this value
			message: &quot;Something wrong&quot;.into(),
			data: Some(format!(&quot;{:?}&quot;, e).into()),
		})
	}
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#installing-the-sum-storage-rpc" id="installing-the-sum-storage-rpc">Installing the Sum Storage RPC</a></h3>
<p>To install this RPC , we expand the existing <code>create_full</code> function from <code>rpc.rs</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>io.extend_with(sum_storage_rpc::SumStorageApi::to_delegate(
	sum_storage_rpc::SumStorage::new(client),
));
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#using-rpc-parameters" id="using-rpc-parameters">Using RPC Parameters</a></h3>
<p>This RPC takes a parameter ,<code>at</code>, whose type is <code>Option&lt;_&gt;</code>. We may call this RPC by omitting the
optional parameter entirely. In this case the implementation provides a default value of the best
block.</p>
<pre><code class="language-bash">$ curl http://localhost:9933 -H &quot;Content-Type:application/json;charset=utf-8&quot; -d   '{
     &quot;jsonrpc&quot;:&quot;2.0&quot;,
      &quot;id&quot;:1,
      &quot;method&quot;:&quot;sumStorage_getSum&quot;,
      &quot;params&quot;: []
    }'
</code></pre>
<p>We may also call the RPC by providing a block hash. One easy way to get a block hash to test this
call is by copying it from the logs of a running node.</p>
<pre><code class="language-bash">$ curl http://localhost:9933 -H &quot;Content-Type:application/json;charset=utf-8&quot; -d   '{
     &quot;jsonrpc&quot;:&quot;2.0&quot;,
      &quot;id&quot;:1,
      &quot;method&quot;:&quot;sumStorage_getSum&quot;,
      &quot;params&quot;: [&quot;0x87b2e4b93e74d2f06a0bde8de78c9e2a9823ce559eb5e3c4710de40a1c1071ac&quot;]
    }'
</code></pre>
<p>As an exercise, change the storage values and confirm that the RPC provides the correct updated sum.
Then call the RPC at an old block and confirm you get the old sum.</p>
<h3><a class="header" href="#polkadot-js-api" id="polkadot-js-api">Polkadot JS API</a></h3>
<p>Many frontends interact with Substrate nodes through Polkadot JS API. While the Recipes does not
strive to document that project, we have included a snippet of javascript for interacting with these first two
custom RPCs in the <code>nodes/rpc-node/js</code> directory.</p>
<h2><a class="header" href="#the-manual-seal-rpc" id="the-manual-seal-rpc">The Manual Seal RPC</a></h2>
<p>Our third and final example RPC will interact with consensus. Specifically, it will tell the consensus engine when to author and finalize blocks. The API for this RPC if defined in Substrate in the <a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sc_consensus_manual_seal/rpc/trait.ManualSealApi.html"><code>ManualSealApi</code> Trait</a>.</p>
<h3><a class="header" href="#installing-the-manual-seal-rpc" id="installing-the-manual-seal-rpc">Installing the Manual Seal RPC</a></h3>
<p>The previous RPC needed a reference to the <code>client</code> to call into the runtime. Likewise, this RPC needs a command stream to send messages to the actual consensus engine. This recipe does not cover installing the manual seal engine, but it is nearly identical to the <a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sc_consensus_manual_seal/fn.run_instant_seal.html">instant seal engine</a> used in the <a href="./kitchen-node.html">Kitchen Node</a>.</p>
<p>To install the RPC endpoint, we do exactly as we have before, and extend the <code>create_full</code> function in <code>rpc.rs</code></p>
<pre><code class="language-rust ignore">io.extend_with(
	// We provide the rpc handler with the sending end of the channel to allow the rpc
	// send EngineCommands to the background block authorship task.
	ManualSealApi::to_delegate(ManualSeal::new(command_sink)),
);
</code></pre>
<h3><a class="header" href="#using-manual-seal" id="using-manual-seal">Using Manual Seal</a></h3>
<p>Once your node is running, you will see that it just sits there idly. It will accept transactions to
the pool, but it will not author blocks on its own. In manual seal, the node does not author a block
until we explicitly tell it to. We can tell it to author a block by calling the <code>engine_createBlock</code>
RPC.</p>
<pre><code class="language-bash">$ curl http://localhost:9933 -H &quot;Content-Type:application/json;charset=utf-8&quot; -d   '{
     &quot;jsonrpc&quot;:&quot;2.0&quot;,
      &quot;id&quot;:1,
      &quot;method&quot;:&quot;engine_createBlock&quot;,
      &quot;params&quot;: [true, false, null]
    }'
</code></pre>
<p>This call takes three parameters, each of which are worth exploring.</p>
<h4><a class="header" href="#create-empty" id="create-empty">Create Empty</a></h4>
<p><code>create_empty</code> is a Boolean value indicating whether empty blocks may be created. Setting
<code>create-empty</code> to true does not mean that an empty block will necessarily be created. Rather it
means that the engine should go ahead creating a block even if no transaction are present. If
transactions are present in the queue, they will be included regardless of <code>create_empty</code>'s value.'</p>
<h4><a class="header" href="#finalize" id="finalize">Finalize</a></h4>
<p><code>finalize</code> is a Boolean indicating whether the block (and its ancestors, recursively) should be
finalized after creation. Manually controlling finality is interesting, but also dangerous. If you
attempt to author and finalize a block that does not build on the best finalized chain, the block
will not be imported. If you finalize one block in one node, and a conflicting block in another
node, you will cause a safety violation when the nodes synchronize.</p>
<h4><a class="header" href="#parent-hash" id="parent-hash">Parent Hash</a></h4>
<p><code>parent_hash</code> is an optional hash of a block to use as a parent. To set the parent, use the format
<code>&quot;0x0e0626477621754200486f323e3858cd5f28fcbe52c69b2581aecb622e384764&quot;</code>. To omit the parent, use
<code>null</code>. When the parent is omitted the block is built on the current best block. Manually specifying
the parent is useful for constructing fork scenarios and demonstrating chain reorganizations.</p>
<h4><a class="header" href="#manually-finalizing-blocks" id="manually-finalizing-blocks">Manually Finalizing Blocks</a></h4>
<p>In addition to finalizing blocks while creating them, they can be finalized later by using the
second provided RPC call, <code>engine_finalizeBlock</code>.</p>
<pre><code class="language-bash">$ curl http://localhost:9933 -H &quot;Content-Type:application/json;charset=utf-8&quot; -d   '{
     &quot;jsonrpc&quot;:&quot;2.0&quot;,
      &quot;id&quot;:1,
      &quot;method&quot;:&quot;engine_finalizeBlock&quot;,
      &quot;params&quot;: [&quot;0x0e0626477621754200486f323e3858cd5f28fcbe52c69b2581aecb622e384764&quot;, null]
    }'
</code></pre>
<p>The two parameters are:</p>
<ul>
<li>The hash of the block to finalize.</li>
<li>A Justification. TODO what is the justification and why might I want to use it?</li>
</ul>
<h1><a class="header" href="#basic-proof-of-work" id="basic-proof-of-work">Basic Proof of Work</a></h1>
<p><code>nodes/basic-pow</code>
<a href="https://playground-staging.substrate.dev/?deploy=recipes&amp;files=%2Fhome%2Fsubstrate%2Fworkspace%2Fnodes%2Fbasic-pow%2Fsrc%2Flib.rs">
<img src="https://img.shields.io/badge/Playground-Try%20it!-brightgreen?logo=Parity%20Substrate" alt="Try on playground" />
</a>
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/nodes/basic-pow/src/lib.rs">
<img src="https://img.shields.io/badge/Github-View%20Code-brightgreen?logo=github" alt="View on GitHub" />
</a></p>
<p>The <code>basic-pow</code> node demonstrates how to wire up a custom consensus engine into the Substrate
Service. It uses a minimal proof of work consensus engine to reach agreement over the blockchain. It
will teach us many useful aspects of dealing with consensus and prepare us to understand more
advanced consensus engines in the future. In particular we will learn about:</p>
<ul>
<li>Substrate's
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sp_consensus/block_import/trait.BlockImport.html"><code>BlockImport</code> trait</a></li>
<li>Substrate's <a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sp_consensus/import_queue/index.html">import pipeline</a></li>
<li>Structure of a typical <a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sc_service/index.html">Substrate Service</a></li>
<li>Configuration of
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sp_authorship/struct.InherentDataProvider.html"><code>InherentDataProvider</code></a>s</li>
</ul>
<h2><a class="header" href="#the-structure-of-a-node" id="the-structure-of-a-node">The Structure of a Node</a></h2>
<p>A Substrate node has two parts. An outer part that is responsible for gossiping transactions and
blocks, handling <a href="./custom-rpc.html">rpc requests</a>, and reaching consensus. And a runtime that is
responsible for the business logic of the chain. This architecture diagram illustrates the
distinction.</p>
<p><img src="img/substrate-architecture.png" alt="Substrate Architecture Diagram" /></p>
<p>In principle, the consensus engine (part of the outer node) is agnostic to the runtime that is used
with it. But in practice, most consensus engines will require the runtime to provide certain
<a href="./runtime-api.html">runtime APIs</a> that affect the engine. For example, Aura and Babe query the
runtime for the set of validators. A more real-world PoW consensus would query the runtime for the
block difficulty. Additionally, some runtimes rely on the consensus engine to provide
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sp_runtime/generic/enum.DigestItem.html#variant.PreRuntime">pre-runtime digests</a>.
For example, runtimes that include the Babe pallet expect a pre-runtime digest containing
information about the current babe slot.</p>
<p>In this recipe we will avoid those practical complexities by using the
<a href="./sha3-pow-consensus.html">Minimal Sha3 Proof of Work</a> consensus engine, and a dedicated
<code>pow-runtime</code> which are truly isolated from each other. The contents of the runtime should be
familiar, and will not be discussed here.</p>
<h2><a class="header" href="#the-substrate-service" id="the-substrate-service">The Substrate Service</a></h2>
<p>The <a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sc_service/index.html">Substrate Service</a> is the main
coordinator of the various parts of a Substrate node, including consensus. The service is large and
takes many parameters, so in each node, it is put together in a dedicated <code>src/service.rs</code> file.</p>
<p>The particular part of the service that is relevant here is
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sc_service/trait.ImportQueue.html"><code>ImportQueue</code></a>.
Here we construct an instance of the
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sc_consensus_pow/struct.PowBlockImport.html"><code>PowBlockImport</code> struct</a>,
providing it with references to our client, our <code>MinimalSha3Algorithm</code>, and some other necessary
data.</p>
<pre><code class="language-rust ignore">let pow_block_import = sc_consensus_pow::PowBlockImport::new(
	client.clone(),
	client.clone(),
	sha3pow::MinimalSha3Algorithm,
	0, // check inherents starting at block 0
	Some(select_chain.clone()),
	inherent_data_providers.clone(),
);

let import_queue = sc_consensus_pow::import_queue(
	Box::new(pow_block_import.clone()),
	None,
	None,
	sha3pow::MinimalSha3Algorithm,
	inherent_data_providers.clone(),
	&amp;task_manager.spawn_handle(),
	config.prometheus_registry(),
)?;
</code></pre>
<p>Once the <code>PowBlockImport</code> is constructed, we can use it to create an actual import queue that the
service will use for importing blocks into the client.</p>
<h3><a class="header" href="#the-block-import-pipeline" id="the-block-import-pipeline">The Block Import Pipeline</a></h3>
<p>You may have noticed that when we created the <code>PowBlockImport</code> we gave it two separate references to
the client. The second reference will always be to a client. But the first is interesting. The
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sc_consensus_pow/struct.PowBlockImport.html#method.new">rustdocs tell us</a>
that the first parameter is <code>inner: BlockImport&lt;B, Transaction = TransactionFor&lt;C, B&gt;&gt;</code>. Why would a
block import have a reference to another block import? Because the &quot;block import pipeline&quot; is
constructed in an onion-like fashion, where one layer of block import wraps the next. Learn more
about this pattern in the knowledgebase article on the
<a href="https://substrate.dev/docs/en/knowledgebase/advanced/block-import">block import pipeline</a>.</p>
<h3><a class="header" href="#inherent-data-providers" id="inherent-data-providers">Inherent Data Providers</a></h3>
<p>Both the BlockImport and the <code>import_queue</code> are given an instance called <code>inherent_data_providers</code>.
This object is created in a helper function defined at the beginning of <code>service.rs</code></p>
<pre><code class="language-rust ignore">pub fn build_inherent_data_providers() -&gt; Result&lt;InherentDataProviders, ServiceError&gt; {
	let providers = InherentDataProviders::new();

	providers
		.register_provider(sp_timestamp::InherentDataProvider)
		.map_err(Into::into)
		.map_err(sp_consensus::error::Error::InherentData)?;

	Ok(providers)
}
</code></pre>
<p>Anything that implements the
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sp_inherents/trait.ProvideInherentData.html"><code>ProvideInherentData</code> trait</a>
may be used here. The block authoring logic must supply all inherents that the runtime expects. In
the case of this basic-pow chain, that is just the
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sp_timestamp/trait.TimestampInherentData.html"><code>TimestampInherentData</code></a>
expected by the <a href="https://substrate.dev/rustdocs/v2.0.0-rc6/pallet_timestamp/index.html">timestamp pallet</a>. In order
to register other inherents, you would call <code>register_provider</code> multiple times, and map errors
accordingly.</p>
<h2><a class="header" href="#mining-1" id="mining-1">Mining</a></h2>
<p>We've already implemented a mining algorithm as part of our
<a href="./sha3-pow-consensus.html"><code>MinimalSha3Algorithm</code></a>, but we haven't yet told our service to actually
mine with that algorithm. This is our last task in the <code>new_full</code> function.</p>
<pre><code class="language-rust ignore">if is_authority {
	let proposer = sc_basic_authorship::ProposerFactory::new(
		client.clone(),
		transaction_pool,
		prometheus_registry.as_ref(),
	);

	// The number of rounds of mining to try in a single call
	let rounds = 500;

	let can_author_with =
		sp_consensus::CanAuthorWithNativeVersion::new(client.executor().clone());

	sc_consensus_pow::start_mine(
		Box::new(block_import),
		client,
		MinimalSha3Algorithm,
		proposer,
		None, // No preruntime digests
		rounds,
		network,
		std::time::Duration::new(2, 0),
		Some(select_chain),
		inherent_data_providers,
		can_author_with,
	);
}
</code></pre>
<p>We begin by testing whether this node participates in consensus, which is to say we check whether
the user wants the node to act as a miner. If this node is to be a miner, we gather references to
various parts of the node that the
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sc_consensus_pow/fn.start_mine.html"><code>start_mine</code> function</a> requires, and
define that we will attempt 500 rounds of mining for each block before pausing. Finally we call
<code>start_mine</code>.</p>
<h2><a class="header" href="#the-light-client" id="the-light-client">The Light Client</a></h2>
<p>The last thing in the <code>service.rs</code> file is constructing the
<a href="https://www.parity.io/what-is-a-light-client/">light client</a>'s service. This code is quite similar
to the construction of the full service.</p>
<h2><a class="header" href="#note-of-finality" id="note-of-finality">Note of Finality</a></h2>
<p>If we run the <code>basic-pow</code> node now, we see in console logs, that the finalized block always remains
at 0.</p>
<pre><code>...
2020-03-22 12:50:09 Starting consensus session on top of parent 0x85811577d1033e918b425380222fd8c5aef980f81fa843d064d80fe027c79f5a
2020-03-22 12:50:09 Imported #189 (0x8581‚Ä¶9f5a)
2020-03-22 12:50:09 Prepared block for proposing at 190 [hash: 0xdd83ba96582acbed59aacd5304a9258962d1d4c2180acb8b77f725bd81461c4f; parent_hash: 0x8581‚Ä¶9f5a; extrinsics (1): [0x77a5‚Ä¶f7ad]]
2020-03-22 12:50:10 Idle (1 peers), best: #189 (0x8581‚Ä¶9f5a), finalized #0 (0xff0d‚Ä¶5cb9), ‚¨á 0.2kiB/s ‚¨Ü 0.4kiB/s
2020-03-22 12:50:15 Idle (1 peers), best: #189 (0x8581‚Ä¶9f5a), finalized #0 (0xff0d‚Ä¶5cb9), ‚¨á 0 ‚¨Ü 0
</code></pre>
<p>This is expected because Proof of Work is a consensus mechanism with probabilistic finality. This
means a block is never truly finalized and can always be reverted. The further behind the blockchain
head a block is, the less likely it is going to be reverted.</p>
<h1><a class="header" href="#hybrid-consensus" id="hybrid-consensus">Hybrid Consensus</a></h1>
<p><code>nodes/hybrid-consensus</code>
<a href="https://playground-staging.substrate.dev/?deploy=recipes&amp;files=%2Fhome%2Fsubstrate%2Fworkspace%2Fnodes%2Fhybrid-consensus%2Fsrc%2Flib.rs">
<img src="https://img.shields.io/badge/Playground-Try%20it!-brightgreen?logo=Parity%20Substrate" alt="Try on playground" />
</a>
<a href="https://github.com/substrate-developer-hub/recipes/tree/master/nodes/hybrid-consensus/src/lib.rs">
<img src="https://img.shields.io/badge/Github-View%20Code-brightgreen?logo=github" alt="View on GitHub" />
</a></p>
<p>This recipe demonstrates a Substrate-based node that employs hybrid consensus. Specifically, it uses
<a href="./sha3-pow-consensus.html">Sha3 Proof of Work</a> to dictate block authoring, and the
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sc_finality_grandpa/index.html">Grandpa</a> finality gadget to provide
<a href="https://substrate.dev/docs/en/knowledgebase/advanced/consensus#finality">deterministic finality</a>. The minimal proof
of work consensus lives entirely outside of the runtime while the grandpa finality obtains its
authorities from the runtime via the
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sp_finality_grandpa/trait.GrandpaApi.html">GrandpaAPI</a>. Understanding this
recipe requires familiarity with Substrate's
<a href="https://substrate.dev/docs/en/knowledgebase/advanced/block-import">block import pipeline</a>.</p>
<h2><a class="header" href="#the-block-import-pipeline-1" id="the-block-import-pipeline-1">The Block Import Pipeline</a></h2>
<p>Substrate's block import pipeline is structured like an onion in the sense that it is layered. A
Substrate node can compose pieces of block import logic by wrapping block imports in other block
imports. In this node we need to ensure that blocks are valid according to both Pow <em>and</em> grandpa.
So we will construct a block import for each of them and wrap one with the other. The end of the
block import pipeline is always the client, which contains the underlying database of imported
blocks. Learn more about the <a href="https://substrate.dev/docs/en/knowledgebase/advanced/block-import">block import pipeline</a> in the Substrate knowledgebase.</p>
<p>We begin by creating the block import for grandpa. In addition to the block import itself, we get
back a <code>grandpa_link</code>. This link is a channel over which the block import can communicate with the
background task that actually casts grandpa votes. The
<a href="https://research.web3.foundation/en/latest/polkadot/GRANDPA.html">details of the grandpa protocol</a>
are beyond the scope of this recipe.</p>
<pre><code class="language-rust ignore">let (grandpa_block_import, grandpa_link) = sc_finality_grandpa::block_import(
	client.clone(),
	&amp;(client.clone() as std::sync::Arc&lt;_&gt;),
	select_chain.clone(),
)?;
</code></pre>
<p>With the grandpa block import created, we can now create the PoW block import. The Pow block import
is the outer-most layer of the block import onion and it wraps the grandpa block import.</p>
<pre><code class="language-rust ignore">let pow_block_import = sc_consensus_pow::PowBlockImport::new(
	grandpa_block_import,
	client.clone(),
	sha3pow::MinimalSha3Algorithm,
	0, // check inherents starting at block 0
	Some(select_chain.clone()),
	inherent_data_providers.clone(),
);
</code></pre>
<h2><a class="header" href="#the-import-queue-1" id="the-import-queue-1">The Import Queue</a></h2>
<p>With the block imports setup, we can proceed to creating the import queue. We make it using PoW's
<code>import_queue</code> helper function. Notice that it requires the entire block import pipeline which we
refer to as <code>pow_block_import</code> because PoW is the outermost layer.</p>
<pre><code class="language-rust ignore">let import_queue = sc_consensus_pow::import_queue(
	Box::new(pow_block_import.clone()),
	None,
	None,
	sha3pow::MinimalSha3Algorithm,
	inherent_data_providers.clone(),
	&amp;task_manager.spawn_handle(),
	config.prometheus_registry(),
)?;
</code></pre>
<h2><a class="header" href="#the-finality-proof-provider" id="the-finality-proof-provider">The Finality Proof Provider</a></h2>
<p>Occasionally in the operation of a blockchain, other nodes will contact our node asking for proof
that a particular block is finalized. To respond to these requests, we include a finality proof
provider.</p>
<pre><code class="language-rust ignore">let provider = client.clone() as Arc&lt;dyn StorageAndProofProvider&lt;_, _&gt;&gt;;
let finality_proof_provider =
	Arc::new(GrandpaFinalityProofProvider::new(backend.clone(), provider));
</code></pre>
<h2><a class="header" href="#spawning-the-pow-authorship-task" id="spawning-the-pow-authorship-task">Spawning the PoW Authorship Task</a></h2>
<p>Any node that is acting as an authority, typically called &quot;miners&quot; in the PoW context, must run a
mining task in another thread.</p>
<pre><code class="language-rust ignore">sc_consensus_pow::start_mine(
	Box::new(block_import),
	client.clone(),
	MinimalSha3Algorithm,
	proposer,
	None, // TODO Do I need some grandpa preruntime digests?
	rounds,
	network.clone(),
	std::time::Duration::new(2, 0),
	Some(select_chain),
	inherent_data_providers.clone(),
	can_author_with,
);
</code></pre>
<p>The use of a separate thread for block authorship is unlike other Substrate-based authorship tasks
which are typically run as <code>async</code> futures. Because mining is a CPU intensive process, it is
necessary to provide a separate thread or else the mining task would run continually and other tasks
such as transaction processing, gossiping, and peer discovery would be starved for CPU.</p>
<h2><a class="header" href="#spawning-the-grandpa-task" id="spawning-the-grandpa-task">Spawning the Grandpa Task</a></h2>
<p>Grandpa is <em>not</em> CPU intensive, so we will use a standard <code>async</code> worker to listen to and cast
grandpa votes. We begin by creating a grandpa
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sc_finality_grandpa/struct.Config.html"><code>Config</code></a>.</p>
<pre><code class="language-rust ignore">let grandpa_config = sc_finality_grandpa::Config {
	gossip_duration: Duration::from_millis(333),
	justification_period: 512,
	name: Some(name),
	observer_enabled: false,
	keystore,
	is_authority: is_network_authority,
};
</code></pre>
<p>We can then use this config to create an instance of
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sc_finality_grandpa/struct.GrandpaParams.html"><code>GrandpaParams</code></a>.</p>
<pre><code class="language-rust ignore">let grandpa_config = sc_finality_grandpa::GrandpaParams {
	config: grandpa_config,
	link: grandpa_link,
	network,
	inherent_data_providers,
	telemetry_on_connect: Some(telemetry_on_connect_sinks.on_connect_stream()),
	voting_rule: sc_finality_grandpa::VotingRulesBuilder::default().build(),
	prometheus_registry,
	shared_voter_state: sc_finality_grandpa::SharedVoterState::empty(),
};
</code></pre>
<p>With the parameters established, we can now create and spawn the authorship future.</p>
<pre><code class="language-rust ignore">task_manager.spawn_essential_handle().spawn_blocking(
	&quot;grandpa-voter&quot;,
	sc_finality_grandpa::run_grandpa_voter(grandpa_config)?
);
</code></pre>
<h3><a class="header" href="#disabled-grandpa" id="disabled-grandpa">Disabled Grandpa</a></h3>
<p>Proof of Authority networks generally contain many full nodes that are not authorities. When Grandpa
is present in the network, we still need to tell the node how to interpret grandpa-related messages
it may receive (just ignore them).</p>
<pre><code class="language-rust ignore">sc_finality_grandpa::setup_disabled_grandpa(
	client,
	&amp;inherent_data_providers,
	network,
)?;
</code></pre>
<h2><a class="header" href="#constraints-on-the-runtime" id="constraints-on-the-runtime">Constraints on the Runtime</a></h2>
<h3><a class="header" href="#runtime-apis-1" id="runtime-apis-1">Runtime APIs</a></h3>
<p>Grandpa relies on getting its authority sets from the runtime via the
<a href="https://substrate.dev/rustdocs/v2.0.0-rc6/sp_finality_grandpa/trait.GrandpaApi.html">GrandpaAPI</a>. So trying to build
this node with a runtime that does not provide this API will fail to compile. For that reason, we
have included the dedicated <code>minimal-grandpa-runtime</code>.</p>
<p>The opposite is not true, however. A node that does <em>not</em> require grandpa may use the
<code>minimal-grandpa-runtime</code> successfully. The unused <code>GrandpaAPI</code> will remain as a harmless vestige in
the runtime.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src=".analytics/load.js"></script>
        
        <script type="text/javascript" src=".analytics/config.js"></script>
        
        <script type="text/javascript" src=".analytics/klaro.min.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
